<template>
  <div class="_sectionsSummary">
    <transition-group
      tag="div"
      name="listComplete"
      class="_allChapters"
      key="allpages"
    >
      <div v-for="(section, index) in sections" :key="section.$path">
        <ChapterPreview
          :section="section"
          :index="index"
          :number_of_sections="sections.length"
          :can_edit="can_edit"
          @open="openSection(section.$path)"
          @moveSection="moveSection"
        />
      </div>
      <div key="'add'" class="_addSection">
        <EditBtn
          v-if="can_edit"
          :btn_type="'add'"
          :is_unfolded="true"
          @click="createSection"
        />
      </div>
    </transition-group>
  </div>
</template>
<script>
import ChapterPreview from "@/components/publications/markdown/ChapterPreview.vue";

export default {
  props: {
    publication: Object,
    sections: Array,
    opened_section_meta_filename: String,
    can_edit: Boolean,
  },
  components: { ChapterPreview },
  data() {
    return {};
  },
  created() {},
  mounted() {
    if (this.can_edit && this.sections.length === 0) this.createSection();
  },
  beforeDestroy() {},
  watch: {
    opened_section_meta_filename() {
      this.openFirstSectionIfNoneOpened();
    },
  },
  computed: {
    is_associated_to_map() {
      return this.$getMapOptions;
    },
    new_section_title() {
      let idx = this.sections.length + 1;
      const makeTitle = (i) => this.$t("section") + " " + i;

      let new_section_title = makeTitle(idx);
      while (this.sections.some((s) => s.section_title === new_section_title)) {
        idx++;
        new_section_title = makeTitle(idx);
      }
      return new_section_title;
    },
    opened_section() {
      return this.sections.find(
        (s) => this.getFilename(s.$path) === this.opened_section_meta_filename
      );
    },
  },
  methods: {
    openSection(path) {
      this.$emit("toggleSection", this.getFilename(path));
    },
    openFirstSectionIfNoneOpened() {
      if (this.sections.length > 0 && !this.opened_section_meta_filename) {
        this.$emit("openFirstSection");
      }
    },
    async createSection() {
      const filename = this.new_section_title + " text.txt";
      const { meta_filename } = await this.$api.uploadText({
        path: this.publication.$path,
        filename,
        content: "Contenu du " + this.new_section_title,
        additional_meta: {
          content_type: "markdown",
        },
      });

      const new_section_meta = await this.createSection2({
        publication: this.publication,
        additional_meta: {
          section_title: this.new_section_title,
          main_text_meta: meta_filename,
        },
      });
      this.$emit("toggleSection", new_section_meta);
    },
    async moveSection({ old_position, new_position }) {
      let sections_meta = this.sections.map((s) => ({
        meta_filename: this.getFilename(s.$path),
      }));

      function array_move(arr, old_index, new_index) {
        if (new_index >= arr.length) {
          var k = new_index - arr.length + 1;
          while (k--) {
            arr.push(undefined);
          }
        }
        arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);
        return arr; // for testing
      }

      array_move(sections_meta, old_position, new_position);

      return await this.$api.updateMeta({
        path: this.publication.$path,
        new_meta: {
          sections_list: sections_meta,
        },
      });
    },
  },
};
</script>
<style lang="scss" scoped>
._sectionsSummary {
  position: relative;
  height: 100%;
  overflow: auto;
  background-color: var(--c-gris_clair);

  padding: calc(var(--spacing) / 1);
}

._createSection {
  padding: calc(var(--spacing) / 4);
}

._allChapters {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  // grid-template-rows: repeat(auto-fill, minmax(50px, 1fr));
  gap: calc(var(--spacing) / 2);

  > * {
    background-color: white;
    padding: calc(var(--spacing) / 2);
  }
}

._addSection {
  padding: calc(var(--spacing) / 1) calc(var(--spacing) * 2);
}
</style>
