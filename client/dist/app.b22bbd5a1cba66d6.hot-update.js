"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(typeof self !== 'undefined' ? self : this)["webpackHotUpdateapp"]("app",{

/***/ "./src/adc-core/api.js":
/*!*****************************!*\
  !*** ./src/adc-core/api.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.includes.js */ \"./node_modules/core-js/modules/es.array.includes.js\");\n/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm.js\");\n\n\n\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {\n  return new vue__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n    data: {\n      socket: null,\n      store: {},\n      debug_mode: false,\n      tokenpath: {\n        token: \"\",\n        token_path: \"\"\n      },\n      general_password: \"\",\n      rooms_joined: [],\n      // todo replace is_identified, create route to test\n      is_correctly_logged_in: false,\n      connected: false\n    },\n    created() {},\n    watch: {},\n    methods: {\n      async init({\n        debug_mode\n      }) {\n        this.debug_mode = debug_mode;\n        await this.initSocketio();\n      },\n      async initSocketio() {\n        console.log(\"initSocketio\");\n        this.socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)({\n          autoConnect: false\n        });\n        const sessionID = localStorage.getItem(\"sessionID\");\n        if (sessionID) this.socket.auth = {\n          sessionID\n        };\n        await this._setAuthFromStorage();\n        this.setAuthorizationHeader();\n        if (this.tokenpath.token_path) await this.getCurrentAuthor().catch(() => {});\n        await this.socket.connect();\n\n        // client-side\n        this.socket.on(\"connect\", () => {\n          console.log(\"socket connected\");\n          this.connected = true;\n          console.log(\"connect \" + this.socket.id);\n          this.$eventHub.$emit(\"socketio.connect\", {\n            socketid: this.socket.id\n          });\n        });\n        this.socket.on(\"session\", ({\n          sessionID,\n          userID\n        }) => {\n          // attach the session ID to the next reconnection attempts\n          this.socket.auth = {\n            sessionID\n          };\n          localStorage.setItem(\"sessionID\", sessionID);\n          this.socket.userID = userID;\n        });\n        this.socket.on(\"connect_error\", reason => {\n          console.log(\"socket connect error\");\n          this.$eventHub.$emit(\"socketio.connect_error\", reason);\n        });\n        this.socket.on(\"disconnect\", reason => {\n          console.log(\"socket disconnected\");\n          this.connected = false;\n          this.$eventHub.$emit(\"socketio.disconnect\", reason);\n          this.socket.disconnect();\n          this.emptyStore();\n          this.socket.once(\"connect\", () => {\n            this.rejoinRooms();\n          });\n        });\n        this.socket.onAny((eventName, ...args) => {\n          // truncate long strings in content (long texts for example)\n          const _args = JSON.parse(JSON.stringify(args));\n          if (_args[0].changed_data?.$content) _args[0].changed_data.$content = \"…\";\n          if (_args[0].changed_data?.$thumbs) _args[0].changed_data.$thumbs = \"…\";\n          // if (_args[0].changed_data?.$content)\n          //   _args[0].changed_data.$content =\n          //     _args[0].changed_data?.$content.slice(0, 15) +\n          //     \"[…] (truncated content)\";\n          if (this.debug_mode) this.$alertify.delay(4000).log(`⤓ ` + eventName\n          // + JSON.stringify(_args)\n          );\n        });\n\n        this.socket.on(\"folderCreated\", this.folderCreated);\n        this.socket.on(\"folderUpdated\", this.folderUpdated);\n        this.socket.on(\"folderRemoved\", this.folderRemoved);\n        this.socket.on(\"fileCreated\", this.fileCreated);\n        this.socket.on(\"fileUpdated\", this.fileUpdated);\n        this.socket.on(\"fileRemoved\", this.fileRemoved);\n        this.socket.on(\"taskStatus\", this.taskStatus);\n        this.socket.on(\"taskEnded\", this.taskEnded);\n      },\n      disconnectSocket() {\n        this.socket.disconnect();\n      },\n      reconnectSocket() {\n        this.socket.connect();\n      },\n      join({\n        room\n      }) {\n        // join room only if not tracking\n        if (!this.rooms_joined.includes(room)) this.socket.emit(\"joinRoom\", {\n          room\n        });\n        // we push this room anyway, so that when we remove it we keep tracking until all has been removed\n        this.rooms_joined.push(room);\n      },\n      leave({\n        room\n      }) {\n        const index_to_remove = this.rooms_joined.findIndex(rj => rj === room);\n        this.rooms_joined.splice(index_to_remove, 1);\n        // if room isnt tracked anymore\n        if (!this.rooms_joined.includes(room)) {\n          this.socket.emit(\"leaveRoom\", {\n            room\n          });\n          this.$delete(this.store, room);\n        }\n      },\n      emptyStore() {\n        // called when client disconnects from socket\n        // since we cant be sure of what happens before reconnect, we nuke all store\n        // this.store = {};\n      },\n      async rejoinRooms() {\n        console.log(\"rejoinRooms\");\n        // refresh full content of all rooms tracked\n        const paths = this.rooms_joined.filter((value, index, array) => array.indexOf(value) === index);\n        for (const path of paths) {\n          await this.updateStore(path);\n          this.socket.emit(\"joinRoom\", {\n            room: path\n          });\n        }\n      },\n      // async getAndTrack(path) {\n      //   // getFolders ou getFolder\n      //   const response = await this.$axios.get(path).catch((err) => {\n      // throw this.processError(err);\n      //   });\n      //   const content = response.data;\n      //   // puis join le path en question\n\n      //   // si disconnect, il faut relancer le get, que ça maj\n      //   // l'objet côté component\n      //   // et que ça rejoin la room\n\n      //   return content;\n      // },\n\n      async _setAuthFromStorage() {\n        let auth = {};\n        const tokenpath = localStorage.getItem(\"tokenpath\");\n        try {\n          const {\n            token,\n            token_path\n          } = JSON.parse(tokenpath);\n          auth.token = token;\n          auth.token_path = token_path;\n        } catch (err) {\n          err;\n        }\n        const general_password = localStorage.getItem(\"general_password\");\n        if (general_password) auth.general_password = general_password;\n        if (Object.keys(auth).length === 0) return;\n        const Authorization = JSON.stringify(auth);\n\n        // check with route\n        const response = await this.$axios.get(\"_authCheck\", {\n          headers: {\n            Authorization\n          }\n        });\n        if (auth.general_password) {\n          if (response.data.general_password_is_valid) this.general_password = auth.general_password;else if (response.data.general_password_is_wrong) {\n            this.$alertify.delay(4000).error(response.data.general_password_is_wrong);\n            this.$eventHub.$emit(\"app.prompt_general_password\");\n          }\n        } else if (response.data.general_password_is_wrong) {\n          this.$eventHub.$emit(\"app.prompt_general_password\");\n        }\n        if (auth.token && auth.token_path) if (response.data.token_is_valid) {\n          this.tokenpath.token = auth.token;\n          this.tokenpath.token_path = auth.token_path;\n          // token is valid, get author info\n        } else if (response.data.token_is_wrong) this.$alertify.delay(4000).error(response.data.token_is_wrong);\n\n        // Todo change all this? if a user has a valid token and token_path,\n        // then they must also have access\n        // so for users that are not logged in but have the password,\n        // they should get a token with a path that looks like\n        // token_path: \"/\"\n        // --> meaning they can read content, but not update anything\n      },\n\n      setAuthorizationHeader() {\n        this.$axios.defaults.headers.common[\"Authorization\"] = JSON.stringify({\n          token: this.tokenpath.token,\n          token_path: this.tokenpath.token_path,\n          general_password: this.general_password\n        });\n      },\n      async getCurrentAuthor() {\n        await this.getFolder({\n          path: this.tokenpath.token_path\n        }).catch(err => {\n          throw err;\n          // TODO catch folder no existing: author was removed, for example\n        });\n      },\n\n      folderCreated({\n        path,\n        meta\n      }) {\n        if (!this.store[path]) this.store[path] = new Array();\n        this.store[path].push(meta);\n        this.$set(this.store, meta.$path, meta);\n      },\n      updateProps({\n        changed_data,\n        folder_to_update\n      }) {\n        Object.entries(changed_data).map(([key, value]) => {\n          this.$set(folder_to_update, key, value);\n        });\n      },\n      folderUpdated({\n        path,\n        changed_data\n      }) {\n        // updated folder $path\n        if (Object.prototype.hasOwnProperty.call(this.store, path)) {\n          this.updateProps({\n            changed_data,\n            folder_to_update: this.store[path]\n          });\n        }\n        if (path === \"\") return;\n\n        // parent folder path\n        const parent_folder_path = path.substr(0, path.lastIndexOf(\"/\"));\n        if (Object.prototype.hasOwnProperty.call(this.store, parent_folder_path)) {\n          const folder_to_update = this.store[parent_folder_path].find(f => f.$path === path);\n          this.updateProps({\n            changed_data,\n            folder_to_update\n          });\n        }\n      },\n      folderRemoved({\n        path\n      }) {\n        this.$delete(this.store, path);\n        if (Object.prototype.hasOwnProperty.call(this.store, path)) {\n          this.store.$delete(path);\n        }\n        const parent_folder_path = path.substr(0, path.lastIndexOf(\"/\"));\n        if (Object.prototype.hasOwnProperty.call(this.store, parent_folder_path)) {\n          const folder_index = this.store[parent_folder_path].findIndex(f => f.$path === path);\n          this.store[parent_folder_path].splice(folder_index, 1);\n        }\n        this.$eventHub.$emit(\"folder.removed\", {\n          path\n        });\n      },\n      fileCreated({\n        path_to_folder,\n        meta\n      }) {\n        const folder = this.store[path_to_folder];\n        if (!folder.$files) this.$set(folder, \"$files\", new Array());\n        folder.$files.push(meta);\n      },\n      fileUpdated({\n        path_to_folder,\n        path_to_meta,\n        changed_data\n      }) {\n        const folder = this.store[path_to_folder];\n        const file = folder.$files.find(file => file.$path === path_to_meta);\n        if (file) Object.entries(changed_data).map(([key, value]) => {\n          this.$set(file, key, value);\n        });\n      },\n      fileRemoved({\n        path_to_folder,\n        path_to_meta\n      }) {\n        const folder = this.store[path_to_folder];\n        folder.$files = folder.$files.filter(file => file.$path !== path_to_meta);\n      },\n      async getStoragePath() {\n        const response = await this.$axios.get(`_storagePath`);\n        const storage_path = response.data.pathToUserContent;\n        return storage_path;\n      },\n      taskStatus({\n        task_id,\n        progress\n      }) {\n        this.$eventHub.$emit(\"task.status\", {\n          task_id,\n          progress\n        });\n      },\n      taskEnded({\n        task_id,\n        message\n      }) {\n        this.$eventHub.$emit(\"task.ended\", {\n          task_id,\n          message\n        });\n      },\n      async restartDodoc() {\n        return await this.$axios.post(`_admin`);\n      },\n      async updateStore(path) {\n        const response = await this.$axios.get(path).catch(err => {\n          throw this.processError(err);\n        });\n        const content = response.data;\n        this.folderUpdated({\n          path,\n          changed_data: content\n        });\n        return;\n      },\n      async getFolders({\n        path\n      }) {\n        if (this.store[path]) return this.store[path];\n        const response = await this.$axios.get(path).catch(err => {\n          throw this.processError(err);\n        });\n        const folders = response.data;\n        // folders.map((f) => this.$set(this.store, f.$path, f));\n        this.$set(this.store, path, folders);\n        // we use the store to trigger updates to array if item is updated\n        return this.store[path];\n      },\n      async getFolder({\n        path\n      }) {\n        if (this.store[path]) return this.store[path];\n        const response = await this.$axios.get(path).catch(err => {\n          throw this.processError(err);\n        });\n        const folder = response.data;\n        this.$set(this.store, folder.$path, folder);\n        return this.store[folder.$path];\n      },\n      async getArchives({\n        path\n      }) {\n        const response = await this.$axios.get(path);\n        return response.data;\n      },\n      async getLocalNetworkInfos() {\n        const response = await this.$axios.get(\"_networkInfos\");\n        return response.data;\n      },\n      async createFolder({\n        path,\n        additional_meta\n      }) {\n        path = `${path}/_create`;\n        const response = await this.$axios.post(path, additional_meta).catch(err => {\n          throw this.processError(err);\n        });\n        return response.data.new_folder_slug;\n      },\n      async loginToFolder({\n        path,\n        auth_infos\n      }) {\n        try {\n          const response = await this.$axios.post(`${path}/_login`, auth_infos);\n          const token = response.data.token;\n          this.tokenpath.token = token;\n          this.tokenpath.token_path = path;\n          localStorage.setItem(\"tokenpath\", JSON.stringify({\n            token,\n            token_path: path\n          }));\n          this.setAuthorizationHeader();\n          await this.getCurrentAuthor();\n          return;\n        } catch (err) {\n          throw this.processError(err);\n        }\n      },\n      async logoutFromFolder() {\n        const auth_infos = {\n          token: this.tokenpath.token\n        };\n        const path = this.tokenpath.token_path;\n        try {\n          // remove token locally\n          this.resetToken();\n          // remove token on the server\n          await this.$axios.post(`${path}/_logout`, auth_infos);\n          return;\n        } catch (err) {\n          throw this.processError(err);\n        }\n      },\n      async submitGeneralPassword({\n        password,\n        remember_on_this_device = false\n      }) {\n        // TODO\n        await this.$axios.get(`_authCheck`, {\n          headers: {\n            Authorization: JSON.stringify({\n              general_password: password\n            })\n          }\n        }).catch(err => {\n          throw this.processError(err);\n        });\n        if (remember_on_this_device) localStorage.setItem(\"general_password\", password);\n        this.general_password = password;\n        this.setAuthorizationHeader();\n        return true;\n      },\n      disconnectFromGeneralPassword() {\n        localStorage.setItem(\"general_password\", \"\");\n        this.general_password = \"\";\n        this.setAuthorizationHeader();\n      },\n      async uploadText({\n        path,\n        filename,\n        content = \"\",\n        additional_meta\n      }) {\n        let formData = new FormData();\n        const file = new Blob([content], {\n          type: \"text/plain\"\n        });\n        if (additional_meta) formData.append(filename, JSON.stringify(additional_meta));\n        return await this.uploadFile({\n          path,\n          filename,\n          file,\n          additional_meta\n        });\n      },\n      async uploadFile({\n        path,\n        filename,\n        file,\n        additional_meta,\n        onProgress\n      }) {\n        // if no file binary to send, we'll only create a meta file with additional_meta\n        let data;\n        let headers;\n        if (file) {\n          data = new FormData();\n          data.append(\"file\", file, filename);\n          if (additional_meta) data.append(filename, JSON.stringify(additional_meta));\n          headers = {\n            \"Content-Type\": \"multipart/form-data\"\n          };\n        } else {\n          data = additional_meta;\n        }\n        path = `${path}/_upload`;\n        let res = await this.$axios.post(path, data, {\n          headers,\n          onUploadProgress: progressEvent => {\n            if (onProgress) onProgress(progressEvent);\n          }\n        }).catch(err => {\n          throw this.processError(err);\n        });\n        return res.data.meta_filename;\n      },\n      async copyFile({\n        path,\n        new_meta = {},\n        path_to_destination_folder = \"\"\n      }) {\n        path = `${path}/_copy`;\n        const response = await this.$axios.post(path, {\n          new_meta,\n          path_to_destination_folder\n        }).catch(err => {\n          throw this.processError(err);\n        });\n        return response.data.meta_filename;\n      },\n      async copyFolder({\n        path,\n        new_meta = {},\n        path_to_destination_type = \"\"\n      }) {\n        path = `${path}/_copy`;\n        const response = await this.$axios.post(path, {\n          new_meta,\n          path_to_destination_type\n        }).catch(err => {\n          throw this.processError(err);\n        });\n        return response.data.copy_folder_path;\n      },\n      async remixFolder({\n        path,\n        new_meta = {},\n        path_to_destination_type = \"\"\n      }) {\n        path = `${path}/_remix`;\n        const response = await this.$axios.post(path, {\n          new_meta,\n          path_to_destination_type\n        }).catch(err => {\n          throw this.processError(err);\n        });\n        return response.data.remix_folder_path;\n      },\n      async exportFolder({\n        path,\n        instructions\n      }) {\n        path = `${path}/_export`;\n        const response = await this.$axios.post(path, instructions).catch(err => {\n          throw this.processError(err);\n        });\n        const task_id = response.data.task_id;\n        this.$eventHub.$emit(\"task.started\", {\n          task_id,\n          instructions\n        });\n        return task_id;\n      },\n      async generatePreviewForPublication({\n        path,\n        instructions\n      }) {\n        path = `${path}/_generatePreview`;\n        const response = await this.$axios.post(path, instructions).catch(err => {\n          throw this.processError(err);\n        });\n        const task_id = response.data.task_id;\n        return task_id;\n      },\n      async updateMeta({\n        path,\n        new_meta\n      }) {\n        const response = await this.$axios.patch(path, new_meta).catch(err => {\n          throw this.processError(err);\n        });\n        return response.data;\n      },\n      async updateCover({\n        path,\n        new_cover_data,\n        onProgress\n      }) {\n        path = path + `?cover`;\n        if (typeof new_cover_data === \"string\") {\n          // its a meta filename in that same folder\n          const new_meta = {\n            path_to_meta: new_cover_data\n          };\n          await this.$axios.patch(path, new_meta).catch(err => {\n            throw this.processError(err);\n          });\n        } else if (typeof new_cover_data === \"object\") {\n          let formData = new FormData();\n          const original_filename = new_cover_data.name || \"cover\";\n          formData.append(\"file\", new_cover_data, original_filename);\n          await this.$axios.patch(path, formData, {\n            headers: {\n              \"Content-Type\": \"multipart/form-data\"\n            },\n            onUploadProgress: progressEvent => {\n              if (onProgress) onProgress(progressEvent);\n            }\n          }).catch(err => {\n            throw this.processError(err);\n          });\n        }\n        return;\n      },\n      async deleteItem({\n        path\n      }) {\n        const response = await this.$axios.delete(path).catch(err => {\n          throw this.processError(err);\n        });\n        return response.data;\n      },\n      resetToken() {\n        this.tokenpath.token = \"\";\n        this.tokenpath.token_path = \"\";\n        localStorage.setItem(\"tokenpath\", undefined);\n      },\n      processError(err) {\n        let {\n          code,\n          err_infos\n        } = err?.response?.data;\n        if (code) {\n          if (code === \"token_does_not_exist\") {\n            this.resetToken();\n          } else if (code === \"token_expired\") {\n            this.resetToken();\n          } else if (code === \"submitted_general_password_is_wrong\") {\n            this.$eventHub.$emit(\"app.prompt_general_password\");\n          } else if (code === \"no_general_password_submitted\") {\n            this.$eventHub.$emit(\"app.prompt_general_password\");\n          } else if (code === \"token_not_allowed_must_be_local_admin\") {\n            // this.$alertify.delay(4000).error(\"notifications.action_not_allowed\");\n          } else if (code === \"token_not_allowed_must_be_contributors\") {\n            // this.$alertify.delay(4000).error(\"notifications.action_not_allowed\");\n          } else if (code === \"ENOENT\") code = \"folder_is_missing\";\n          this.$alertify.delay(4000).error(\"Message d’erreur : \" + code);\n          console.error(\"processError – \" + code);\n        } else console.error(\"processError – NO ERROR CODES\");\n        this.setAuthorizationHeader();\n        return {\n          code,\n          err_infos\n        };\n        // this.$alertify.delay(4000).error(err);\n      }\n    },\n\n    computed: {}\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYWRjLWNvcmUvYXBpLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvLi9zcmMvYWRjLWNvcmUvYXBpLmpzP2FkZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW8gfSBmcm9tIFwic29ja2V0LmlvLWNsaWVudFwiO1xuaW1wb3J0IFZ1ZSBmcm9tIFwidnVlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBWdWUoe1xuICAgIGRhdGE6IHtcbiAgICAgIHNvY2tldDogbnVsbCxcbiAgICAgIHN0b3JlOiB7fSxcbiAgICAgIGRlYnVnX21vZGU6IGZhbHNlLFxuICAgICAgdG9rZW5wYXRoOiB7XG4gICAgICAgIHRva2VuOiBcIlwiLFxuICAgICAgICB0b2tlbl9wYXRoOiBcIlwiLFxuICAgICAgfSxcbiAgICAgIGdlbmVyYWxfcGFzc3dvcmQ6IFwiXCIsXG5cbiAgICAgIHJvb21zX2pvaW5lZDogW10sXG5cbiAgICAgIC8vIHRvZG8gcmVwbGFjZSBpc19pZGVudGlmaWVkLCBjcmVhdGUgcm91dGUgdG8gdGVzdFxuICAgICAgaXNfY29ycmVjdGx5X2xvZ2dlZF9pbjogZmFsc2UsXG5cbiAgICAgIGNvbm5lY3RlZDogZmFsc2UsXG4gICAgfSxcbiAgICBjcmVhdGVkKCkge30sXG4gICAgd2F0Y2g6IHt9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGFzeW5jIGluaXQoeyBkZWJ1Z19tb2RlIH0pIHtcbiAgICAgICAgdGhpcy5kZWJ1Z19tb2RlID0gZGVidWdfbW9kZTtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0U29ja2V0aW8oKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBpbml0U29ja2V0aW8oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW5pdFNvY2tldGlvXCIpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IGlvKHtcbiAgICAgICAgICBhdXRvQ29ubmVjdDogZmFsc2UsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHNlc3Npb25JRCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic2Vzc2lvbklEXCIpO1xuICAgICAgICBpZiAoc2Vzc2lvbklEKSB0aGlzLnNvY2tldC5hdXRoID0geyBzZXNzaW9uSUQgfTtcblxuICAgICAgICBhd2FpdCB0aGlzLl9zZXRBdXRoRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgdGhpcy5zZXRBdXRob3JpemF0aW9uSGVhZGVyKCk7XG5cbiAgICAgICAgaWYgKHRoaXMudG9rZW5wYXRoLnRva2VuX3BhdGgpXG4gICAgICAgICAgYXdhaXQgdGhpcy5nZXRDdXJyZW50QXV0aG9yKCkuY2F0Y2goKCkgPT4ge30pO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuc29ja2V0LmNvbm5lY3QoKTtcblxuICAgICAgICAvLyBjbGllbnQtc2lkZVxuICAgICAgICB0aGlzLnNvY2tldC5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwic29ja2V0IGNvbm5lY3RlZFwiKTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJjb25uZWN0IFwiICsgdGhpcy5zb2NrZXQuaWQpO1xuICAgICAgICAgIHRoaXMuJGV2ZW50SHViLiRlbWl0KFwic29ja2V0aW8uY29ubmVjdFwiLCB7XG4gICAgICAgICAgICBzb2NrZXRpZDogdGhpcy5zb2NrZXQuaWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwic2Vzc2lvblwiLCAoeyBzZXNzaW9uSUQsIHVzZXJJRCB9KSA9PiB7XG4gICAgICAgICAgLy8gYXR0YWNoIHRoZSBzZXNzaW9uIElEIHRvIHRoZSBuZXh0IHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAgICAgICAgIHRoaXMuc29ja2V0LmF1dGggPSB7IHNlc3Npb25JRCB9O1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic2Vzc2lvbklEXCIsIHNlc3Npb25JRCk7XG4gICAgICAgICAgdGhpcy5zb2NrZXQudXNlcklEID0gdXNlcklEO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oXCJjb25uZWN0X2Vycm9yXCIsIChyZWFzb24pID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInNvY2tldCBjb25uZWN0IGVycm9yXCIpO1xuICAgICAgICAgIHRoaXMuJGV2ZW50SHViLiRlbWl0KFwic29ja2V0aW8uY29ubmVjdF9lcnJvclwiLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oXCJkaXNjb25uZWN0XCIsIChyZWFzb24pID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInNvY2tldCBkaXNjb25uZWN0ZWRcIik7XG5cbiAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuJGV2ZW50SHViLiRlbWl0KFwic29ja2V0aW8uZGlzY29ubmVjdFwiLCByZWFzb24pO1xuICAgICAgICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLmVtcHR5U3RvcmUoKTtcbiAgICAgICAgICB0aGlzLnNvY2tldC5vbmNlKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlam9pblJvb21zKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc29ja2V0Lm9uQW55KChldmVudE5hbWUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAvLyB0cnVuY2F0ZSBsb25nIHN0cmluZ3MgaW4gY29udGVudCAobG9uZyB0ZXh0cyBmb3IgZXhhbXBsZSlcbiAgICAgICAgICBjb25zdCBfYXJncyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgICAgIGlmIChfYXJnc1swXS5jaGFuZ2VkX2RhdGE/LiRjb250ZW50KVxuICAgICAgICAgICAgX2FyZ3NbMF0uY2hhbmdlZF9kYXRhLiRjb250ZW50ID0gXCLigKZcIjtcbiAgICAgICAgICBpZiAoX2FyZ3NbMF0uY2hhbmdlZF9kYXRhPy4kdGh1bWJzKVxuICAgICAgICAgICAgX2FyZ3NbMF0uY2hhbmdlZF9kYXRhLiR0aHVtYnMgPSBcIuKAplwiO1xuICAgICAgICAgIC8vIGlmIChfYXJnc1swXS5jaGFuZ2VkX2RhdGE/LiRjb250ZW50KVxuICAgICAgICAgIC8vICAgX2FyZ3NbMF0uY2hhbmdlZF9kYXRhLiRjb250ZW50ID1cbiAgICAgICAgICAvLyAgICAgX2FyZ3NbMF0uY2hhbmdlZF9kYXRhPy4kY29udGVudC5zbGljZSgwLCAxNSkgK1xuICAgICAgICAgIC8vICAgICBcIlvigKZdICh0cnVuY2F0ZWQgY29udGVudClcIjtcbiAgICAgICAgICBpZiAodGhpcy5kZWJ1Z19tb2RlKVxuICAgICAgICAgICAgdGhpcy4kYWxlcnRpZnkuZGVsYXkoNDAwMCkubG9nKFxuICAgICAgICAgICAgICBg4qSTIGAgKyBldmVudE5hbWVcbiAgICAgICAgICAgICAgLy8gKyBKU09OLnN0cmluZ2lmeShfYXJncylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNvY2tldC5vbihcImZvbGRlckNyZWF0ZWRcIiwgdGhpcy5mb2xkZXJDcmVhdGVkKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oXCJmb2xkZXJVcGRhdGVkXCIsIHRoaXMuZm9sZGVyVXBkYXRlZCk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZm9sZGVyUmVtb3ZlZFwiLCB0aGlzLmZvbGRlclJlbW92ZWQpO1xuXG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZmlsZUNyZWF0ZWRcIiwgdGhpcy5maWxlQ3JlYXRlZCk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZmlsZVVwZGF0ZWRcIiwgdGhpcy5maWxlVXBkYXRlZCk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZmlsZVJlbW92ZWRcIiwgdGhpcy5maWxlUmVtb3ZlZCk7XG5cbiAgICAgICAgdGhpcy5zb2NrZXQub24oXCJ0YXNrU3RhdHVzXCIsIHRoaXMudGFza1N0YXR1cyk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwidGFza0VuZGVkXCIsIHRoaXMudGFza0VuZGVkKTtcbiAgICAgIH0sXG4gICAgICBkaXNjb25uZWN0U29ja2V0KCkge1xuICAgICAgICB0aGlzLnNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICB9LFxuICAgICAgcmVjb25uZWN0U29ja2V0KCkge1xuICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KCk7XG4gICAgICB9LFxuICAgICAgam9pbih7IHJvb20gfSkge1xuICAgICAgICAvLyBqb2luIHJvb20gb25seSBpZiBub3QgdHJhY2tpbmdcbiAgICAgICAgaWYgKCF0aGlzLnJvb21zX2pvaW5lZC5pbmNsdWRlcyhyb29tKSlcbiAgICAgICAgICB0aGlzLnNvY2tldC5lbWl0KFwiam9pblJvb21cIiwgeyByb29tIH0pO1xuICAgICAgICAvLyB3ZSBwdXNoIHRoaXMgcm9vbSBhbnl3YXksIHNvIHRoYXQgd2hlbiB3ZSByZW1vdmUgaXQgd2Uga2VlcCB0cmFja2luZyB1bnRpbCBhbGwgaGFzIGJlZW4gcmVtb3ZlZFxuICAgICAgICB0aGlzLnJvb21zX2pvaW5lZC5wdXNoKHJvb20pO1xuICAgICAgfSxcbiAgICAgIGxlYXZlKHsgcm9vbSB9KSB7XG4gICAgICAgIGNvbnN0IGluZGV4X3RvX3JlbW92ZSA9IHRoaXMucm9vbXNfam9pbmVkLmZpbmRJbmRleChcbiAgICAgICAgICAocmopID0+IHJqID09PSByb29tXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucm9vbXNfam9pbmVkLnNwbGljZShpbmRleF90b19yZW1vdmUsIDEpO1xuICAgICAgICAvLyBpZiByb29tIGlzbnQgdHJhY2tlZCBhbnltb3JlXG4gICAgICAgIGlmICghdGhpcy5yb29tc19qb2luZWQuaW5jbHVkZXMocm9vbSkpIHtcbiAgICAgICAgICB0aGlzLnNvY2tldC5lbWl0KFwibGVhdmVSb29tXCIsIHsgcm9vbSB9KTtcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5zdG9yZSwgcm9vbSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGVtcHR5U3RvcmUoKSB7XG4gICAgICAgIC8vIGNhbGxlZCB3aGVuIGNsaWVudCBkaXNjb25uZWN0cyBmcm9tIHNvY2tldFxuICAgICAgICAvLyBzaW5jZSB3ZSBjYW50IGJlIHN1cmUgb2Ygd2hhdCBoYXBwZW5zIGJlZm9yZSByZWNvbm5lY3QsIHdlIG51a2UgYWxsIHN0b3JlXG4gICAgICAgIC8vIHRoaXMuc3RvcmUgPSB7fTtcbiAgICAgIH0sXG5cbiAgICAgIGFzeW5jIHJlam9pblJvb21zKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcInJlam9pblJvb21zXCIpO1xuICAgICAgICAvLyByZWZyZXNoIGZ1bGwgY29udGVudCBvZiBhbGwgcm9vbXMgdHJhY2tlZFxuICAgICAgICBjb25zdCBwYXRocyA9IHRoaXMucm9vbXNfam9pbmVkLmZpbHRlcihcbiAgICAgICAgICAodmFsdWUsIGluZGV4LCBhcnJheSkgPT4gYXJyYXkuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4XG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlU3RvcmUocGF0aCk7XG4gICAgICAgICAgdGhpcy5zb2NrZXQuZW1pdChcImpvaW5Sb29tXCIsIHsgcm9vbTogcGF0aCB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIGFzeW5jIGdldEFuZFRyYWNrKHBhdGgpIHtcbiAgICAgIC8vICAgLy8gZ2V0Rm9sZGVycyBvdSBnZXRGb2xkZXJcbiAgICAgIC8vICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLiRheGlvcy5nZXQocGF0aCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgLy8gdGhyb3cgdGhpcy5wcm9jZXNzRXJyb3IoZXJyKTtcbiAgICAgIC8vICAgfSk7XG4gICAgICAvLyAgIGNvbnN0IGNvbnRlbnQgPSByZXNwb25zZS5kYXRhO1xuICAgICAgLy8gICAvLyBwdWlzIGpvaW4gbGUgcGF0aCBlbiBxdWVzdGlvblxuXG4gICAgICAvLyAgIC8vIHNpIGRpc2Nvbm5lY3QsIGlsIGZhdXQgcmVsYW5jZXIgbGUgZ2V0LCBxdWUgw6dhIG1halxuICAgICAgLy8gICAvLyBsJ29iamV0IGPDtHTDqSBjb21wb25lbnRcbiAgICAgIC8vICAgLy8gZXQgcXVlIMOnYSByZWpvaW4gbGEgcm9vbVxuXG4gICAgICAvLyAgIHJldHVybiBjb250ZW50O1xuICAgICAgLy8gfSxcblxuICAgICAgYXN5bmMgX3NldEF1dGhGcm9tU3RvcmFnZSgpIHtcbiAgICAgICAgbGV0IGF1dGggPSB7fTtcblxuICAgICAgICBjb25zdCB0b2tlbnBhdGggPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRva2VucGF0aFwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IHRva2VuLCB0b2tlbl9wYXRoIH0gPSBKU09OLnBhcnNlKHRva2VucGF0aCk7XG4gICAgICAgICAgYXV0aC50b2tlbiA9IHRva2VuO1xuICAgICAgICAgIGF1dGgudG9rZW5fcGF0aCA9IHRva2VuX3BhdGg7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdlbmVyYWxfcGFzc3dvcmQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImdlbmVyYWxfcGFzc3dvcmRcIik7XG4gICAgICAgIGlmIChnZW5lcmFsX3Bhc3N3b3JkKSBhdXRoLmdlbmVyYWxfcGFzc3dvcmQgPSBnZW5lcmFsX3Bhc3N3b3JkO1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhhdXRoKS5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICBjb25zdCBBdXRob3JpemF0aW9uID0gSlNPTi5zdHJpbmdpZnkoYXV0aCk7XG5cbiAgICAgICAgLy8gY2hlY2sgd2l0aCByb3V0ZVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuJGF4aW9zLmdldChcIl9hdXRoQ2hlY2tcIiwge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGF1dGguZ2VuZXJhbF9wYXNzd29yZCkge1xuICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLmdlbmVyYWxfcGFzc3dvcmRfaXNfdmFsaWQpXG4gICAgICAgICAgICB0aGlzLmdlbmVyYWxfcGFzc3dvcmQgPSBhdXRoLmdlbmVyYWxfcGFzc3dvcmQ7XG4gICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2UuZGF0YS5nZW5lcmFsX3Bhc3N3b3JkX2lzX3dyb25nKSB7XG4gICAgICAgICAgICB0aGlzLiRhbGVydGlmeVxuICAgICAgICAgICAgICAuZGVsYXkoNDAwMClcbiAgICAgICAgICAgICAgLmVycm9yKHJlc3BvbnNlLmRhdGEuZ2VuZXJhbF9wYXNzd29yZF9pc193cm9uZyk7XG4gICAgICAgICAgICB0aGlzLiRldmVudEh1Yi4kZW1pdChcImFwcC5wcm9tcHRfZ2VuZXJhbF9wYXNzd29yZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuZGF0YS5nZW5lcmFsX3Bhc3N3b3JkX2lzX3dyb25nKSB7XG4gICAgICAgICAgdGhpcy4kZXZlbnRIdWIuJGVtaXQoXCJhcHAucHJvbXB0X2dlbmVyYWxfcGFzc3dvcmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXV0aC50b2tlbiAmJiBhdXRoLnRva2VuX3BhdGgpXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEudG9rZW5faXNfdmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5wYXRoLnRva2VuID0gYXV0aC50b2tlbjtcbiAgICAgICAgICAgIHRoaXMudG9rZW5wYXRoLnRva2VuX3BhdGggPSBhdXRoLnRva2VuX3BhdGg7XG4gICAgICAgICAgICAvLyB0b2tlbiBpcyB2YWxpZCwgZ2V0IGF1dGhvciBpbmZvXG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5kYXRhLnRva2VuX2lzX3dyb25nKVxuICAgICAgICAgICAgdGhpcy4kYWxlcnRpZnkuZGVsYXkoNDAwMCkuZXJyb3IocmVzcG9uc2UuZGF0YS50b2tlbl9pc193cm9uZyk7XG5cbiAgICAgICAgLy8gVG9kbyBjaGFuZ2UgYWxsIHRoaXM/IGlmIGEgdXNlciBoYXMgYSB2YWxpZCB0b2tlbiBhbmQgdG9rZW5fcGF0aCxcbiAgICAgICAgLy8gdGhlbiB0aGV5IG11c3QgYWxzbyBoYXZlIGFjY2Vzc1xuICAgICAgICAvLyBzbyBmb3IgdXNlcnMgdGhhdCBhcmUgbm90IGxvZ2dlZCBpbiBidXQgaGF2ZSB0aGUgcGFzc3dvcmQsXG4gICAgICAgIC8vIHRoZXkgc2hvdWxkIGdldCBhIHRva2VuIHdpdGggYSBwYXRoIHRoYXQgbG9va3MgbGlrZVxuICAgICAgICAvLyB0b2tlbl9wYXRoOiBcIi9cIlxuICAgICAgICAvLyAtLT4gbWVhbmluZyB0aGV5IGNhbiByZWFkIGNvbnRlbnQsIGJ1dCBub3QgdXBkYXRlIGFueXRoaW5nXG4gICAgICB9LFxuICAgICAgc2V0QXV0aG9yaXphdGlvbkhlYWRlcigpIHtcbiAgICAgICAgdGhpcy4kYXhpb3MuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bXCJBdXRob3JpemF0aW9uXCJdID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHRva2VuOiB0aGlzLnRva2VucGF0aC50b2tlbixcbiAgICAgICAgICB0b2tlbl9wYXRoOiB0aGlzLnRva2VucGF0aC50b2tlbl9wYXRoLFxuICAgICAgICAgIGdlbmVyYWxfcGFzc3dvcmQ6IHRoaXMuZ2VuZXJhbF9wYXNzd29yZCxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgZ2V0Q3VycmVudEF1dGhvcigpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5nZXRGb2xkZXIoe1xuICAgICAgICAgIHBhdGg6IHRoaXMudG9rZW5wYXRoLnRva2VuX3BhdGgsXG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgLy8gVE9ETyBjYXRjaCBmb2xkZXIgbm8gZXhpc3Rpbmc6IGF1dGhvciB3YXMgcmVtb3ZlZCwgZm9yIGV4YW1wbGVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBmb2xkZXJDcmVhdGVkKHsgcGF0aCwgbWV0YSB9KSB7XG4gICAgICAgIGlmICghdGhpcy5zdG9yZVtwYXRoXSkgdGhpcy5zdG9yZVtwYXRoXSA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLnN0b3JlW3BhdGhdLnB1c2gobWV0YSk7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0b3JlLCBtZXRhLiRwYXRoLCBtZXRhKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZVByb3BzKHsgY2hhbmdlZF9kYXRhLCBmb2xkZXJfdG9fdXBkYXRlIH0pIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoY2hhbmdlZF9kYXRhKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldChmb2xkZXJfdG9fdXBkYXRlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBmb2xkZXJVcGRhdGVkKHsgcGF0aCwgY2hhbmdlZF9kYXRhIH0pIHtcbiAgICAgICAgLy8gdXBkYXRlZCBmb2xkZXIgJHBhdGhcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0b3JlLCBwYXRoKSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlUHJvcHMoe1xuICAgICAgICAgICAgY2hhbmdlZF9kYXRhLFxuICAgICAgICAgICAgZm9sZGVyX3RvX3VwZGF0ZTogdGhpcy5zdG9yZVtwYXRoXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoID09PSBcIlwiKSByZXR1cm47XG5cbiAgICAgICAgLy8gcGFyZW50IGZvbGRlciBwYXRoXG4gICAgICAgIGNvbnN0IHBhcmVudF9mb2xkZXJfcGF0aCA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGFzdEluZGV4T2YoXCIvXCIpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0b3JlLCBwYXJlbnRfZm9sZGVyX3BhdGgpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGZvbGRlcl90b191cGRhdGUgPSB0aGlzLnN0b3JlW3BhcmVudF9mb2xkZXJfcGF0aF0uZmluZChcbiAgICAgICAgICAgIChmKSA9PiBmLiRwYXRoID09PSBwYXRoXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVByb3BzKHsgY2hhbmdlZF9kYXRhLCBmb2xkZXJfdG9fdXBkYXRlIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZm9sZGVyUmVtb3ZlZCh7IHBhdGggfSkge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5zdG9yZSwgcGF0aCk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0b3JlLCBwYXRoKSkge1xuICAgICAgICAgIHRoaXMuc3RvcmUuJGRlbGV0ZShwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcmVudF9mb2xkZXJfcGF0aCA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGFzdEluZGV4T2YoXCIvXCIpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0b3JlLCBwYXJlbnRfZm9sZGVyX3BhdGgpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGZvbGRlcl9pbmRleCA9IHRoaXMuc3RvcmVbcGFyZW50X2ZvbGRlcl9wYXRoXS5maW5kSW5kZXgoXG4gICAgICAgICAgICAoZikgPT4gZi4kcGF0aCA9PT0gcGF0aFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5zdG9yZVtwYXJlbnRfZm9sZGVyX3BhdGhdLnNwbGljZShmb2xkZXJfaW5kZXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kZXZlbnRIdWIuJGVtaXQoXCJmb2xkZXIucmVtb3ZlZFwiLCB7IHBhdGggfSk7XG4gICAgICB9LFxuXG4gICAgICBmaWxlQ3JlYXRlZCh7IHBhdGhfdG9fZm9sZGVyLCBtZXRhIH0pIHtcbiAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy5zdG9yZVtwYXRoX3RvX2ZvbGRlcl07XG4gICAgICAgIGlmICghZm9sZGVyLiRmaWxlcykgdGhpcy4kc2V0KGZvbGRlciwgXCIkZmlsZXNcIiwgbmV3IEFycmF5KCkpO1xuICAgICAgICBmb2xkZXIuJGZpbGVzLnB1c2gobWV0YSk7XG4gICAgICB9LFxuICAgICAgZmlsZVVwZGF0ZWQoeyBwYXRoX3RvX2ZvbGRlciwgcGF0aF90b19tZXRhLCBjaGFuZ2VkX2RhdGEgfSkge1xuICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLnN0b3JlW3BhdGhfdG9fZm9sZGVyXTtcbiAgICAgICAgY29uc3QgZmlsZSA9IGZvbGRlci4kZmlsZXMuZmluZCgoZmlsZSkgPT4gZmlsZS4kcGF0aCA9PT0gcGF0aF90b19tZXRhKTtcbiAgICAgICAgaWYgKGZpbGUpXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoY2hhbmdlZF9kYXRhKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy4kc2V0KGZpbGUsIGtleSwgdmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZpbGVSZW1vdmVkKHsgcGF0aF90b19mb2xkZXIsIHBhdGhfdG9fbWV0YSB9KSB7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuc3RvcmVbcGF0aF90b19mb2xkZXJdO1xuICAgICAgICBmb2xkZXIuJGZpbGVzID0gZm9sZGVyLiRmaWxlcy5maWx0ZXIoXG4gICAgICAgICAgKGZpbGUpID0+IGZpbGUuJHBhdGggIT09IHBhdGhfdG9fbWV0YVxuICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgYXN5bmMgZ2V0U3RvcmFnZVBhdGgoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy4kYXhpb3MuZ2V0KGBfc3RvcmFnZVBhdGhgKTtcbiAgICAgICAgY29uc3Qgc3RvcmFnZV9wYXRoID0gcmVzcG9uc2UuZGF0YS5wYXRoVG9Vc2VyQ29udGVudDtcbiAgICAgICAgcmV0dXJuIHN0b3JhZ2VfcGF0aDtcbiAgICAgIH0sXG4gICAgICB0YXNrU3RhdHVzKHsgdGFza19pZCwgcHJvZ3Jlc3MgfSkge1xuICAgICAgICB0aGlzLiRldmVudEh1Yi4kZW1pdChcInRhc2suc3RhdHVzXCIsIHsgdGFza19pZCwgcHJvZ3Jlc3MgfSk7XG4gICAgICB9LFxuICAgICAgdGFza0VuZGVkKHsgdGFza19pZCwgbWVzc2FnZSB9KSB7XG4gICAgICAgIHRoaXMuJGV2ZW50SHViLiRlbWl0KFwidGFzay5lbmRlZFwiLCB7IHRhc2tfaWQsIG1lc3NhZ2UgfSk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgcmVzdGFydERvZG9jKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4kYXhpb3MucG9zdChgX2FkbWluYCk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgdXBkYXRlU3RvcmUocGF0aCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuJGF4aW9zLmdldChwYXRoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5wcm9jZXNzRXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICB0aGlzLmZvbGRlclVwZGF0ZWQoeyBwYXRoLCBjaGFuZ2VkX2RhdGE6IGNvbnRlbnQgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0sXG4gICAgICBhc3luYyBnZXRGb2xkZXJzKHsgcGF0aCB9KSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3JlW3BhdGhdKSByZXR1cm4gdGhpcy5zdG9yZVtwYXRoXTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLiRheGlvcy5nZXQocGF0aCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHRocm93IHRoaXMucHJvY2Vzc0Vycm9yKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmb2xkZXJzID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgLy8gZm9sZGVycy5tYXAoKGYpID0+IHRoaXMuJHNldCh0aGlzLnN0b3JlLCBmLiRwYXRoLCBmKSk7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0b3JlLCBwYXRoLCBmb2xkZXJzKTtcbiAgICAgICAgLy8gd2UgdXNlIHRoZSBzdG9yZSB0byB0cmlnZ2VyIHVwZGF0ZXMgdG8gYXJyYXkgaWYgaXRlbSBpcyB1cGRhdGVkXG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlW3BhdGhdO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGdldEZvbGRlcih7IHBhdGggfSkge1xuICAgICAgICBpZiAodGhpcy5zdG9yZVtwYXRoXSkgcmV0dXJuIHRoaXMuc3RvcmVbcGF0aF07XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLiRheGlvcy5nZXQocGF0aCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHRocm93IHRoaXMucHJvY2Vzc0Vycm9yKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmb2xkZXIgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5zdG9yZSwgZm9sZGVyLiRwYXRoLCBmb2xkZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZVtmb2xkZXIuJHBhdGhdO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGdldEFyY2hpdmVzKHsgcGF0aCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy4kYXhpb3MuZ2V0KHBhdGgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBnZXRMb2NhbE5ldHdvcmtJbmZvcygpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLiRheGlvcy5nZXQoXCJfbmV0d29ya0luZm9zXCIpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBjcmVhdGVGb2xkZXIoeyBwYXRoLCBhZGRpdGlvbmFsX21ldGEgfSkge1xuICAgICAgICBwYXRoID0gYCR7cGF0aH0vX2NyZWF0ZWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy4kYXhpb3NcbiAgICAgICAgICAucG9zdChwYXRoLCBhZGRpdGlvbmFsX21ldGEpXG4gICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucHJvY2Vzc0Vycm9yKGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLm5ld19mb2xkZXJfc2x1ZztcbiAgICAgIH0sXG4gICAgICBhc3luYyBsb2dpblRvRm9sZGVyKHsgcGF0aCwgYXV0aF9pbmZvcyB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLiRheGlvcy5wb3N0KGAke3BhdGh9L19sb2dpbmAsIGF1dGhfaW5mb3MpO1xuICAgICAgICAgIGNvbnN0IHRva2VuID0gcmVzcG9uc2UuZGF0YS50b2tlbjtcblxuICAgICAgICAgIHRoaXMudG9rZW5wYXRoLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgdGhpcy50b2tlbnBhdGgudG9rZW5fcGF0aCA9IHBhdGg7XG5cbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICAgIFwidG9rZW5wYXRoXCIsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHRva2VuLCB0b2tlbl9wYXRoOiBwYXRoIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnNldEF1dGhvcml6YXRpb25IZWFkZXIoKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLmdldEN1cnJlbnRBdXRob3IoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5wcm9jZXNzRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGxvZ291dEZyb21Gb2xkZXIoKSB7XG4gICAgICAgIGNvbnN0IGF1dGhfaW5mb3MgPSB7XG4gICAgICAgICAgdG9rZW46IHRoaXMudG9rZW5wYXRoLnRva2VuLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy50b2tlbnBhdGgudG9rZW5fcGF0aDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyByZW1vdmUgdG9rZW4gbG9jYWxseVxuICAgICAgICAgIHRoaXMucmVzZXRUb2tlbigpO1xuICAgICAgICAgIC8vIHJlbW92ZSB0b2tlbiBvbiB0aGUgc2VydmVyXG4gICAgICAgICAgYXdhaXQgdGhpcy4kYXhpb3MucG9zdChgJHtwYXRofS9fbG9nb3V0YCwgYXV0aF9pbmZvcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnByb2Nlc3NFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBhc3luYyBzdWJtaXRHZW5lcmFsUGFzc3dvcmQoe1xuICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgcmVtZW1iZXJfb25fdGhpc19kZXZpY2UgPSBmYWxzZSxcbiAgICAgIH0pIHtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBhd2FpdCB0aGlzLiRheGlvc1xuICAgICAgICAgIC5nZXQoYF9hdXRoQ2hlY2tgLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IEpTT04uc3RyaW5naWZ5KHsgZ2VuZXJhbF9wYXNzd29yZDogcGFzc3dvcmQgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucHJvY2Vzc0Vycm9yKGVycik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlbWVtYmVyX29uX3RoaXNfZGV2aWNlKVxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiZ2VuZXJhbF9wYXNzd29yZFwiLCBwYXNzd29yZCk7XG5cbiAgICAgICAgdGhpcy5nZW5lcmFsX3Bhc3N3b3JkID0gcGFzc3dvcmQ7XG4gICAgICAgIHRoaXMuc2V0QXV0aG9yaXphdGlvbkhlYWRlcigpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBkaXNjb25uZWN0RnJvbUdlbmVyYWxQYXNzd29yZCgpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJnZW5lcmFsX3Bhc3N3b3JkXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLmdlbmVyYWxfcGFzc3dvcmQgPSBcIlwiO1xuICAgICAgICB0aGlzLnNldEF1dGhvcml6YXRpb25IZWFkZXIoKTtcbiAgICAgIH0sXG5cbiAgICAgIGFzeW5jIHVwbG9hZFRleHQoeyBwYXRoLCBmaWxlbmFtZSwgY29udGVudCA9IFwiXCIsIGFkZGl0aW9uYWxfbWV0YSB9KSB7XG4gICAgICAgIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgQmxvYihbY29udGVudF0sIHsgdHlwZTogXCJ0ZXh0L3BsYWluXCIgfSk7XG5cbiAgICAgICAgaWYgKGFkZGl0aW9uYWxfbWV0YSlcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZmlsZW5hbWUsIEpTT04uc3RyaW5naWZ5KGFkZGl0aW9uYWxfbWV0YSkpO1xuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnVwbG9hZEZpbGUoe1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgZmlsZSxcbiAgICAgICAgICBhZGRpdGlvbmFsX21ldGEsXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHVwbG9hZEZpbGUoeyBwYXRoLCBmaWxlbmFtZSwgZmlsZSwgYWRkaXRpb25hbF9tZXRhLCBvblByb2dyZXNzIH0pIHtcbiAgICAgICAgLy8gaWYgbm8gZmlsZSBiaW5hcnkgdG8gc2VuZCwgd2UnbGwgb25seSBjcmVhdGUgYSBtZXRhIGZpbGUgd2l0aCBhZGRpdGlvbmFsX21ldGFcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGxldCBoZWFkZXJzO1xuXG4gICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgIGRhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlLCBmaWxlbmFtZSk7XG4gICAgICAgICAgaWYgKGFkZGl0aW9uYWxfbWV0YSlcbiAgICAgICAgICAgIGRhdGEuYXBwZW5kKGZpbGVuYW1lLCBKU09OLnN0cmluZ2lmeShhZGRpdGlvbmFsX21ldGEpKTtcbiAgICAgICAgICBoZWFkZXJzID0geyBcIkNvbnRlbnQtVHlwZVwiOiBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBhZGRpdGlvbmFsX21ldGE7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IGAke3BhdGh9L191cGxvYWRgO1xuICAgICAgICBsZXQgcmVzID0gYXdhaXQgdGhpcy4kYXhpb3NcbiAgICAgICAgICAucG9zdChwYXRoLCBkYXRhLCB7XG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgb25VcGxvYWRQcm9ncmVzczogKHByb2dyZXNzRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIG9uUHJvZ3Jlc3MocHJvZ3Jlc3NFdmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucHJvY2Vzc0Vycm9yKGVycik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhLm1ldGFfZmlsZW5hbWU7XG4gICAgICB9LFxuICAgICAgYXN5bmMgY29weUZpbGUoeyBwYXRoLCBuZXdfbWV0YSA9IHt9LCBwYXRoX3RvX2Rlc3RpbmF0aW9uX2ZvbGRlciA9IFwiXCIgfSkge1xuICAgICAgICBwYXRoID0gYCR7cGF0aH0vX2NvcHlgO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuJGF4aW9zXG4gICAgICAgICAgLnBvc3QocGF0aCwgeyBuZXdfbWV0YSwgcGF0aF90b19kZXN0aW5hdGlvbl9mb2xkZXIgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5wcm9jZXNzRXJyb3IoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubWV0YV9maWxlbmFtZTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBjb3B5Rm9sZGVyKHsgcGF0aCwgbmV3X21ldGEgPSB7fSwgcGF0aF90b19kZXN0aW5hdGlvbl90eXBlID0gXCJcIiB9KSB7XG4gICAgICAgIHBhdGggPSBgJHtwYXRofS9fY29weWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy4kYXhpb3NcbiAgICAgICAgICAucG9zdChwYXRoLCB7IG5ld19tZXRhLCBwYXRoX3RvX2Rlc3RpbmF0aW9uX3R5cGUgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5wcm9jZXNzRXJyb3IoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuY29weV9mb2xkZXJfcGF0aDtcbiAgICAgIH0sXG4gICAgICBhc3luYyByZW1peEZvbGRlcih7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG5ld19tZXRhID0ge30sXG4gICAgICAgIHBhdGhfdG9fZGVzdGluYXRpb25fdHlwZSA9IFwiXCIsXG4gICAgICB9KSB7XG4gICAgICAgIHBhdGggPSBgJHtwYXRofS9fcmVtaXhgO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuJGF4aW9zXG4gICAgICAgICAgLnBvc3QocGF0aCwgeyBuZXdfbWV0YSwgcGF0aF90b19kZXN0aW5hdGlvbl90eXBlIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucHJvY2Vzc0Vycm9yKGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLnJlbWl4X2ZvbGRlcl9wYXRoO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGV4cG9ydEZvbGRlcih7IHBhdGgsIGluc3RydWN0aW9ucyB9KSB7XG4gICAgICAgIHBhdGggPSBgJHtwYXRofS9fZXhwb3J0YDtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuJGF4aW9zXG4gICAgICAgICAgLnBvc3QocGF0aCwgaW5zdHJ1Y3Rpb25zKVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnByb2Nlc3NFcnJvcihlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0YXNrX2lkID0gcmVzcG9uc2UuZGF0YS50YXNrX2lkO1xuICAgICAgICB0aGlzLiRldmVudEh1Yi4kZW1pdChcInRhc2suc3RhcnRlZFwiLCB7IHRhc2tfaWQsIGluc3RydWN0aW9ucyB9KTtcbiAgICAgICAgcmV0dXJuIHRhc2tfaWQ7XG4gICAgICB9LFxuICAgICAgYXN5bmMgZ2VuZXJhdGVQcmV2aWV3Rm9yUHVibGljYXRpb24oeyBwYXRoLCBpbnN0cnVjdGlvbnMgfSkge1xuICAgICAgICBwYXRoID0gYCR7cGF0aH0vX2dlbmVyYXRlUHJldmlld2A7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLiRheGlvc1xuICAgICAgICAgIC5wb3N0KHBhdGgsIGluc3RydWN0aW9ucylcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5wcm9jZXNzRXJyb3IoZXJyKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0YXNrX2lkID0gcmVzcG9uc2UuZGF0YS50YXNrX2lkO1xuICAgICAgICByZXR1cm4gdGFza19pZDtcbiAgICAgIH0sXG4gICAgICBhc3luYyB1cGRhdGVNZXRhKHsgcGF0aCwgbmV3X21ldGEgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuJGF4aW9zXG4gICAgICAgICAgLnBhdGNoKHBhdGgsIG5ld19tZXRhKVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnByb2Nlc3NFcnJvcihlcnIpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSxcblxuICAgICAgYXN5bmMgdXBkYXRlQ292ZXIoeyBwYXRoLCBuZXdfY292ZXJfZGF0YSwgb25Qcm9ncmVzcyB9KSB7XG4gICAgICAgIHBhdGggPSBwYXRoICsgYD9jb3ZlcmA7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3X2NvdmVyX2RhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAvLyBpdHMgYSBtZXRhIGZpbGVuYW1lIGluIHRoYXQgc2FtZSBmb2xkZXJcbiAgICAgICAgICBjb25zdCBuZXdfbWV0YSA9IHtcbiAgICAgICAgICAgIHBhdGhfdG9fbWV0YTogbmV3X2NvdmVyX2RhdGEsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBhd2FpdCB0aGlzLiRheGlvcy5wYXRjaChwYXRoLCBuZXdfbWV0YSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5wcm9jZXNzRXJyb3IoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV3X2NvdmVyX2RhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsX2ZpbGVuYW1lID0gbmV3X2NvdmVyX2RhdGEubmFtZSB8fCBcImNvdmVyXCI7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBuZXdfY292ZXJfZGF0YSwgb3JpZ2luYWxfZmlsZW5hbWUpO1xuXG4gICAgICAgICAgYXdhaXQgdGhpcy4kYXhpb3NcbiAgICAgICAgICAgIC5wYXRjaChwYXRoLCBmb3JtRGF0YSwge1xuICAgICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIH0sXG4gICAgICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IChwcm9ncmVzc0V2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIG9uUHJvZ3Jlc3MocHJvZ3Jlc3NFdmVudCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5wcm9jZXNzRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSxcblxuICAgICAgYXN5bmMgZGVsZXRlSXRlbSh7IHBhdGggfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuJGF4aW9zLmRlbGV0ZShwYXRoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5wcm9jZXNzRXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9LFxuXG4gICAgICByZXNldFRva2VuKCkge1xuICAgICAgICB0aGlzLnRva2VucGF0aC50b2tlbiA9IFwiXCI7XG4gICAgICAgIHRoaXMudG9rZW5wYXRoLnRva2VuX3BhdGggPSBcIlwiO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInRva2VucGF0aFwiLCB1bmRlZmluZWQpO1xuICAgICAgfSxcblxuICAgICAgcHJvY2Vzc0Vycm9yKGVycikge1xuICAgICAgICBsZXQgeyBjb2RlLCBlcnJfaW5mb3MgfSA9IGVycj8ucmVzcG9uc2U/LmRhdGE7XG5cbiAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gXCJ0b2tlbl9kb2VzX25vdF9leGlzdFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0VG9rZW4oKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IFwidG9rZW5fZXhwaXJlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0VG9rZW4oKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IFwic3VibWl0dGVkX2dlbmVyYWxfcGFzc3dvcmRfaXNfd3JvbmdcIikge1xuICAgICAgICAgICAgdGhpcy4kZXZlbnRIdWIuJGVtaXQoXCJhcHAucHJvbXB0X2dlbmVyYWxfcGFzc3dvcmRcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSBcIm5vX2dlbmVyYWxfcGFzc3dvcmRfc3VibWl0dGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuJGV2ZW50SHViLiRlbWl0KFwiYXBwLnByb21wdF9nZW5lcmFsX3Bhc3N3b3JkXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gXCJ0b2tlbl9ub3RfYWxsb3dlZF9tdXN0X2JlX2xvY2FsX2FkbWluXCIpIHtcbiAgICAgICAgICAgIC8vIHRoaXMuJGFsZXJ0aWZ5LmRlbGF5KDQwMDApLmVycm9yKFwibm90aWZpY2F0aW9ucy5hY3Rpb25fbm90X2FsbG93ZWRcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSBcInRva2VuX25vdF9hbGxvd2VkX211c3RfYmVfY29udHJpYnV0b3JzXCIpIHtcbiAgICAgICAgICAgIC8vIHRoaXMuJGFsZXJ0aWZ5LmRlbGF5KDQwMDApLmVycm9yKFwibm90aWZpY2F0aW9ucy5hY3Rpb25fbm90X2FsbG93ZWRcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSBcIkVOT0VOVFwiKSBjb2RlID0gXCJmb2xkZXJfaXNfbWlzc2luZ1wiO1xuICAgICAgICAgIHRoaXMuJGFsZXJ0aWZ5LmRlbGF5KDQwMDApLmVycm9yKFwiTWVzc2FnZSBk4oCZZXJyZXVyIDogXCIgKyBjb2RlKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwicHJvY2Vzc0Vycm9yIOKAkyBcIiArIGNvZGUpO1xuICAgICAgICB9IGVsc2UgY29uc29sZS5lcnJvcihcInByb2Nlc3NFcnJvciDigJMgTk8gRVJST1IgQ09ERVNcIik7XG5cbiAgICAgICAgdGhpcy5zZXRBdXRob3JpemF0aW9uSGVhZGVyKCk7XG5cbiAgICAgICAgcmV0dXJuIHsgY29kZSwgZXJyX2luZm9zIH07XG4gICAgICAgIC8vIHRoaXMuJGFsZXJ0aWZ5LmRlbGF5KDQwMDApLmVycm9yKGVycik7XG4gICAgICB9LFxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHt9LFxuICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/adc-core/api.js\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ !function() {
/******/ 	__webpack_require__.h = function() { return "59824a821be1fb57"; }
/******/ }();
/******/ 
/******/ }
);