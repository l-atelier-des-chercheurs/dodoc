/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
((typeof self !== 'undefined' ? self : this)["webpackChunkapp"] = (typeof self !== 'undefined' ? self : this)["webpackChunkapp"] || []).push([["src_adc-core_ui_QRCodeWithLink_vue"],{

/***/ "./src/adc-core/ui/QRCodeWithLink.vue":
/*!********************************************!*\
  !*** ./src/adc-core/ui/QRCodeWithLink.vue ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _QRCodeWithLink_vue_vue_type_template_id_71cc997f_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true& */ \"./src/adc-core/ui/QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true&\");\n/* harmony import */ var _QRCodeWithLink_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./QRCodeWithLink.vue?vue&type=script&lang=js& */ \"./src/adc-core/ui/QRCodeWithLink.vue?vue&type=script&lang=js&\");\n/* harmony import */ var _QRCodeWithLink_vue_vue_type_style_index_0_id_71cc997f_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true& */ \"./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true&\");\n/* harmony import */ var _node_modules_vue_vue_loader_v15_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js */ \"./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\");\n\n\n\n;\n\n\n/* normalize component */\n\nvar component = (0,_node_modules_vue_vue_loader_v15_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n  _QRCodeWithLink_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _QRCodeWithLink_vue_vue_type_template_id_71cc997f_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,\n  _QRCodeWithLink_vue_vue_type_template_id_71cc997f_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,\n  false,\n  null,\n  \"71cc997f\",\n  null\n  \n)\n\n/* hot reload */\nif (true) {\n  var api = __webpack_require__(/*! ./node_modules/vue-hot-reload-api/dist/index.js */ \"./node_modules/vue-hot-reload-api/dist/index.js\")\n  api.install(__webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm.js\"))\n  if (api.compatible) {\n    module.hot.accept()\n    if (!api.isRecorded('71cc997f')) {\n      api.createRecord('71cc997f', component.options)\n    } else {\n      api.reload('71cc997f', component.options)\n    }\n    module.hot.accept(/*! ./QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true& */ \"./src/adc-core/ui/QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true&\", function(__WEBPACK_OUTDATED_DEPENDENCIES__) { /* harmony import */ _QRCodeWithLink_vue_vue_type_template_id_71cc997f_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true& */ \"./src/adc-core/ui/QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true&\");\n(function () {\n      api.rerender('71cc997f', {\n        render: _QRCodeWithLink_vue_vue_type_template_id_71cc997f_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,\n        staticRenderFns: _QRCodeWithLink_vue_vue_type_template_id_71cc997f_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns\n      })\n    })(__WEBPACK_OUTDATED_DEPENDENCIES__); }.bind(this))\n  }\n}\ncomponent.options.__file = \"src/adc-core/ui/QRCodeWithLink.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYWRjLWNvcmUvdWkvUVJDb2RlV2l0aExpbmsudnVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL3NyYy9hZGMtY29yZS91aS9RUkNvZGVXaXRoTGluay52dWU/NTU3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL1FSQ29kZVdpdGhMaW5rLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03MWNjOTk3ZiZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9RUkNvZGVXaXRoTGluay52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL1FSQ29kZVdpdGhMaW5rLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9RUkNvZGVXaXRoTGluay52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD03MWNjOTk3ZiZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjcxY2M5OTdmXCIsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiL1VzZXJzL2xvdWlzL0RvY3VtZW50cy9SRVBPL0xVTUEvY2xpZW50L25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGkvZGlzdC9pbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghYXBpLmlzUmVjb3JkZWQoJzcxY2M5OTdmJykpIHtcbiAgICAgIGFwaS5jcmVhdGVSZWNvcmQoJzcxY2M5OTdmJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZWxvYWQoJzcxY2M5OTdmJywgY29tcG9uZW50Lm9wdGlvbnMpXG4gICAgfVxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9RUkNvZGVXaXRoTGluay52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NzFjYzk5N2Ymc2NvcGVkPXRydWUmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignNzFjYzk5N2YnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9hZGMtY29yZS91aS9RUkNvZGVXaXRoTGluay52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/adc-core/ui/QRCodeWithLink.vue\n");

/***/ }),

/***/ "./src/adc-core/ui/QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true&":
/*!***************************************************************************************!*\
  !*** ./src/adc-core/ui/QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true& ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_vue_vue_loader_v15_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_QRCodeWithLink_vue_vue_type_template_id_71cc997f_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render; },
/* harmony export */   "staticRenderFns": function() { return /* reexport safe */ _node_modules_vue_vue_loader_v15_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_QRCodeWithLink_vue_vue_type_template_id_71cc997f_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns; }
/* harmony export */ });
/* harmony import */ var _node_modules_vue_vue_loader_v15_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_QRCodeWithLink_vue_vue_type_template_id_71cc997f_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true& */ "./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true&");


/***/ }),

/***/ "./src/adc-core/ui/QRCodeWithLink.vue?vue&type=script&lang=js&":
/*!*********************************************************************!*\
  !*** ./src/adc-core/ui/QRCodeWithLink.vue?vue&type=script&lang=js& ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_37_0_rules_0_use_0_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_QRCodeWithLink_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-37[0].rules[0].use[0]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./QRCodeWithLink.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-37[0].rules[0].use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=script&lang=js&\");\n /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_37_0_rules_0_use_0_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_QRCodeWithLink_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYWRjLWNvcmUvdWkvUVJDb2RlV2l0aExpbmsudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJi5qcyIsIm1hcHBpbmdzIjoiOztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vc3JjL2FkYy1jb3JlL3VpL1FSQ29kZVdpdGhMaW5rLnZ1ZT8yOWFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMzdbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vUVJDb2RlV2l0aExpbmsudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTM3WzBdLnJ1bGVzWzBdLnVzZVswXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1FSQ29kZVdpdGhMaW5rLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/adc-core/ui/QRCodeWithLink.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true&":
/*!******************************************************************************************************!*\
  !*** ./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true& ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_clonedRuleSet_19_0_rules_0_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_1_node_modules_vue_vue_loader_v15_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_QRCodeWithLink_vue_vue_type_style_index_0_id_71cc997f_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-style-loader/index.js??clonedRuleSet-19[0].rules[0].use[0]!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!../../../node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true& */ "./node_modules/vue-style-loader/index.js??clonedRuleSet-19[0].rules[0].use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_clonedRuleSet_19_0_rules_0_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_1_node_modules_vue_vue_loader_v15_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_QRCodeWithLink_vue_vue_type_style_index_0_id_71cc997f_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_clonedRuleSet_19_0_rules_0_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_1_node_modules_vue_vue_loader_v15_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_QRCodeWithLink_vue_vue_type_style_index_0_id_71cc997f_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_clonedRuleSet_19_0_rules_0_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_1_node_modules_vue_vue_loader_v15_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_QRCodeWithLink_vue_vue_type_style_index_0_id_71cc997f_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _node_modules_vue_style_loader_index_js_clonedRuleSet_19_0_rules_0_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_1_node_modules_vue_vue_loader_v15_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_19_0_rules_0_use_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_QRCodeWithLink_vue_vue_type_style_index_0_id_71cc997f_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),

/***/ "./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true&":
/*!************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true& ***!
  \************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* binding */ render; },\n/* harmony export */   \"staticRenderFns\": function() { return /* binding */ staticRenderFns; }\n/* harmony export */ });\nvar render = function () {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    { staticClass: \"_QRCodeWithLink\" },\n    [\n      _c(\"div\", { staticClass: \"_link\" }, [\n        _c(\"div\", { staticClass: \"u-inputGroup\" }, [\n          _c(\"input\", {\n            directives: [\n              {\n                name: \"model\",\n                rawName: \"v-model\",\n                value: _vm.local_url,\n                expression: \"local_url\",\n              },\n            ],\n            ref: \"urlToCopy\",\n            staticClass: \"_urlInput\",\n            attrs: { type: \"text\" },\n            domProps: { value: _vm.local_url },\n            on: {\n              input: function ($event) {\n                if ($event.target.composing) {\n                  return\n                }\n                _vm.local_url = $event.target.value\n              },\n            },\n          }),\n          _c(\n            \"button\",\n            {\n              staticClass: \"u-button u-button_icon u-suffix _clipboardBtn\",\n              attrs: { type: \"button\" },\n              on: { click: _vm.copyToClipboard },\n            },\n            [\n              !_vm.is_copied\n                ? _c(\"b-icon\", { attrs: { icon: \"clipboard\" } })\n                : _c(\"b-icon\", { attrs: { icon: \"clipboard-check\" } }),\n            ],\n            1\n          ),\n        ]),\n        _c(\n          \"a\",\n          {\n            staticClass: \"u-buttonLink\",\n            attrs: { href: _vm.local_url, target: \"_blank\" },\n          },\n          [\n            _vm._v(\" \" + _vm._s(_vm.$t(\"open\")) + \" \"),\n            _c(\"b-icon\", {\n              attrs: { slot: \"prefix\", icon: \"box-arrow-up-right\" },\n              slot: \"prefix\",\n            }),\n          ],\n          1\n        ),\n      ]),\n      _c(\"transition\", { attrs: { name: \"pagechange\", mode: \"out-in\" } }, [\n        _c(\n          \"div\",\n          { key: _vm.local_url, staticClass: \"_qr\" },\n          [\n            _c(\n              \"div\",\n              { staticClass: \"_fsButton\" },\n              [\n                _c(\"EditBtn\", {\n                  attrs: { btn_type: \"fullscreen\" },\n                  on: {\n                    click: function ($event) {\n                      _vm.show_fullscreen = true\n                    },\n                  },\n                }),\n              ],\n              1\n            ),\n            _c(\"qrcode\", {\n              ref: \"qrCode\",\n              attrs: {\n                value: _vm.local_url,\n                tag: \"canvas\",\n                options: _vm.qr_options,\n              },\n            }),\n            _vm.show_fullscreen\n              ? _c(\n                  \"FullscreenView\",\n                  {\n                    on: {\n                      close: function ($event) {\n                        _vm.show_fullscreen = false\n                      },\n                    },\n                  },\n                  [\n                    _c(\"qrcode\", {\n                      ref: \"qrCode\",\n                      attrs: {\n                        value: _vm.local_url,\n                        tag: \"canvas\",\n                        options: _vm.qr_options,\n                      },\n                    }),\n                  ],\n                  1\n                )\n              : _vm._e(),\n          ],\n          1\n        ),\n      ]),\n      _c(\"small\", [\n        _c(\n          \"a\",\n          { staticClass: \"u-buttonLink\", on: { click: _vm.downloadCanvas } },\n          [_vm._v(\" \" + _vm._s(_vm.$t(\"download_this_qr_code\")) + \" \")]\n        ),\n      ]),\n    ],\n    1\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvYWRjLWNvcmUvdWkvUVJDb2RlV2l0aExpbmsudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTcxY2M5OTdmJnNjb3BlZD10cnVlJi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL3NyYy9hZGMtY29yZS91aS9RUkNvZGVXaXRoTGluay52dWU/Nzc0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwiX1FSQ29kZVdpdGhMaW5rXCIgfSxcbiAgICBbXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIl9saW5rXCIgfSwgW1xuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInUtaW5wdXRHcm91cFwiIH0sIFtcbiAgICAgICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmxvY2FsX3VybCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImxvY2FsX3VybFwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHJlZjogXCJ1cmxUb0NvcHlcIixcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIl91cmxJbnB1dFwiLFxuICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJ0ZXh0XCIgfSxcbiAgICAgICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0ubG9jYWxfdXJsIH0sXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBpbnB1dDogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF92bS5sb2NhbF91cmwgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidS1idXR0b24gdS1idXR0b25faWNvbiB1LXN1ZmZpeCBfY2xpcGJvYXJkQnRuXCIsXG4gICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5jb3B5VG9DbGlwYm9hcmQgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICFfdm0uaXNfY29waWVkXG4gICAgICAgICAgICAgICAgPyBfYyhcImItaWNvblwiLCB7IGF0dHJzOiB7IGljb246IFwiY2xpcGJvYXJkXCIgfSB9KVxuICAgICAgICAgICAgICAgIDogX2MoXCJiLWljb25cIiwgeyBhdHRyczogeyBpY29uOiBcImNsaXBib2FyZC1jaGVja1wiIH0gfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICksXG4gICAgICAgIF0pLFxuICAgICAgICBfYyhcbiAgICAgICAgICBcImFcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ1LWJ1dHRvbkxpbmtcIixcbiAgICAgICAgICAgIGF0dHJzOiB7IGhyZWY6IF92bS5sb2NhbF91cmwsIHRhcmdldDogXCJfYmxhbmtcIiB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgX3ZtLl92KFwiIFwiICsgX3ZtLl9zKF92bS4kdChcIm9wZW5cIikpICsgXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJiLWljb25cIiwge1xuICAgICAgICAgICAgICBhdHRyczogeyBzbG90OiBcInByZWZpeFwiLCBpY29uOiBcImJveC1hcnJvdy11cC1yaWdodFwiIH0sXG4gICAgICAgICAgICAgIHNsb3Q6IFwicHJlZml4XCIsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKSxcbiAgICAgIF0pLFxuICAgICAgX2MoXCJ0cmFuc2l0aW9uXCIsIHsgYXR0cnM6IHsgbmFtZTogXCJwYWdlY2hhbmdlXCIsIG1vZGU6IFwib3V0LWluXCIgfSB9LCBbXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBrZXk6IF92bS5sb2NhbF91cmwsIHN0YXRpY0NsYXNzOiBcIl9xclwiIH0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiX2ZzQnV0dG9uXCIgfSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIF9jKFwiRWRpdEJ0blwiLCB7XG4gICAgICAgICAgICAgICAgICBhdHRyczogeyBidG5fdHlwZTogXCJmdWxsc2NyZWVuXCIgfSxcbiAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLnNob3dfZnVsbHNjcmVlbiA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBfYyhcInFyY29kZVwiLCB7XG4gICAgICAgICAgICAgIHJlZjogXCJxckNvZGVcIixcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmxvY2FsX3VybCxcbiAgICAgICAgICAgICAgICB0YWc6IFwiY2FudmFzXCIsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogX3ZtLnFyX29wdGlvbnMsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF92bS5zaG93X2Z1bGxzY3JlZW5cbiAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgIFwiRnVsbHNjcmVlblZpZXdcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnNob3dfZnVsbHNjcmVlbiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIF9jKFwicXJjb2RlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICByZWY6IFwicXJDb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0ubG9jYWxfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBcImNhbnZhc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogX3ZtLnFyX29wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKSxcbiAgICAgIF0pLFxuICAgICAgX2MoXCJzbWFsbFwiLCBbXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwiYVwiLFxuICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwidS1idXR0b25MaW5rXCIsIG9uOiB7IGNsaWNrOiBfdm0uZG93bmxvYWRDYW52YXMgfSB9LFxuICAgICAgICAgIFtfdm0uX3YoXCIgXCIgKyBfdm0uX3MoX3ZtLiR0KFwiZG93bmxvYWRfdGhpc19xcl9jb2RlXCIpKSArIFwiIFwiKV1cbiAgICAgICAgKSxcbiAgICAgIF0pLFxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=template&id=71cc997f&scoped=true&\n");

/***/ }),

/***/ "./node_modules/@chenfengyuan/vue-qrcode/dist/vue-qrcode.js":
/*!******************************************************************!*\
  !*** ./node_modules/@chenfengyuan/vue-qrcode/dist/vue-qrcode.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n__webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.at.js */ \"./node_modules/core-js/modules/es.typed-array.at.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.find-last.js */ \"./node_modules/core-js/modules/es.typed-array.find-last.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.find-last-index.js */ \"./node_modules/core-js/modules/es.typed-array.find-last-index.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.set.js */ \"./node_modules/core-js/modules/es.typed-array.set.js\");\n__webpack_require__(/*! core-js/modules/es.array.includes.js */ \"./node_modules/core-js/modules/es.array.includes.js\");\n/*!\n * vue-qrcode v1.0.2\n * https://fengyuanchen.github.io/vue-qrcode\n *\n * Copyright 2018-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2020-01-18T06:04:33.222Z\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() : 0;\n})(this, function () {\n  'use strict';\n\n  function commonjsRequire() {\n    throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');\n  }\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n  var qrcode = createCommonjsModule(function (module, exports) {\n    (function (f) {\n      {\n        module.exports = f();\n      }\n    })(function () {\n      return function () {\n        function r(e, n, t) {\n          function o(i, f) {\n            if (!n[i]) {\n              if (!e[i]) {\n                var c = \"function\" == typeof commonjsRequire && commonjsRequire;\n                if (!f && c) return c(i, !0);\n                if (u) return u(i, !0);\n                var a = new Error(\"Cannot find module '\" + i + \"'\");\n                throw a.code = \"MODULE_NOT_FOUND\", a;\n              }\n              var p = n[i] = {\n                exports: {}\n              };\n              e[i][0].call(p.exports, function (r) {\n                var n = e[i][1][r];\n                return o(n || r);\n              }, p, p.exports, r, e, n, t);\n            }\n            return n[i].exports;\n          }\n          for (var u = \"function\" == typeof commonjsRequire && commonjsRequire, i = 0; i < t.length; i++) o(t[i]);\n          return o;\n        }\n        return r;\n      }()({\n        1: [function (require, module, exports) {\n          // can-promise has a crash in some versions of react native that dont have\n          // standard global objects\n          // https://github.com/soldair/node-qrcode/issues/157\n\n          module.exports = function () {\n            return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then;\n          };\n        }, {}],\n        2: [function (require, module, exports) {\n          /**\n           * Alignment pattern are fixed reference pattern in defined positions\n           * in a matrix symbology, which enables the decode software to re-synchronise\n           * the coordinate mapping of the image modules in the event of moderate amounts\n           * of distortion of the image.\n           *\n           * Alignment patterns are present only in QR Code symbols of version 2 or larger\n           * and their number depends on the symbol version.\n           */\n\n          var getSymbolSize = require('./utils').getSymbolSize;\n\n          /**\n           * Calculate the row/column coordinates of the center module of each alignment pattern\n           * for the specified QR Code version.\n           *\n           * The alignment patterns are positioned symmetrically on either side of the diagonal\n           * running from the top left corner of the symbol to the bottom right corner.\n           *\n           * Since positions are simmetrical only half of the coordinates are returned.\n           * Each item of the array will represent in turn the x and y coordinate.\n           * @see {@link getPositions}\n           *\n           * @param  {Number} version QR Code version\n           * @return {Array}          Array of coordinate\n           */\n          exports.getRowColCoords = function getRowColCoords(version) {\n            if (version === 1) return [];\n            var posCount = Math.floor(version / 7) + 2;\n            var size = getSymbolSize(version);\n            var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;\n            var positions = [size - 7]; // Last coord is always (size - 7)\n\n            for (var i = 1; i < posCount - 1; i++) {\n              positions[i] = positions[i - 1] - intervals;\n            }\n            positions.push(6); // First coord is always 6\n\n            return positions.reverse();\n          };\n\n          /**\n           * Returns an array containing the positions of each alignment pattern.\n           * Each array's element represent the center point of the pattern as (x, y) coordinates\n           *\n           * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}\n           * and filtering out the items that overlaps with finder pattern\n           *\n           * @example\n           * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.\n           * The alignment patterns, therefore, are to be centered on (row, column)\n           * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).\n           * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns\n           * and are not therefore used for alignment patterns.\n           *\n           * var pos = getPositions(7)\n           * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]\n           *\n           * @param  {Number} version QR Code version\n           * @return {Array}          Array of coordinates\n           */\n          exports.getPositions = function getPositions(version) {\n            var coords = [];\n            var pos = exports.getRowColCoords(version);\n            var posLength = pos.length;\n            for (var i = 0; i < posLength; i++) {\n              for (var j = 0; j < posLength; j++) {\n                // Skip if position is occupied by finder patterns\n                if (i === 0 && j === 0 ||\n                // top-left\n                i === 0 && j === posLength - 1 ||\n                // bottom-left\n                i === posLength - 1 && j === 0) {\n                  // top-right\n                  continue;\n                }\n                coords.push([pos[i], pos[j]]);\n              }\n            }\n            return coords;\n          };\n        }, {\n          \"./utils\": 21\n        }],\n        3: [function (require, module, exports) {\n          var Mode = require('./mode');\n\n          /**\n           * Array of characters available in alphanumeric mode\n           *\n           * As per QR Code specification, to each character\n           * is assigned a value from 0 to 44 which in this case coincides\n           * with the array index\n           *\n           * @type {Array}\n           */\n          var ALPHA_NUM_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', '$', '%', '*', '+', '-', '.', '/', ':'];\n          function AlphanumericData(data) {\n            this.mode = Mode.ALPHANUMERIC;\n            this.data = data;\n          }\n          AlphanumericData.getBitsLength = function getBitsLength(length) {\n            return 11 * Math.floor(length / 2) + 6 * (length % 2);\n          };\n          AlphanumericData.prototype.getLength = function getLength() {\n            return this.data.length;\n          };\n          AlphanumericData.prototype.getBitsLength = function getBitsLength() {\n            return AlphanumericData.getBitsLength(this.data.length);\n          };\n          AlphanumericData.prototype.write = function write(bitBuffer) {\n            var i;\n\n            // Input data characters are divided into groups of two characters\n            // and encoded as 11-bit binary codes.\n            for (i = 0; i + 2 <= this.data.length; i += 2) {\n              // The character value of the first character is multiplied by 45\n              var value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;\n\n              // The character value of the second digit is added to the product\n              value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);\n\n              // The sum is then stored as 11-bit binary number\n              bitBuffer.put(value, 11);\n            }\n\n            // If the number of input data characters is not a multiple of two,\n            // the character value of the final character is encoded as a 6-bit binary number.\n            if (this.data.length % 2) {\n              bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);\n            }\n          };\n          module.exports = AlphanumericData;\n        }, {\n          \"./mode\": 14\n        }],\n        4: [function (require, module, exports) {\n          function BitBuffer() {\n            this.buffer = [];\n            this.length = 0;\n          }\n          BitBuffer.prototype = {\n            get: function (index) {\n              var bufIndex = Math.floor(index / 8);\n              return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;\n            },\n            put: function (num, length) {\n              for (var i = 0; i < length; i++) {\n                this.putBit((num >>> length - i - 1 & 1) === 1);\n              }\n            },\n            getLengthInBits: function () {\n              return this.length;\n            },\n            putBit: function (bit) {\n              var bufIndex = Math.floor(this.length / 8);\n              if (this.buffer.length <= bufIndex) {\n                this.buffer.push(0);\n              }\n              if (bit) {\n                this.buffer[bufIndex] |= 0x80 >>> this.length % 8;\n              }\n              this.length++;\n            }\n          };\n          module.exports = BitBuffer;\n        }, {}],\n        5: [function (require, module, exports) {\n          var BufferUtil = require('../utils/buffer');\n\n          /**\n           * Helper class to handle QR Code symbol modules\n           *\n           * @param {Number} size Symbol size\n           */\n          function BitMatrix(size) {\n            if (!size || size < 1) {\n              throw new Error('BitMatrix size must be defined and greater than 0');\n            }\n            this.size = size;\n            this.data = BufferUtil.alloc(size * size);\n            this.reservedBit = BufferUtil.alloc(size * size);\n          }\n\n          /**\n           * Set bit value at specified location\n           * If reserved flag is set, this bit will be ignored during masking process\n           *\n           * @param {Number}  row\n           * @param {Number}  col\n           * @param {Boolean} value\n           * @param {Boolean} reserved\n           */\n          BitMatrix.prototype.set = function (row, col, value, reserved) {\n            var index = row * this.size + col;\n            this.data[index] = value;\n            if (reserved) this.reservedBit[index] = true;\n          };\n\n          /**\n           * Returns bit value at specified location\n           *\n           * @param  {Number}  row\n           * @param  {Number}  col\n           * @return {Boolean}\n           */\n          BitMatrix.prototype.get = function (row, col) {\n            return this.data[row * this.size + col];\n          };\n\n          /**\n           * Applies xor operator at specified location\n           * (used during masking process)\n           *\n           * @param {Number}  row\n           * @param {Number}  col\n           * @param {Boolean} value\n           */\n          BitMatrix.prototype.xor = function (row, col, value) {\n            this.data[row * this.size + col] ^= value;\n          };\n\n          /**\n           * Check if bit at specified location is reserved\n           *\n           * @param {Number}   row\n           * @param {Number}   col\n           * @return {Boolean}\n           */\n          BitMatrix.prototype.isReserved = function (row, col) {\n            return this.reservedBit[row * this.size + col];\n          };\n          module.exports = BitMatrix;\n        }, {\n          \"../utils/buffer\": 28\n        }],\n        6: [function (require, module, exports) {\n          var BufferUtil = require('../utils/buffer');\n          var Mode = require('./mode');\n          function ByteData(data) {\n            this.mode = Mode.BYTE;\n            this.data = BufferUtil.from(data);\n          }\n          ByteData.getBitsLength = function getBitsLength(length) {\n            return length * 8;\n          };\n          ByteData.prototype.getLength = function getLength() {\n            return this.data.length;\n          };\n          ByteData.prototype.getBitsLength = function getBitsLength() {\n            return ByteData.getBitsLength(this.data.length);\n          };\n          ByteData.prototype.write = function (bitBuffer) {\n            for (var i = 0, l = this.data.length; i < l; i++) {\n              bitBuffer.put(this.data[i], 8);\n            }\n          };\n          module.exports = ByteData;\n        }, {\n          \"../utils/buffer\": 28,\n          \"./mode\": 14\n        }],\n        7: [function (require, module, exports) {\n          var ECLevel = require('./error-correction-level');\n          var EC_BLOCKS_TABLE = [\n          // L  M  Q  H\n          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81];\n          var EC_CODEWORDS_TABLE = [\n          // L  M  Q  H\n          7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];\n\n          /**\r\n           * Returns the number of error correction block that the QR Code should contain\r\n           * for the specified version and error correction level.\r\n           *\r\n           * @param  {Number} version              QR Code version\r\n           * @param  {Number} errorCorrectionLevel Error correction level\r\n           * @return {Number}                      Number of error correction blocks\r\n           */\n          exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {\n            switch (errorCorrectionLevel) {\n              case ECLevel.L:\n                return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];\n              case ECLevel.M:\n                return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];\n              case ECLevel.Q:\n                return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];\n              case ECLevel.H:\n                return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];\n              default:\n                return undefined;\n            }\n          };\n\n          /**\r\n           * Returns the number of error correction codewords to use for the specified\r\n           * version and error correction level.\r\n           *\r\n           * @param  {Number} version              QR Code version\r\n           * @param  {Number} errorCorrectionLevel Error correction level\r\n           * @return {Number}                      Number of error correction codewords\r\n           */\n          exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {\n            switch (errorCorrectionLevel) {\n              case ECLevel.L:\n                return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];\n              case ECLevel.M:\n                return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];\n              case ECLevel.Q:\n                return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];\n              case ECLevel.H:\n                return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];\n              default:\n                return undefined;\n            }\n          };\n        }, {\n          \"./error-correction-level\": 8\n        }],\n        8: [function (require, module, exports) {\n          exports.L = {\n            bit: 1\n          };\n          exports.M = {\n            bit: 0\n          };\n          exports.Q = {\n            bit: 3\n          };\n          exports.H = {\n            bit: 2\n          };\n          function fromString(string) {\n            if (typeof string !== 'string') {\n              throw new Error('Param is not a string');\n            }\n            var lcStr = string.toLowerCase();\n            switch (lcStr) {\n              case 'l':\n              case 'low':\n                return exports.L;\n              case 'm':\n              case 'medium':\n                return exports.M;\n              case 'q':\n              case 'quartile':\n                return exports.Q;\n              case 'h':\n              case 'high':\n                return exports.H;\n              default:\n                throw new Error('Unknown EC Level: ' + string);\n            }\n          }\n          exports.isValid = function isValid(level) {\n            return level && typeof level.bit !== 'undefined' && level.bit >= 0 && level.bit < 4;\n          };\n          exports.from = function from(value, defaultValue) {\n            if (exports.isValid(value)) {\n              return value;\n            }\n            try {\n              return fromString(value);\n            } catch (e) {\n              return defaultValue;\n            }\n          };\n        }, {}],\n        9: [function (require, module, exports) {\n          var getSymbolSize = require('./utils').getSymbolSize;\n          var FINDER_PATTERN_SIZE = 7;\n\n          /**\n           * Returns an array containing the positions of each finder pattern.\n           * Each array's element represent the top-left point of the pattern as (x, y) coordinates\n           *\n           * @param  {Number} version QR Code version\n           * @return {Array}          Array of coordinates\n           */\n          exports.getPositions = function getPositions(version) {\n            var size = getSymbolSize(version);\n            return [\n            // top-left\n            [0, 0],\n            // top-right\n            [size - FINDER_PATTERN_SIZE, 0],\n            // bottom-left\n            [0, size - FINDER_PATTERN_SIZE]];\n          };\n        }, {\n          \"./utils\": 21\n        }],\n        10: [function (require, module, exports) {\n          var Utils = require('./utils');\n          var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;\n          var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;\n          var G15_BCH = Utils.getBCHDigit(G15);\n\n          /**\n           * Returns format information with relative error correction bits\n           *\n           * The format information is a 15-bit sequence containing 5 data bits,\n           * with 10 error correction bits calculated using the (15, 5) BCH code.\n           *\n           * @param  {Number} errorCorrectionLevel Error correction level\n           * @param  {Number} mask                 Mask pattern\n           * @return {Number}                      Encoded format information bits\n           */\n          exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {\n            var data = errorCorrectionLevel.bit << 3 | mask;\n            var d = data << 10;\n            while (Utils.getBCHDigit(d) - G15_BCH >= 0) {\n              d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;\n            }\n\n            // xor final data with mask pattern in order to ensure that\n            // no combination of Error Correction Level and data mask pattern\n            // will result in an all-zero data string\n            return (data << 10 | d) ^ G15_MASK;\n          };\n        }, {\n          \"./utils\": 21\n        }],\n        11: [function (require, module, exports) {\n          var BufferUtil = require('../utils/buffer');\n          var EXP_TABLE = BufferUtil.alloc(512);\n          var LOG_TABLE = BufferUtil.alloc(256)\n          /**\n           * Precompute the log and anti-log tables for faster computation later\n           *\n           * For each possible value in the galois field 2^8, we will pre-compute\n           * the logarithm and anti-logarithm (exponential) of this value\n           *\n           * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}\n           */;\n          (function initTables() {\n            var x = 1;\n            for (var i = 0; i < 255; i++) {\n              EXP_TABLE[i] = x;\n              LOG_TABLE[x] = i;\n              x <<= 1; // multiply by 2\n\n              // The QR code specification says to use byte-wise modulo 100011101 arithmetic.\n              // This means that when a number is 256 or larger, it should be XORed with 0x11D.\n              if (x & 0x100) {\n                // similar to x >= 256, but a lot faster (because 0x100 == 256)\n                x ^= 0x11D;\n              }\n            }\n\n            // Optimization: double the size of the anti-log table so that we don't need to mod 255 to\n            // stay inside the bounds (because we will mainly use this table for the multiplication of\n            // two GF numbers, no more).\n            // @see {@link mul}\n            for (i = 255; i < 512; i++) {\n              EXP_TABLE[i] = EXP_TABLE[i - 255];\n            }\n          })();\n\n          /**\n           * Returns log value of n inside Galois Field\n           *\n           * @param  {Number} n\n           * @return {Number}\n           */\n          exports.log = function log(n) {\n            if (n < 1) throw new Error('log(' + n + ')');\n            return LOG_TABLE[n];\n          };\n\n          /**\n           * Returns anti-log value of n inside Galois Field\n           *\n           * @param  {Number} n\n           * @return {Number}\n           */\n          exports.exp = function exp(n) {\n            return EXP_TABLE[n];\n          };\n\n          /**\n           * Multiplies two number inside Galois Field\n           *\n           * @param  {Number} x\n           * @param  {Number} y\n           * @return {Number}\n           */\n          exports.mul = function mul(x, y) {\n            if (x === 0 || y === 0) return 0;\n\n            // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized\n            // @see {@link initTables}\n            return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];\n          };\n        }, {\n          \"../utils/buffer\": 28\n        }],\n        12: [function (require, module, exports) {\n          var Mode = require('./mode');\n          var Utils = require('./utils');\n          function KanjiData(data) {\n            this.mode = Mode.KANJI;\n            this.data = data;\n          }\n          KanjiData.getBitsLength = function getBitsLength(length) {\n            return length * 13;\n          };\n          KanjiData.prototype.getLength = function getLength() {\n            return this.data.length;\n          };\n          KanjiData.prototype.getBitsLength = function getBitsLength() {\n            return KanjiData.getBitsLength(this.data.length);\n          };\n          KanjiData.prototype.write = function (bitBuffer) {\n            var i;\n\n            // In the Shift JIS system, Kanji characters are represented by a two byte combination.\n            // These byte values are shifted from the JIS X 0208 values.\n            // JIS X 0208 gives details of the shift coded representation.\n            for (i = 0; i < this.data.length; i++) {\n              var value = Utils.toSJIS(this.data[i]);\n\n              // For characters with Shift JIS values from 0x8140 to 0x9FFC:\n              if (value >= 0x8140 && value <= 0x9FFC) {\n                // Subtract 0x8140 from Shift JIS value\n                value -= 0x8140;\n\n                // For characters with Shift JIS values from 0xE040 to 0xEBBF\n              } else if (value >= 0xE040 && value <= 0xEBBF) {\n                // Subtract 0xC140 from Shift JIS value\n                value -= 0xC140;\n              } else {\n                throw new Error('Invalid SJIS character: ' + this.data[i] + '\\n' + 'Make sure your charset is UTF-8');\n              }\n\n              // Multiply most significant byte of result by 0xC0\n              // and add least significant byte to product\n              value = (value >>> 8 & 0xff) * 0xC0 + (value & 0xff);\n\n              // Convert result to a 13-bit binary string\n              bitBuffer.put(value, 13);\n            }\n          };\n          module.exports = KanjiData;\n        }, {\n          \"./mode\": 14,\n          \"./utils\": 21\n        }],\n        13: [function (require, module, exports) {\n          /**\n           * Data mask pattern reference\n           * @type {Object}\n           */\n          exports.Patterns = {\n            PATTERN000: 0,\n            PATTERN001: 1,\n            PATTERN010: 2,\n            PATTERN011: 3,\n            PATTERN100: 4,\n            PATTERN101: 5,\n            PATTERN110: 6,\n            PATTERN111: 7\n          };\n\n          /**\n           * Weighted penalty scores for the undesirable features\n           * @type {Object}\n           */\n          var PenaltyScores = {\n            N1: 3,\n            N2: 3,\n            N3: 40,\n            N4: 10\n          };\n\n          /**\n           * Check if mask pattern value is valid\n           *\n           * @param  {Number}  mask    Mask pattern\n           * @return {Boolean}         true if valid, false otherwise\n           */\n          exports.isValid = function isValid(mask) {\n            return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7;\n          };\n\n          /**\n           * Returns mask pattern from a value.\n           * If value is not valid, returns undefined\n           *\n           * @param  {Number|String} value        Mask pattern value\n           * @return {Number}                     Valid mask pattern or undefined\n           */\n          exports.from = function from(value) {\n            return exports.isValid(value) ? parseInt(value, 10) : undefined;\n          };\n\n          /**\n          * Find adjacent modules in row/column with the same color\n          * and assign a penalty value.\n          *\n          * Points: N1 + i\n          * i is the amount by which the number of adjacent modules of the same color exceeds 5\n          */\n          exports.getPenaltyN1 = function getPenaltyN1(data) {\n            var size = data.size;\n            var points = 0;\n            var sameCountCol = 0;\n            var sameCountRow = 0;\n            var lastCol = null;\n            var lastRow = null;\n            for (var row = 0; row < size; row++) {\n              sameCountCol = sameCountRow = 0;\n              lastCol = lastRow = null;\n              for (var col = 0; col < size; col++) {\n                var module = data.get(row, col);\n                if (module === lastCol) {\n                  sameCountCol++;\n                } else {\n                  if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);\n                  lastCol = module;\n                  sameCountCol = 1;\n                }\n                module = data.get(col, row);\n                if (module === lastRow) {\n                  sameCountRow++;\n                } else {\n                  if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);\n                  lastRow = module;\n                  sameCountRow = 1;\n                }\n              }\n              if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);\n              if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);\n            }\n            return points;\n          };\n\n          /**\n           * Find 2x2 blocks with the same color and assign a penalty value\n           *\n           * Points: N2 * (m - 1) * (n - 1)\n           */\n          exports.getPenaltyN2 = function getPenaltyN2(data) {\n            var size = data.size;\n            var points = 0;\n            for (var row = 0; row < size - 1; row++) {\n              for (var col = 0; col < size - 1; col++) {\n                var last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);\n                if (last === 4 || last === 0) points++;\n              }\n            }\n            return points * PenaltyScores.N2;\n          };\n\n          /**\n           * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\n           * preceded or followed by light area 4 modules wide\n           *\n           * Points: N3 * number of pattern found\n           */\n          exports.getPenaltyN3 = function getPenaltyN3(data) {\n            var size = data.size;\n            var points = 0;\n            var bitsCol = 0;\n            var bitsRow = 0;\n            for (var row = 0; row < size; row++) {\n              bitsCol = bitsRow = 0;\n              for (var col = 0; col < size; col++) {\n                bitsCol = bitsCol << 1 & 0x7FF | data.get(row, col);\n                if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;\n                bitsRow = bitsRow << 1 & 0x7FF | data.get(col, row);\n                if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;\n              }\n            }\n            return points * PenaltyScores.N3;\n          };\n\n          /**\n           * Calculate proportion of dark modules in entire symbol\n           *\n           * Points: N4 * k\n           *\n           * k is the rating of the deviation of the proportion of dark modules\n           * in the symbol from 50% in steps of 5%\n           */\n          exports.getPenaltyN4 = function getPenaltyN4(data) {\n            var darkCount = 0;\n            var modulesCount = data.data.length;\n            for (var i = 0; i < modulesCount; i++) darkCount += data.data[i];\n            var k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);\n            return k * PenaltyScores.N4;\n          };\n\n          /**\n           * Return mask value at given position\n           *\n           * @param  {Number} maskPattern Pattern reference value\n           * @param  {Number} i           Row\n           * @param  {Number} j           Column\n           * @return {Boolean}            Mask value\n           */\n          function getMaskAt(maskPattern, i, j) {\n            switch (maskPattern) {\n              case exports.Patterns.PATTERN000:\n                return (i + j) % 2 === 0;\n              case exports.Patterns.PATTERN001:\n                return i % 2 === 0;\n              case exports.Patterns.PATTERN010:\n                return j % 3 === 0;\n              case exports.Patterns.PATTERN011:\n                return (i + j) % 3 === 0;\n              case exports.Patterns.PATTERN100:\n                return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;\n              case exports.Patterns.PATTERN101:\n                return i * j % 2 + i * j % 3 === 0;\n              case exports.Patterns.PATTERN110:\n                return (i * j % 2 + i * j % 3) % 2 === 0;\n              case exports.Patterns.PATTERN111:\n                return (i * j % 3 + (i + j) % 2) % 2 === 0;\n              default:\n                throw new Error('bad maskPattern:' + maskPattern);\n            }\n          }\n\n          /**\n           * Apply a mask pattern to a BitMatrix\n           *\n           * @param  {Number}    pattern Pattern reference number\n           * @param  {BitMatrix} data    BitMatrix data\n           */\n          exports.applyMask = function applyMask(pattern, data) {\n            var size = data.size;\n            for (var col = 0; col < size; col++) {\n              for (var row = 0; row < size; row++) {\n                if (data.isReserved(row, col)) continue;\n                data.xor(row, col, getMaskAt(pattern, row, col));\n              }\n            }\n          };\n\n          /**\n           * Returns the best mask pattern for data\n           *\n           * @param  {BitMatrix} data\n           * @return {Number} Mask pattern reference number\n           */\n          exports.getBestMask = function getBestMask(data, setupFormatFunc) {\n            var numPatterns = Object.keys(exports.Patterns).length;\n            var bestPattern = 0;\n            var lowerPenalty = Infinity;\n            for (var p = 0; p < numPatterns; p++) {\n              setupFormatFunc(p);\n              exports.applyMask(p, data);\n\n              // Calculate penalty\n              var penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);\n\n              // Undo previously applied mask\n              exports.applyMask(p, data);\n              if (penalty < lowerPenalty) {\n                lowerPenalty = penalty;\n                bestPattern = p;\n              }\n            }\n            return bestPattern;\n          };\n        }, {}],\n        14: [function (require, module, exports) {\n          var VersionCheck = require('./version-check');\n          var Regex = require('./regex');\n\n          /**\n           * Numeric mode encodes data from the decimal digit set (0 - 9)\n           * (byte values 30HEX to 39HEX).\n           * Normally, 3 data characters are represented by 10 bits.\n           *\n           * @type {Object}\n           */\n          exports.NUMERIC = {\n            id: 'Numeric',\n            bit: 1 << 0,\n            ccBits: [10, 12, 14]\n          };\n\n          /**\n           * Alphanumeric mode encodes data from a set of 45 characters,\n           * i.e. 10 numeric digits (0 - 9),\n           *      26 alphabetic characters (A - Z),\n           *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n           * Normally, two input characters are represented by 11 bits.\n           *\n           * @type {Object}\n           */\n          exports.ALPHANUMERIC = {\n            id: 'Alphanumeric',\n            bit: 1 << 1,\n            ccBits: [9, 11, 13]\n          };\n\n          /**\n           * In byte mode, data is encoded at 8 bits per character.\n           *\n           * @type {Object}\n           */\n          exports.BYTE = {\n            id: 'Byte',\n            bit: 1 << 2,\n            ccBits: [8, 16, 16]\n          };\n\n          /**\n           * The Kanji mode efficiently encodes Kanji characters in accordance with\n           * the Shift JIS system based on JIS X 0208.\n           * The Shift JIS values are shifted from the JIS X 0208 values.\n           * JIS X 0208 gives details of the shift coded representation.\n           * Each two-byte character value is compacted to a 13-bit binary codeword.\n           *\n           * @type {Object}\n           */\n          exports.KANJI = {\n            id: 'Kanji',\n            bit: 1 << 3,\n            ccBits: [8, 10, 12]\n          };\n\n          /**\n           * Mixed mode will contain a sequences of data in a combination of any of\n           * the modes described above\n           *\n           * @type {Object}\n           */\n          exports.MIXED = {\n            bit: -1\n          };\n\n          /**\n           * Returns the number of bits needed to store the data length\n           * according to QR Code specifications.\n           *\n           * @param  {Mode}   mode    Data mode\n           * @param  {Number} version QR Code version\n           * @return {Number}         Number of bits\n           */\n          exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {\n            if (!mode.ccBits) throw new Error('Invalid mode: ' + mode);\n            if (!VersionCheck.isValid(version)) {\n              throw new Error('Invalid version: ' + version);\n            }\n            if (version >= 1 && version < 10) return mode.ccBits[0];else if (version < 27) return mode.ccBits[1];\n            return mode.ccBits[2];\n          };\n\n          /**\n           * Returns the most efficient mode to store the specified data\n           *\n           * @param  {String} dataStr Input data string\n           * @return {Mode}           Best mode\n           */\n          exports.getBestModeForData = function getBestModeForData(dataStr) {\n            if (Regex.testNumeric(dataStr)) return exports.NUMERIC;else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;else if (Regex.testKanji(dataStr)) return exports.KANJI;else return exports.BYTE;\n          };\n\n          /**\n           * Return mode name as string\n           *\n           * @param {Mode} mode Mode object\n           * @returns {String}  Mode name\n           */\n          exports.toString = function toString(mode) {\n            if (mode && mode.id) return mode.id;\n            throw new Error('Invalid mode');\n          };\n\n          /**\n           * Check if input param is a valid mode object\n           *\n           * @param   {Mode}    mode Mode object\n           * @returns {Boolean} True if valid mode, false otherwise\n           */\n          exports.isValid = function isValid(mode) {\n            return mode && mode.bit && mode.ccBits;\n          };\n\n          /**\n           * Get mode object from its name\n           *\n           * @param   {String} string Mode name\n           * @returns {Mode}          Mode object\n           */\n          function fromString(string) {\n            if (typeof string !== 'string') {\n              throw new Error('Param is not a string');\n            }\n            var lcStr = string.toLowerCase();\n            switch (lcStr) {\n              case 'numeric':\n                return exports.NUMERIC;\n              case 'alphanumeric':\n                return exports.ALPHANUMERIC;\n              case 'kanji':\n                return exports.KANJI;\n              case 'byte':\n                return exports.BYTE;\n              default:\n                throw new Error('Unknown mode: ' + string);\n            }\n          }\n\n          /**\n           * Returns mode from a value.\n           * If value is not a valid mode, returns defaultValue\n           *\n           * @param  {Mode|String} value        Encoding mode\n           * @param  {Mode}        defaultValue Fallback value\n           * @return {Mode}                     Encoding mode\n           */\n          exports.from = function from(value, defaultValue) {\n            if (exports.isValid(value)) {\n              return value;\n            }\n            try {\n              return fromString(value);\n            } catch (e) {\n              return defaultValue;\n            }\n          };\n        }, {\n          \"./regex\": 19,\n          \"./version-check\": 22\n        }],\n        15: [function (require, module, exports) {\n          var Mode = require('./mode');\n          function NumericData(data) {\n            this.mode = Mode.NUMERIC;\n            this.data = data.toString();\n          }\n          NumericData.getBitsLength = function getBitsLength(length) {\n            return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);\n          };\n          NumericData.prototype.getLength = function getLength() {\n            return this.data.length;\n          };\n          NumericData.prototype.getBitsLength = function getBitsLength() {\n            return NumericData.getBitsLength(this.data.length);\n          };\n          NumericData.prototype.write = function write(bitBuffer) {\n            var i, group, value;\n\n            // The input data string is divided into groups of three digits,\n            // and each group is converted to its 10-bit binary equivalent.\n            for (i = 0; i + 3 <= this.data.length; i += 3) {\n              group = this.data.substr(i, 3);\n              value = parseInt(group, 10);\n              bitBuffer.put(value, 10);\n            }\n\n            // If the number of input digits is not an exact multiple of three,\n            // the final one or two digits are converted to 4 or 7 bits respectively.\n            var remainingNum = this.data.length - i;\n            if (remainingNum > 0) {\n              group = this.data.substr(i);\n              value = parseInt(group, 10);\n              bitBuffer.put(value, remainingNum * 3 + 1);\n            }\n          };\n          module.exports = NumericData;\n        }, {\n          \"./mode\": 14\n        }],\n        16: [function (require, module, exports) {\n          var BufferUtil = require('../utils/buffer');\n          var GF = require('./galois-field');\n\n          /**\n           * Multiplies two polynomials inside Galois Field\n           *\n           * @param  {Buffer} p1 Polynomial\n           * @param  {Buffer} p2 Polynomial\n           * @return {Buffer}    Product of p1 and p2\n           */\n          exports.mul = function mul(p1, p2) {\n            var coeff = BufferUtil.alloc(p1.length + p2.length - 1);\n            for (var i = 0; i < p1.length; i++) {\n              for (var j = 0; j < p2.length; j++) {\n                coeff[i + j] ^= GF.mul(p1[i], p2[j]);\n              }\n            }\n            return coeff;\n          };\n\n          /**\n           * Calculate the remainder of polynomials division\n           *\n           * @param  {Buffer} divident Polynomial\n           * @param  {Buffer} divisor  Polynomial\n           * @return {Buffer}          Remainder\n           */\n          exports.mod = function mod(divident, divisor) {\n            var result = BufferUtil.from(divident);\n            while (result.length - divisor.length >= 0) {\n              var coeff = result[0];\n              for (var i = 0; i < divisor.length; i++) {\n                result[i] ^= GF.mul(divisor[i], coeff);\n              }\n\n              // remove all zeros from buffer head\n              var offset = 0;\n              while (offset < result.length && result[offset] === 0) offset++;\n              result = result.slice(offset);\n            }\n            return result;\n          };\n\n          /**\n           * Generate an irreducible generator polynomial of specified degree\n           * (used by Reed-Solomon encoder)\n           *\n           * @param  {Number} degree Degree of the generator polynomial\n           * @return {Buffer}        Buffer containing polynomial coefficients\n           */\n          exports.generateECPolynomial = function generateECPolynomial(degree) {\n            var poly = BufferUtil.from([1]);\n            for (var i = 0; i < degree; i++) {\n              poly = exports.mul(poly, [1, GF.exp(i)]);\n            }\n            return poly;\n          };\n        }, {\n          \"../utils/buffer\": 28,\n          \"./galois-field\": 11\n        }],\n        17: [function (require, module, exports) {\n          var BufferUtil = require('../utils/buffer');\n          var Utils = require('./utils');\n          var ECLevel = require('./error-correction-level');\n          var BitBuffer = require('./bit-buffer');\n          var BitMatrix = require('./bit-matrix');\n          var AlignmentPattern = require('./alignment-pattern');\n          var FinderPattern = require('./finder-pattern');\n          var MaskPattern = require('./mask-pattern');\n          var ECCode = require('./error-correction-code');\n          var ReedSolomonEncoder = require('./reed-solomon-encoder');\n          var Version = require('./version');\n          var FormatInfo = require('./format-info');\n          var Mode = require('./mode');\n          var Segments = require('./segments');\n          var isArray = require('isarray');\n\n          /**\n           * QRCode for JavaScript\n           *\n           * modified by Ryan Day for nodejs support\n           * Copyright (c) 2011 Ryan Day\n           *\n           * Licensed under the MIT license:\n           *   http://www.opensource.org/licenses/mit-license.php\n           *\n          //---------------------------------------------------------------------\n          // QRCode for JavaScript\n          //\n          // Copyright (c) 2009 Kazuhiko Arase\n          //\n          // URL: http://www.d-project.com/\n          //\n          // Licensed under the MIT license:\n          //   http://www.opensource.org/licenses/mit-license.php\n          //\n          // The word \"QR Code\" is registered trademark of\n          // DENSO WAVE INCORPORATED\n          //   http://www.denso-wave.com/qrcode/faqpatent-e.html\n          //\n          //---------------------------------------------------------------------\n          */\n\n          /**\n           * Add finder patterns bits to matrix\n           *\n           * @param  {BitMatrix} matrix  Modules matrix\n           * @param  {Number}    version QR Code version\n           */\n          function setupFinderPattern(matrix, version) {\n            var size = matrix.size;\n            var pos = FinderPattern.getPositions(version);\n            for (var i = 0; i < pos.length; i++) {\n              var row = pos[i][0];\n              var col = pos[i][1];\n              for (var r = -1; r <= 7; r++) {\n                if (row + r <= -1 || size <= row + r) continue;\n                for (var c = -1; c <= 7; c++) {\n                  if (col + c <= -1 || size <= col + c) continue;\n                  if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {\n                    matrix.set(row + r, col + c, true, true);\n                  } else {\n                    matrix.set(row + r, col + c, false, true);\n                  }\n                }\n              }\n            }\n          }\n\n          /**\n           * Add timing pattern bits to matrix\n           *\n           * Note: this function must be called before {@link setupAlignmentPattern}\n           *\n           * @param  {BitMatrix} matrix Modules matrix\n           */\n          function setupTimingPattern(matrix) {\n            var size = matrix.size;\n            for (var r = 8; r < size - 8; r++) {\n              var value = r % 2 === 0;\n              matrix.set(r, 6, value, true);\n              matrix.set(6, r, value, true);\n            }\n          }\n\n          /**\n           * Add alignment patterns bits to matrix\n           *\n           * Note: this function must be called after {@link setupTimingPattern}\n           *\n           * @param  {BitMatrix} matrix  Modules matrix\n           * @param  {Number}    version QR Code version\n           */\n          function setupAlignmentPattern(matrix, version) {\n            var pos = AlignmentPattern.getPositions(version);\n            for (var i = 0; i < pos.length; i++) {\n              var row = pos[i][0];\n              var col = pos[i][1];\n              for (var r = -2; r <= 2; r++) {\n                for (var c = -2; c <= 2; c++) {\n                  if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {\n                    matrix.set(row + r, col + c, true, true);\n                  } else {\n                    matrix.set(row + r, col + c, false, true);\n                  }\n                }\n              }\n            }\n          }\n\n          /**\n           * Add version info bits to matrix\n           *\n           * @param  {BitMatrix} matrix  Modules matrix\n           * @param  {Number}    version QR Code version\n           */\n          function setupVersionInfo(matrix, version) {\n            var size = matrix.size;\n            var bits = Version.getEncodedBits(version);\n            var row, col, mod;\n            for (var i = 0; i < 18; i++) {\n              row = Math.floor(i / 3);\n              col = i % 3 + size - 8 - 3;\n              mod = (bits >> i & 1) === 1;\n              matrix.set(row, col, mod, true);\n              matrix.set(col, row, mod, true);\n            }\n          }\n\n          /**\n           * Add format info bits to matrix\n           *\n           * @param  {BitMatrix} matrix               Modules matrix\n           * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n           * @param  {Number}    maskPattern          Mask pattern reference value\n           */\n          function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {\n            var size = matrix.size;\n            var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);\n            var i, mod;\n            for (i = 0; i < 15; i++) {\n              mod = (bits >> i & 1) === 1;\n\n              // vertical\n              if (i < 6) {\n                matrix.set(i, 8, mod, true);\n              } else if (i < 8) {\n                matrix.set(i + 1, 8, mod, true);\n              } else {\n                matrix.set(size - 15 + i, 8, mod, true);\n              }\n\n              // horizontal\n              if (i < 8) {\n                matrix.set(8, size - i - 1, mod, true);\n              } else if (i < 9) {\n                matrix.set(8, 15 - i - 1 + 1, mod, true);\n              } else {\n                matrix.set(8, 15 - i - 1, mod, true);\n              }\n            }\n\n            // fixed module\n            matrix.set(size - 8, 8, 1, true);\n          }\n\n          /**\n           * Add encoded data bits to matrix\n           *\n           * @param  {BitMatrix} matrix Modules matrix\n           * @param  {Buffer}    data   Data codewords\n           */\n          function setupData(matrix, data) {\n            var size = matrix.size;\n            var inc = -1;\n            var row = size - 1;\n            var bitIndex = 7;\n            var byteIndex = 0;\n            for (var col = size - 1; col > 0; col -= 2) {\n              if (col === 6) col--;\n              while (true) {\n                for (var c = 0; c < 2; c++) {\n                  if (!matrix.isReserved(row, col - c)) {\n                    var dark = false;\n                    if (byteIndex < data.length) {\n                      dark = (data[byteIndex] >>> bitIndex & 1) === 1;\n                    }\n                    matrix.set(row, col - c, dark);\n                    bitIndex--;\n                    if (bitIndex === -1) {\n                      byteIndex++;\n                      bitIndex = 7;\n                    }\n                  }\n                }\n                row += inc;\n                if (row < 0 || size <= row) {\n                  row -= inc;\n                  inc = -inc;\n                  break;\n                }\n              }\n            }\n          }\n\n          /**\n           * Create encoded codewords from data input\n           *\n           * @param  {Number}   version              QR Code version\n           * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n           * @param  {ByteData} data                 Data input\n           * @return {Buffer}                        Buffer containing encoded codewords\n           */\n          function createData(version, errorCorrectionLevel, segments) {\n            // Prepare data buffer\n            var buffer = new BitBuffer();\n            segments.forEach(function (data) {\n              // prefix data with mode indicator (4 bits)\n              buffer.put(data.mode.bit, 4);\n\n              // Prefix data with character count indicator.\n              // The character count indicator is a string of bits that represents the\n              // number of characters that are being encoded.\n              // The character count indicator must be placed after the mode indicator\n              // and must be a certain number of bits long, depending on the QR version\n              // and data mode\n              // @see {@link Mode.getCharCountIndicator}.\n              buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));\n\n              // add binary data sequence to buffer\n              data.write(buffer);\n            });\n\n            // Calculate required number of bits\n            var totalCodewords = Utils.getSymbolTotalCodewords(version);\n            var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n            var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n\n            // Add a terminator.\n            // If the bit string is shorter than the total number of required bits,\n            // a terminator of up to four 0s must be added to the right side of the string.\n            // If the bit string is more than four bits shorter than the required number of bits,\n            // add four 0s to the end.\n            if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n              buffer.put(0, 4);\n            }\n\n            // If the bit string is fewer than four bits shorter, add only the number of 0s that\n            // are needed to reach the required number of bits.\n\n            // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n            // pad the string on the right with 0s to make the string's length a multiple of 8.\n            while (buffer.getLengthInBits() % 8 !== 0) {\n              buffer.putBit(0);\n            }\n\n            // Add pad bytes if the string is still shorter than the total number of required bits.\n            // Extend the buffer to fill the data capacity of the symbol corresponding to\n            // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n            // and 00010001 (0x11) alternately.\n            var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;\n            for (var i = 0; i < remainingByte; i++) {\n              buffer.put(i % 2 ? 0x11 : 0xEC, 8);\n            }\n            return createCodewords(buffer, version, errorCorrectionLevel);\n          }\n\n          /**\n           * Encode input data with Reed-Solomon and return codewords with\n           * relative error correction bits\n           *\n           * @param  {BitBuffer} bitBuffer            Data to encode\n           * @param  {Number}    version              QR Code version\n           * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n           * @return {Buffer}                         Buffer containing encoded codewords\n           */\n          function createCodewords(bitBuffer, version, errorCorrectionLevel) {\n            // Total codewords for this QR code version (Data + Error correction)\n            var totalCodewords = Utils.getSymbolTotalCodewords(version);\n\n            // Total number of error correction codewords\n            var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n\n            // Total number of data codewords\n            var dataTotalCodewords = totalCodewords - ecTotalCodewords;\n\n            // Total number of blocks\n            var ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);\n\n            // Calculate how many blocks each group should contain\n            var blocksInGroup2 = totalCodewords % ecTotalBlocks;\n            var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;\n            var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);\n            var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);\n            var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;\n\n            // Number of EC codewords is the same for both groups\n            var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;\n\n            // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n            var rs = new ReedSolomonEncoder(ecCount);\n            var offset = 0;\n            var dcData = new Array(ecTotalBlocks);\n            var ecData = new Array(ecTotalBlocks);\n            var maxDataSize = 0;\n            var buffer = BufferUtil.from(bitBuffer.buffer);\n\n            // Divide the buffer into the required number of blocks\n            for (var b = 0; b < ecTotalBlocks; b++) {\n              var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;\n\n              // extract a block of data from buffer\n              dcData[b] = buffer.slice(offset, offset + dataSize);\n\n              // Calculate EC codewords for this data block\n              ecData[b] = rs.encode(dcData[b]);\n              offset += dataSize;\n              maxDataSize = Math.max(maxDataSize, dataSize);\n            }\n\n            // Create final data\n            // Interleave the data and error correction codewords from each block\n            var data = BufferUtil.alloc(totalCodewords);\n            var index = 0;\n            var i, r;\n\n            // Add data codewords\n            for (i = 0; i < maxDataSize; i++) {\n              for (r = 0; r < ecTotalBlocks; r++) {\n                if (i < dcData[r].length) {\n                  data[index++] = dcData[r][i];\n                }\n              }\n            }\n\n            // Apped EC codewords\n            for (i = 0; i < ecCount; i++) {\n              for (r = 0; r < ecTotalBlocks; r++) {\n                data[index++] = ecData[r][i];\n              }\n            }\n            return data;\n          }\n\n          /**\n           * Build QR Code symbol\n           *\n           * @param  {String} data                 Input string\n           * @param  {Number} version              QR Code version\n           * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n           * @param  {MaskPattern} maskPattern     Mask pattern\n           * @return {Object}                      Object containing symbol data\n           */\n          function createSymbol(data, version, errorCorrectionLevel, maskPattern) {\n            var segments;\n            if (isArray(data)) {\n              segments = Segments.fromArray(data);\n            } else if (typeof data === 'string') {\n              var estimatedVersion = version;\n              if (!estimatedVersion) {\n                var rawSegments = Segments.rawSplit(data);\n\n                // Estimate best version that can contain raw splitted segments\n                estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);\n              }\n\n              // Build optimized segments\n              // If estimated version is undefined, try with the highest version\n              segments = Segments.fromString(data, estimatedVersion || 40);\n            } else {\n              throw new Error('Invalid data');\n            }\n\n            // Get the min version that can contain data\n            var bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);\n\n            // If no version is found, data cannot be stored\n            if (!bestVersion) {\n              throw new Error('The amount of data is too big to be stored in a QR Code');\n            }\n\n            // If not specified, use min version as default\n            if (!version) {\n              version = bestVersion;\n\n              // Check if the specified version can contain the data\n            } else if (version < bestVersion) {\n              throw new Error('\\n' + 'The chosen QR Code version cannot contain this amount of data.\\n' + 'Minimum version required to store current data is: ' + bestVersion + '.\\n');\n            }\n            var dataBits = createData(version, errorCorrectionLevel, segments);\n\n            // Allocate matrix buffer\n            var moduleCount = Utils.getSymbolSize(version);\n            var modules = new BitMatrix(moduleCount);\n\n            // Add function modules\n            setupFinderPattern(modules, version);\n            setupTimingPattern(modules);\n            setupAlignmentPattern(modules, version);\n\n            // Add temporary dummy bits for format info just to set them as reserved.\n            // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n            // since the masking operation must be performed only on the encoding region.\n            // These blocks will be replaced with correct values later in code.\n            setupFormatInfo(modules, errorCorrectionLevel, 0);\n            if (version >= 7) {\n              setupVersionInfo(modules, version);\n            }\n\n            // Add data codewords\n            setupData(modules, dataBits);\n            if (isNaN(maskPattern)) {\n              // Find best mask pattern\n              maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));\n            }\n\n            // Apply mask pattern\n            MaskPattern.applyMask(maskPattern, modules);\n\n            // Replace format info bits with correct values\n            setupFormatInfo(modules, errorCorrectionLevel, maskPattern);\n            return {\n              modules: modules,\n              version: version,\n              errorCorrectionLevel: errorCorrectionLevel,\n              maskPattern: maskPattern,\n              segments: segments\n            };\n          }\n\n          /**\n           * QR Code\n           *\n           * @param {String | Array} data                 Input data\n           * @param {Object} options                      Optional configurations\n           * @param {Number} options.version              QR Code version\n           * @param {String} options.errorCorrectionLevel Error correction level\n           * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n           */\n          exports.create = function create(data, options) {\n            if (typeof data === 'undefined' || data === '') {\n              throw new Error('No input text');\n            }\n            var errorCorrectionLevel = ECLevel.M;\n            var version;\n            var mask;\n            if (typeof options !== 'undefined') {\n              // Use higher error correction level as default\n              errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);\n              version = Version.from(options.version);\n              mask = MaskPattern.from(options.maskPattern);\n              if (options.toSJISFunc) {\n                Utils.setToSJISFunction(options.toSJISFunc);\n              }\n            }\n            return createSymbol(data, version, errorCorrectionLevel, mask);\n          };\n        }, {\n          \"../utils/buffer\": 28,\n          \"./alignment-pattern\": 2,\n          \"./bit-buffer\": 4,\n          \"./bit-matrix\": 5,\n          \"./error-correction-code\": 7,\n          \"./error-correction-level\": 8,\n          \"./finder-pattern\": 9,\n          \"./format-info\": 10,\n          \"./mask-pattern\": 13,\n          \"./mode\": 14,\n          \"./reed-solomon-encoder\": 18,\n          \"./segments\": 20,\n          \"./utils\": 21,\n          \"./version\": 23,\n          \"isarray\": 33\n        }],\n        18: [function (require, module, exports) {\n          var BufferUtil = require('../utils/buffer');\n          var Polynomial = require('./polynomial');\n          var Buffer = require('buffer').Buffer;\n          function ReedSolomonEncoder(degree) {\n            this.genPoly = undefined;\n            this.degree = degree;\n            if (this.degree) this.initialize(this.degree);\n          }\n\n          /**\n           * Initialize the encoder.\n           * The input param should correspond to the number of error correction codewords.\n           *\n           * @param  {Number} degree\n           */\n          ReedSolomonEncoder.prototype.initialize = function initialize(degree) {\n            // create an irreducible generator polynomial\n            this.degree = degree;\n            this.genPoly = Polynomial.generateECPolynomial(this.degree);\n          };\n\n          /**\n           * Encodes a chunk of data\n           *\n           * @param  {Buffer} data Buffer containing input data\n           * @return {Buffer}      Buffer containing encoded data\n           */\n          ReedSolomonEncoder.prototype.encode = function encode(data) {\n            if (!this.genPoly) {\n              throw new Error('Encoder not initialized');\n            }\n\n            // Calculate EC for this data block\n            // extends data size to data+genPoly size\n            var pad = BufferUtil.alloc(this.degree);\n            var paddedData = Buffer.concat([data, pad], data.length + this.degree);\n\n            // The error correction codewords are the remainder after dividing the data codewords\n            // by a generator polynomial\n            var remainder = Polynomial.mod(paddedData, this.genPoly);\n\n            // return EC data blocks (last n byte, where n is the degree of genPoly)\n            // If coefficients number in remainder are less than genPoly degree,\n            // pad with 0s to the left to reach the needed number of coefficients\n            var start = this.degree - remainder.length;\n            if (start > 0) {\n              var buff = BufferUtil.alloc(this.degree);\n              remainder.copy(buff, start);\n              return buff;\n            }\n            return remainder;\n          };\n          module.exports = ReedSolomonEncoder;\n        }, {\n          \"../utils/buffer\": 28,\n          \"./polynomial\": 16,\n          \"buffer\": 30\n        }],\n        19: [function (require, module, exports) {\n          var numeric = '[0-9]+';\n          var alphanumeric = '[A-Z $%*+\\\\-./:]+';\n          var kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' + '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' + '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' + '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';\n          kanji = kanji.replace(/u/g, '\\\\u');\n          var byte = '(?:(?![A-Z0-9 $%*+\\\\-./:]|' + kanji + ')(?:.|[\\r\\n]))+';\n          exports.KANJI = new RegExp(kanji, 'g');\n          exports.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\\\-./:]+', 'g');\n          exports.BYTE = new RegExp(byte, 'g');\n          exports.NUMERIC = new RegExp(numeric, 'g');\n          exports.ALPHANUMERIC = new RegExp(alphanumeric, 'g');\n          var TEST_KANJI = new RegExp('^' + kanji + '$');\n          var TEST_NUMERIC = new RegExp('^' + numeric + '$');\n          var TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\\\-./:]+$');\n          exports.testKanji = function testKanji(str) {\n            return TEST_KANJI.test(str);\n          };\n          exports.testNumeric = function testNumeric(str) {\n            return TEST_NUMERIC.test(str);\n          };\n          exports.testAlphanumeric = function testAlphanumeric(str) {\n            return TEST_ALPHANUMERIC.test(str);\n          };\n        }, {}],\n        20: [function (require, module, exports) {\n          var Mode = require('./mode');\n          var NumericData = require('./numeric-data');\n          var AlphanumericData = require('./alphanumeric-data');\n          var ByteData = require('./byte-data');\n          var KanjiData = require('./kanji-data');\n          var Regex = require('./regex');\n          var Utils = require('./utils');\n          var dijkstra = require('dijkstrajs');\n\n          /**\n           * Returns UTF8 byte length\n           *\n           * @param  {String} str Input string\n           * @return {Number}     Number of byte\n           */\n          function getStringByteLength(str) {\n            return unescape(encodeURIComponent(str)).length;\n          }\n\n          /**\n           * Get a list of segments of the specified mode\n           * from a string\n           *\n           * @param  {Mode}   mode Segment mode\n           * @param  {String} str  String to process\n           * @return {Array}       Array of object with segments data\n           */\n          function getSegments(regex, mode, str) {\n            var segments = [];\n            var result;\n            while ((result = regex.exec(str)) !== null) {\n              segments.push({\n                data: result[0],\n                index: result.index,\n                mode: mode,\n                length: result[0].length\n              });\n            }\n            return segments;\n          }\n\n          /**\n           * Extracts a series of segments with the appropriate\n           * modes from a string\n           *\n           * @param  {String} dataStr Input string\n           * @return {Array}          Array of object with segments data\n           */\n          function getSegmentsFromString(dataStr) {\n            var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);\n            var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);\n            var byteSegs;\n            var kanjiSegs;\n            if (Utils.isKanjiModeEnabled()) {\n              byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);\n              kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);\n            } else {\n              byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);\n              kanjiSegs = [];\n            }\n            var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);\n            return segs.sort(function (s1, s2) {\n              return s1.index - s2.index;\n            }).map(function (obj) {\n              return {\n                data: obj.data,\n                mode: obj.mode,\n                length: obj.length\n              };\n            });\n          }\n\n          /**\n           * Returns how many bits are needed to encode a string of\n           * specified length with the specified mode\n           *\n           * @param  {Number} length String length\n           * @param  {Mode} mode     Segment mode\n           * @return {Number}        Bit length\n           */\n          function getSegmentBitsLength(length, mode) {\n            switch (mode) {\n              case Mode.NUMERIC:\n                return NumericData.getBitsLength(length);\n              case Mode.ALPHANUMERIC:\n                return AlphanumericData.getBitsLength(length);\n              case Mode.KANJI:\n                return KanjiData.getBitsLength(length);\n              case Mode.BYTE:\n                return ByteData.getBitsLength(length);\n            }\n          }\n\n          /**\n           * Merges adjacent segments which have the same mode\n           *\n           * @param  {Array} segs Array of object with segments data\n           * @return {Array}      Array of object with segments data\n           */\n          function mergeSegments(segs) {\n            return segs.reduce(function (acc, curr) {\n              var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;\n              if (prevSeg && prevSeg.mode === curr.mode) {\n                acc[acc.length - 1].data += curr.data;\n                return acc;\n              }\n              acc.push(curr);\n              return acc;\n            }, []);\n          }\n\n          /**\n           * Generates a list of all possible nodes combination which\n           * will be used to build a segments graph.\n           *\n           * Nodes are divided by groups. Each group will contain a list of all the modes\n           * in which is possible to encode the given text.\n           *\n           * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n           * The group for '12345' will contain then 3 objects, one for each\n           * possible encoding mode.\n           *\n           * Each node represents a possible segment.\n           *\n           * @param  {Array} segs Array of object with segments data\n           * @return {Array}      Array of object with segments data\n           */\n          function buildNodes(segs) {\n            var nodes = [];\n            for (var i = 0; i < segs.length; i++) {\n              var seg = segs[i];\n              switch (seg.mode) {\n                case Mode.NUMERIC:\n                  nodes.push([seg, {\n                    data: seg.data,\n                    mode: Mode.ALPHANUMERIC,\n                    length: seg.length\n                  }, {\n                    data: seg.data,\n                    mode: Mode.BYTE,\n                    length: seg.length\n                  }]);\n                  break;\n                case Mode.ALPHANUMERIC:\n                  nodes.push([seg, {\n                    data: seg.data,\n                    mode: Mode.BYTE,\n                    length: seg.length\n                  }]);\n                  break;\n                case Mode.KANJI:\n                  nodes.push([seg, {\n                    data: seg.data,\n                    mode: Mode.BYTE,\n                    length: getStringByteLength(seg.data)\n                  }]);\n                  break;\n                case Mode.BYTE:\n                  nodes.push([{\n                    data: seg.data,\n                    mode: Mode.BYTE,\n                    length: getStringByteLength(seg.data)\n                  }]);\n              }\n            }\n            return nodes;\n          }\n\n          /**\n           * Builds a graph from a list of nodes.\n           * All segments in each node group will be connected with all the segments of\n           * the next group and so on.\n           *\n           * At each connection will be assigned a weight depending on the\n           * segment's byte length.\n           *\n           * @param  {Array} nodes    Array of object with segments data\n           * @param  {Number} version QR Code version\n           * @return {Object}         Graph of all possible segments\n           */\n          function buildGraph(nodes, version) {\n            var table = {};\n            var graph = {\n              'start': {}\n            };\n            var prevNodeIds = ['start'];\n            for (var i = 0; i < nodes.length; i++) {\n              var nodeGroup = nodes[i];\n              var currentNodeIds = [];\n              for (var j = 0; j < nodeGroup.length; j++) {\n                var node = nodeGroup[j];\n                var key = '' + i + j;\n                currentNodeIds.push(key);\n                table[key] = {\n                  node: node,\n                  lastCount: 0\n                };\n                graph[key] = {};\n                for (var n = 0; n < prevNodeIds.length; n++) {\n                  var prevNodeId = prevNodeIds[n];\n                  if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n                    graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);\n                    table[prevNodeId].lastCount += node.length;\n                  } else {\n                    if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;\n                    graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version); // switch cost\n                  }\n                }\n              }\n\n              prevNodeIds = currentNodeIds;\n            }\n            for (n = 0; n < prevNodeIds.length; n++) {\n              graph[prevNodeIds[n]]['end'] = 0;\n            }\n            return {\n              map: graph,\n              table: table\n            };\n          }\n\n          /**\n           * Builds a segment from a specified data and mode.\n           * If a mode is not specified, the more suitable will be used.\n           *\n           * @param  {String} data             Input data\n           * @param  {Mode | String} modesHint Data mode\n           * @return {Segment}                 Segment\n           */\n          function buildSingleSegment(data, modesHint) {\n            var mode;\n            var bestMode = Mode.getBestModeForData(data);\n            mode = Mode.from(modesHint, bestMode);\n\n            // Make sure data can be encoded\n            if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n              throw new Error('\"' + data + '\"' + ' cannot be encoded with mode ' + Mode.toString(mode) + '.\\n Suggested mode is: ' + Mode.toString(bestMode));\n            }\n\n            // Use Mode.BYTE if Kanji support is disabled\n            if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n              mode = Mode.BYTE;\n            }\n            switch (mode) {\n              case Mode.NUMERIC:\n                return new NumericData(data);\n              case Mode.ALPHANUMERIC:\n                return new AlphanumericData(data);\n              case Mode.KANJI:\n                return new KanjiData(data);\n              case Mode.BYTE:\n                return new ByteData(data);\n            }\n          }\n\n          /**\n           * Builds a list of segments from an array.\n           * Array can contain Strings or Objects with segment's info.\n           *\n           * For each item which is a string, will be generated a segment with the given\n           * string and the more appropriate encoding mode.\n           *\n           * For each item which is an object, will be generated a segment with the given\n           * data and mode.\n           * Objects must contain at least the property \"data\".\n           * If property \"mode\" is not present, the more suitable mode will be used.\n           *\n           * @param  {Array} array Array of objects with segments data\n           * @return {Array}       Array of Segments\n           */\n          exports.fromArray = function fromArray(array) {\n            return array.reduce(function (acc, seg) {\n              if (typeof seg === 'string') {\n                acc.push(buildSingleSegment(seg, null));\n              } else if (seg.data) {\n                acc.push(buildSingleSegment(seg.data, seg.mode));\n              }\n              return acc;\n            }, []);\n          };\n\n          /**\n           * Builds an optimized sequence of segments from a string,\n           * which will produce the shortest possible bitstream.\n           *\n           * @param  {String} data    Input string\n           * @param  {Number} version QR Code version\n           * @return {Array}          Array of segments\n           */\n          exports.fromString = function fromString(data, version) {\n            var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());\n            var nodes = buildNodes(segs);\n            var graph = buildGraph(nodes, version);\n            var path = dijkstra.find_path(graph.map, 'start', 'end');\n            var optimizedSegs = [];\n            for (var i = 1; i < path.length - 1; i++) {\n              optimizedSegs.push(graph.table[path[i]].node);\n            }\n            return exports.fromArray(mergeSegments(optimizedSegs));\n          };\n\n          /**\n           * Splits a string in various segments with the modes which\n           * best represent their content.\n           * The produced segments are far from being optimized.\n           * The output of this function is only used to estimate a QR Code version\n           * which may contain the data.\n           *\n           * @param  {string} data Input string\n           * @return {Array}       Array of segments\n           */\n          exports.rawSplit = function rawSplit(data) {\n            return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));\n          };\n        }, {\n          \"./alphanumeric-data\": 3,\n          \"./byte-data\": 6,\n          \"./kanji-data\": 12,\n          \"./mode\": 14,\n          \"./numeric-data\": 15,\n          \"./regex\": 19,\n          \"./utils\": 21,\n          \"dijkstrajs\": 31\n        }],\n        21: [function (require, module, exports) {\n          var toSJISFunction;\n          var CODEWORDS_COUNT = [0,\n          // Not used\n          26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];\n\n          /**\n           * Returns the QR Code size for the specified version\n           *\n           * @param  {Number} version QR Code version\n           * @return {Number}         size of QR code\n           */\n          exports.getSymbolSize = function getSymbolSize(version) {\n            if (!version) throw new Error('\"version\" cannot be null or undefined');\n            if (version < 1 || version > 40) throw new Error('\"version\" should be in range from 1 to 40');\n            return version * 4 + 17;\n          };\n\n          /**\n           * Returns the total number of codewords used to store data and EC information.\n           *\n           * @param  {Number} version QR Code version\n           * @return {Number}         Data length in bits\n           */\n          exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {\n            return CODEWORDS_COUNT[version];\n          };\n\n          /**\n           * Encode data with Bose-Chaudhuri-Hocquenghem\n           *\n           * @param  {Number} data Value to encode\n           * @return {Number}      Encoded value\n           */\n          exports.getBCHDigit = function (data) {\n            var digit = 0;\n            while (data !== 0) {\n              digit++;\n              data >>>= 1;\n            }\n            return digit;\n          };\n          exports.setToSJISFunction = function setToSJISFunction(f) {\n            if (typeof f !== 'function') {\n              throw new Error('\"toSJISFunc\" is not a valid function.');\n            }\n            toSJISFunction = f;\n          };\n          exports.isKanjiModeEnabled = function () {\n            return typeof toSJISFunction !== 'undefined';\n          };\n          exports.toSJIS = function toSJIS(kanji) {\n            return toSJISFunction(kanji);\n          };\n        }, {}],\n        22: [function (require, module, exports) {\n          /**\n           * Check if QR Code version is valid\n           *\n           * @param  {Number}  version QR Code version\n           * @return {Boolean}         true if valid version, false otherwise\n           */\n          exports.isValid = function isValid(version) {\n            return !isNaN(version) && version >= 1 && version <= 40;\n          };\n        }, {}],\n        23: [function (require, module, exports) {\n          var Utils = require('./utils');\n          var ECCode = require('./error-correction-code');\n          var ECLevel = require('./error-correction-level');\n          var Mode = require('./mode');\n          var VersionCheck = require('./version-check');\n          var isArray = require('isarray');\n\n          // Generator polynomial used to encode version information\n          var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;\n          var G18_BCH = Utils.getBCHDigit(G18);\n          function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {\n            for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {\n              if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n                return currentVersion;\n              }\n            }\n            return undefined;\n          }\n          function getReservedBitsCount(mode, version) {\n            // Character count indicator + mode indicator bits\n            return Mode.getCharCountIndicator(mode, version) + 4;\n          }\n          function getTotalBitsFromDataArray(segments, version) {\n            var totalBits = 0;\n            segments.forEach(function (data) {\n              var reservedBits = getReservedBitsCount(data.mode, version);\n              totalBits += reservedBits + data.getBitsLength();\n            });\n            return totalBits;\n          }\n          function getBestVersionForMixedData(segments, errorCorrectionLevel) {\n            for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {\n              var length = getTotalBitsFromDataArray(segments, currentVersion);\n              if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {\n                return currentVersion;\n              }\n            }\n            return undefined;\n          }\n\n          /**\n           * Returns version number from a value.\n           * If value is not a valid version, returns defaultValue\n           *\n           * @param  {Number|String} value        QR Code version\n           * @param  {Number}        defaultValue Fallback value\n           * @return {Number}                     QR Code version number\n           */\n          exports.from = function from(value, defaultValue) {\n            if (VersionCheck.isValid(value)) {\n              return parseInt(value, 10);\n            }\n            return defaultValue;\n          };\n\n          /**\n           * Returns how much data can be stored with the specified QR code version\n           * and error correction level\n           *\n           * @param  {Number} version              QR Code version (1-40)\n           * @param  {Number} errorCorrectionLevel Error correction level\n           * @param  {Mode}   mode                 Data mode\n           * @return {Number}                      Quantity of storable data\n           */\n          exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {\n            if (!VersionCheck.isValid(version)) {\n              throw new Error('Invalid QR Code version');\n            }\n\n            // Use Byte mode as default\n            if (typeof mode === 'undefined') mode = Mode.BYTE;\n\n            // Total codewords for this QR code version (Data + Error correction)\n            var totalCodewords = Utils.getSymbolTotalCodewords(version);\n\n            // Total number of error correction codewords\n            var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n\n            // Total number of data codewords\n            var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n            if (mode === Mode.MIXED) return dataTotalCodewordsBits;\n            var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);\n\n            // Return max number of storable codewords\n            switch (mode) {\n              case Mode.NUMERIC:\n                return Math.floor(usableBits / 10 * 3);\n              case Mode.ALPHANUMERIC:\n                return Math.floor(usableBits / 11 * 2);\n              case Mode.KANJI:\n                return Math.floor(usableBits / 13);\n              case Mode.BYTE:\n              default:\n                return Math.floor(usableBits / 8);\n            }\n          };\n\n          /**\n           * Returns the minimum version needed to contain the amount of data\n           *\n           * @param  {Segment} data                    Segment of data\n           * @param  {Number} [errorCorrectionLevel=H] Error correction level\n           * @param  {Mode} mode                       Data mode\n           * @return {Number}                          QR Code version\n           */\n          exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {\n            var seg;\n            var ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);\n            if (isArray(data)) {\n              if (data.length > 1) {\n                return getBestVersionForMixedData(data, ecl);\n              }\n              if (data.length === 0) {\n                return 1;\n              }\n              seg = data[0];\n            } else {\n              seg = data;\n            }\n            return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);\n          };\n\n          /**\n           * Returns version information with relative error correction bits\n           *\n           * The version information is included in QR Code symbols of version 7 or larger.\n           * It consists of an 18-bit sequence containing 6 data bits,\n           * with 12 error correction bits calculated using the (18, 6) Golay code.\n           *\n           * @param  {Number} version QR Code version\n           * @return {Number}         Encoded version info bits\n           */\n          exports.getEncodedBits = function getEncodedBits(version) {\n            if (!VersionCheck.isValid(version) || version < 7) {\n              throw new Error('Invalid QR Code version');\n            }\n            var d = version << 12;\n            while (Utils.getBCHDigit(d) - G18_BCH >= 0) {\n              d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;\n            }\n            return version << 12 | d;\n          };\n        }, {\n          \"./error-correction-code\": 7,\n          \"./error-correction-level\": 8,\n          \"./mode\": 14,\n          \"./utils\": 21,\n          \"./version-check\": 22,\n          \"isarray\": 33\n        }],\n        24: [function (require, module, exports) {\n          var canPromise = require('./can-promise');\n          var QRCode = require('./core/qrcode');\n          var CanvasRenderer = require('./renderer/canvas');\n          var SvgRenderer = require('./renderer/svg-tag.js');\n          function renderCanvas(renderFunc, canvas, text, opts, cb) {\n            var args = [].slice.call(arguments, 1);\n            var argsNum = args.length;\n            var isLastArgCb = typeof args[argsNum - 1] === 'function';\n            if (!isLastArgCb && !canPromise()) {\n              throw new Error('Callback required as last argument');\n            }\n            if (isLastArgCb) {\n              if (argsNum < 2) {\n                throw new Error('Too few arguments provided');\n              }\n              if (argsNum === 2) {\n                cb = text;\n                text = canvas;\n                canvas = opts = undefined;\n              } else if (argsNum === 3) {\n                if (canvas.getContext && typeof cb === 'undefined') {\n                  cb = opts;\n                  opts = undefined;\n                } else {\n                  cb = opts;\n                  opts = text;\n                  text = canvas;\n                  canvas = undefined;\n                }\n              }\n            } else {\n              if (argsNum < 1) {\n                throw new Error('Too few arguments provided');\n              }\n              if (argsNum === 1) {\n                text = canvas;\n                canvas = opts = undefined;\n              } else if (argsNum === 2 && !canvas.getContext) {\n                opts = text;\n                text = canvas;\n                canvas = undefined;\n              }\n              return new Promise(function (resolve, reject) {\n                try {\n                  var data = QRCode.create(text, opts);\n                  resolve(renderFunc(data, canvas, opts));\n                } catch (e) {\n                  reject(e);\n                }\n              });\n            }\n            try {\n              var data = QRCode.create(text, opts);\n              cb(null, renderFunc(data, canvas, opts));\n            } catch (e) {\n              cb(e);\n            }\n          }\n          exports.create = QRCode.create;\n          exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);\n          exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);\n\n          // only svg for now.\n          exports.toString = renderCanvas.bind(null, function (data, _, opts) {\n            return SvgRenderer.render(data, opts);\n          });\n        }, {\n          \"./can-promise\": 1,\n          \"./core/qrcode\": 17,\n          \"./renderer/canvas\": 25,\n          \"./renderer/svg-tag.js\": 26\n        }],\n        25: [function (require, module, exports) {\n          var Utils = require('./utils');\n          function clearCanvas(ctx, canvas, size) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            if (!canvas.style) canvas.style = {};\n            canvas.height = size;\n            canvas.width = size;\n            canvas.style.height = size + 'px';\n            canvas.style.width = size + 'px';\n          }\n          function getCanvasElement() {\n            try {\n              return document.createElement('canvas');\n            } catch (e) {\n              throw new Error('You need to specify a canvas element');\n            }\n          }\n          exports.render = function render(qrData, canvas, options) {\n            var opts = options;\n            var canvasEl = canvas;\n            if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n              opts = canvas;\n              canvas = undefined;\n            }\n            if (!canvas) {\n              canvasEl = getCanvasElement();\n            }\n            opts = Utils.getOptions(opts);\n            var size = Utils.getImageWidth(qrData.modules.size, opts);\n            var ctx = canvasEl.getContext('2d');\n            var image = ctx.createImageData(size, size);\n            Utils.qrToImageData(image.data, qrData, opts);\n            clearCanvas(ctx, canvasEl, size);\n            ctx.putImageData(image, 0, 0);\n            return canvasEl;\n          };\n          exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {\n            var opts = options;\n            if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n              opts = canvas;\n              canvas = undefined;\n            }\n            if (!opts) opts = {};\n            var canvasEl = exports.render(qrData, canvas, opts);\n            var type = opts.type || 'image/png';\n            var rendererOpts = opts.rendererOpts || {};\n            return canvasEl.toDataURL(type, rendererOpts.quality);\n          };\n        }, {\n          \"./utils\": 27\n        }],\n        26: [function (require, module, exports) {\n          var Utils = require('./utils');\n          function getColorAttrib(color, attrib) {\n            var alpha = color.a / 255;\n            var str = attrib + '=\"' + color.hex + '\"';\n            return alpha < 1 ? str + ' ' + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"' : str;\n          }\n          function svgCmd(cmd, x, y) {\n            var str = cmd + x;\n            if (typeof y !== 'undefined') str += ' ' + y;\n            return str;\n          }\n          function qrToPath(data, size, margin) {\n            var path = '';\n            var moveBy = 0;\n            var newRow = false;\n            var lineLength = 0;\n            for (var i = 0; i < data.length; i++) {\n              var col = Math.floor(i % size);\n              var row = Math.floor(i / size);\n              if (!col && !newRow) newRow = true;\n              if (data[i]) {\n                lineLength++;\n                if (!(i > 0 && col > 0 && data[i - 1])) {\n                  path += newRow ? svgCmd('M', col + margin, 0.5 + row + margin) : svgCmd('m', moveBy, 0);\n                  moveBy = 0;\n                  newRow = false;\n                }\n                if (!(col + 1 < size && data[i + 1])) {\n                  path += svgCmd('h', lineLength);\n                  lineLength = 0;\n                }\n              } else {\n                moveBy++;\n              }\n            }\n            return path;\n          }\n          exports.render = function render(qrData, options, cb) {\n            var opts = Utils.getOptions(options);\n            var size = qrData.modules.size;\n            var data = qrData.modules.data;\n            var qrcodesize = size + opts.margin * 2;\n            var bg = !opts.color.light.a ? '' : '<path ' + getColorAttrib(opts.color.light, 'fill') + ' d=\"M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z\"/>';\n            var path = '<path ' + getColorAttrib(opts.color.dark, 'stroke') + ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>';\n            var viewBox = 'viewBox=\"' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '\"';\n            var width = !opts.width ? '' : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" ';\n            var svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + '</svg>\\n';\n            if (typeof cb === 'function') {\n              cb(null, svgTag);\n            }\n            return svgTag;\n          };\n        }, {\n          \"./utils\": 27\n        }],\n        27: [function (require, module, exports) {\n          function hex2rgba(hex) {\n            if (typeof hex === 'number') {\n              hex = hex.toString();\n            }\n            if (typeof hex !== 'string') {\n              throw new Error('Color should be defined as hex string');\n            }\n            var hexCode = hex.slice().replace('#', '').split('');\n            if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n              throw new Error('Invalid hex color: ' + hex);\n            }\n\n            // Convert from short to long form (fff -> ffffff)\n            if (hexCode.length === 3 || hexCode.length === 4) {\n              hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n                return [c, c];\n              }));\n            }\n\n            // Add default alpha value\n            if (hexCode.length === 6) hexCode.push('F', 'F');\n            var hexValue = parseInt(hexCode.join(''), 16);\n            return {\n              r: hexValue >> 24 & 255,\n              g: hexValue >> 16 & 255,\n              b: hexValue >> 8 & 255,\n              a: hexValue & 255,\n              hex: '#' + hexCode.slice(0, 6).join('')\n            };\n          }\n          exports.getOptions = function getOptions(options) {\n            if (!options) options = {};\n            if (!options.color) options.color = {};\n            var margin = typeof options.margin === 'undefined' || options.margin === null || options.margin < 0 ? 4 : options.margin;\n            var width = options.width && options.width >= 21 ? options.width : undefined;\n            var scale = options.scale || 4;\n            return {\n              width: width,\n              scale: width ? 4 : scale,\n              margin: margin,\n              color: {\n                dark: hex2rgba(options.color.dark || '#000000ff'),\n                light: hex2rgba(options.color.light || '#ffffffff')\n              },\n              type: options.type,\n              rendererOpts: options.rendererOpts || {}\n            };\n          };\n          exports.getScale = function getScale(qrSize, opts) {\n            return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;\n          };\n          exports.getImageWidth = function getImageWidth(qrSize, opts) {\n            var scale = exports.getScale(qrSize, opts);\n            return Math.floor((qrSize + opts.margin * 2) * scale);\n          };\n          exports.qrToImageData = function qrToImageData(imgData, qr, opts) {\n            var size = qr.modules.size;\n            var data = qr.modules.data;\n            var scale = exports.getScale(size, opts);\n            var symbolSize = Math.floor((size + opts.margin * 2) * scale);\n            var scaledMargin = opts.margin * scale;\n            var palette = [opts.color.light, opts.color.dark];\n            for (var i = 0; i < symbolSize; i++) {\n              for (var j = 0; j < symbolSize; j++) {\n                var posDst = (i * symbolSize + j) * 4;\n                var pxColor = opts.color.light;\n                if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n                  var iSrc = Math.floor((i - scaledMargin) / scale);\n                  var jSrc = Math.floor((j - scaledMargin) / scale);\n                  pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];\n                }\n                imgData[posDst++] = pxColor.r;\n                imgData[posDst++] = pxColor.g;\n                imgData[posDst++] = pxColor.b;\n                imgData[posDst] = pxColor.a;\n              }\n            }\n          };\n        }, {}],\n        28: [function (require, module, exports) {\n          var isArray = require('isarray');\n          function typedArraySupport() {\n            // Can typed array instances be augmented?\n            try {\n              var arr = new Uint8Array(1);\n              arr.__proto__ = {\n                __proto__: Uint8Array.prototype,\n                foo: function () {\n                  return 42;\n                }\n              };\n              return arr.foo() === 42;\n            } catch (e) {\n              return false;\n            }\n          }\n          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n          var K_MAX_LENGTH = Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n          function Buffer(arg, offset, length) {\n            if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n              return new Buffer(arg, offset, length);\n            }\n            if (typeof arg === 'number') {\n              return allocUnsafe(this, arg);\n            }\n            return from(this, arg, offset, length);\n          }\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            Buffer.prototype.__proto__ = Uint8Array.prototype;\n            Buffer.__proto__ = Uint8Array;\n\n            // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n            if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n              Object.defineProperty(Buffer, Symbol.species, {\n                value: null,\n                configurable: true,\n                enumerable: false,\n                writable: false\n              });\n            }\n          }\n          function checked(length) {\n            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n            // length is NaN (which is otherwise coerced to zero.)\n            if (length >= K_MAX_LENGTH) {\n              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n            }\n            return length | 0;\n          }\n          function isnan(val) {\n            return val !== val; // eslint-disable-line no-self-compare\n          }\n\n          function createBuffer(that, length) {\n            var buf;\n            if (Buffer.TYPED_ARRAY_SUPPORT) {\n              buf = new Uint8Array(length);\n              buf.__proto__ = Buffer.prototype;\n            } else {\n              // Fallback: Return an object instance of the Buffer class\n              buf = that;\n              if (buf === null) {\n                buf = new Buffer(length);\n              }\n              buf.length = length;\n            }\n            return buf;\n          }\n          function allocUnsafe(that, size) {\n            var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n            if (!Buffer.TYPED_ARRAY_SUPPORT) {\n              for (var i = 0; i < size; ++i) {\n                buf[i] = 0;\n              }\n            }\n            return buf;\n          }\n          function fromString(that, string) {\n            var length = byteLength(string) | 0;\n            var buf = createBuffer(that, length);\n            var actual = buf.write(string);\n            if (actual !== length) {\n              // Writing a hex string, for example, that contains invalid characters will\n              // cause everything after the first invalid character to be ignored. (e.g.\n              // 'abxxcd' will be treated as 'ab')\n              buf = buf.slice(0, actual);\n            }\n            return buf;\n          }\n          function fromArrayLike(that, array) {\n            var length = array.length < 0 ? 0 : checked(array.length) | 0;\n            var buf = createBuffer(that, length);\n            for (var i = 0; i < length; i += 1) {\n              buf[i] = array[i] & 255;\n            }\n            return buf;\n          }\n          function fromArrayBuffer(that, array, byteOffset, length) {\n            if (byteOffset < 0 || array.byteLength < byteOffset) {\n              throw new RangeError('\\'offset\\' is out of bounds');\n            }\n            if (array.byteLength < byteOffset + (length || 0)) {\n              throw new RangeError('\\'length\\' is out of bounds');\n            }\n            var buf;\n            if (byteOffset === undefined && length === undefined) {\n              buf = new Uint8Array(array);\n            } else if (length === undefined) {\n              buf = new Uint8Array(array, byteOffset);\n            } else {\n              buf = new Uint8Array(array, byteOffset, length);\n            }\n            if (Buffer.TYPED_ARRAY_SUPPORT) {\n              // Return an augmented `Uint8Array` instance, for best performance\n              buf.__proto__ = Buffer.prototype;\n            } else {\n              // Fallback: Return an object instance of the Buffer class\n              buf = fromArrayLike(that, buf);\n            }\n            return buf;\n          }\n          function fromObject(that, obj) {\n            if (Buffer.isBuffer(obj)) {\n              var len = checked(obj.length) | 0;\n              var buf = createBuffer(that, len);\n              if (buf.length === 0) {\n                return buf;\n              }\n              obj.copy(buf, 0, 0, len);\n              return buf;\n            }\n            if (obj) {\n              if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n                if (typeof obj.length !== 'number' || isnan(obj.length)) {\n                  return createBuffer(that, 0);\n                }\n                return fromArrayLike(that, obj);\n              }\n              if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n                return fromArrayLike(that, obj.data);\n              }\n            }\n            throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n          }\n          function utf8ToBytes(string, units) {\n            units = units || Infinity;\n            var codePoint;\n            var length = string.length;\n            var leadSurrogate = null;\n            var bytes = [];\n            for (var i = 0; i < length; ++i) {\n              codePoint = string.charCodeAt(i);\n\n              // is surrogate component\n              if (codePoint > 0xD7FF && codePoint < 0xE000) {\n                // last char was a lead\n                if (!leadSurrogate) {\n                  // no lead yet\n                  if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                  } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                  }\n\n                  // valid lead\n                  leadSurrogate = codePoint;\n                  continue;\n                }\n\n                // 2 leads in a row\n                if (codePoint < 0xDC00) {\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  leadSurrogate = codePoint;\n                  continue;\n                }\n\n                // valid surrogate pair\n                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n              } else if (leadSurrogate) {\n                // valid bmp char, but last char was a lead\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n              }\n              leadSurrogate = null;\n\n              // encode utf8\n              if (codePoint < 0x80) {\n                if ((units -= 1) < 0) break;\n                bytes.push(codePoint);\n              } else if (codePoint < 0x800) {\n                if ((units -= 2) < 0) break;\n                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n              } else if (codePoint < 0x10000) {\n                if ((units -= 3) < 0) break;\n                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n              } else if (codePoint < 0x110000) {\n                if ((units -= 4) < 0) break;\n                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n              } else {\n                throw new Error('Invalid code point');\n              }\n            }\n            return bytes;\n          }\n          function byteLength(string) {\n            if (Buffer.isBuffer(string)) {\n              return string.length;\n            }\n            if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n              return string.byteLength;\n            }\n            if (typeof string !== 'string') {\n              string = '' + string;\n            }\n            var len = string.length;\n            if (len === 0) return 0;\n            return utf8ToBytes(string).length;\n          }\n          function blitBuffer(src, dst, offset, length) {\n            for (var i = 0; i < length; ++i) {\n              if (i + offset >= dst.length || i >= src.length) break;\n              dst[i + offset] = src[i];\n            }\n            return i;\n          }\n          function utf8Write(buf, string, offset, length) {\n            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n          }\n          function from(that, value, offset, length) {\n            if (typeof value === 'number') {\n              throw new TypeError('\"value\" argument must not be a number');\n            }\n            if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n              return fromArrayBuffer(that, value, offset, length);\n            }\n            if (typeof value === 'string') {\n              return fromString(that, value);\n            }\n            return fromObject(that, value);\n          }\n          Buffer.prototype.write = function write(string, offset, length) {\n            // Buffer#write(string)\n            if (offset === undefined) {\n              length = this.length;\n              offset = 0;\n              // Buffer#write(string, encoding)\n            } else if (length === undefined && typeof offset === 'string') {\n              length = this.length;\n              offset = 0;\n              // Buffer#write(string, offset[, length])\n            } else if (isFinite(offset)) {\n              offset = offset | 0;\n              if (isFinite(length)) {\n                length = length | 0;\n              } else {\n                length = undefined;\n              }\n            }\n            var remaining = this.length - offset;\n            if (length === undefined || length > remaining) length = remaining;\n            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n              throw new RangeError('Attempt to write outside buffer bounds');\n            }\n            return utf8Write(this, string, offset, length);\n          };\n          Buffer.prototype.slice = function slice(start, end) {\n            var len = this.length;\n            start = ~~start;\n            end = end === undefined ? len : ~~end;\n            if (start < 0) {\n              start += len;\n              if (start < 0) start = 0;\n            } else if (start > len) {\n              start = len;\n            }\n            if (end < 0) {\n              end += len;\n              if (end < 0) end = 0;\n            } else if (end > len) {\n              end = len;\n            }\n            if (end < start) end = start;\n            var newBuf;\n            if (Buffer.TYPED_ARRAY_SUPPORT) {\n              newBuf = this.subarray(start, end);\n              // Return an augmented `Uint8Array` instance\n              newBuf.__proto__ = Buffer.prototype;\n            } else {\n              var sliceLen = end - start;\n              newBuf = new Buffer(sliceLen, undefined);\n              for (var i = 0; i < sliceLen; ++i) {\n                newBuf[i] = this[i + start];\n              }\n            }\n            return newBuf;\n          };\n          Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n            if (!start) start = 0;\n            if (!end && end !== 0) end = this.length;\n            if (targetStart >= target.length) targetStart = target.length;\n            if (!targetStart) targetStart = 0;\n            if (end > 0 && end < start) end = start;\n\n            // Copy 0 bytes; we're done\n            if (end === start) return 0;\n            if (target.length === 0 || this.length === 0) return 0;\n\n            // Fatal error conditions\n            if (targetStart < 0) {\n              throw new RangeError('targetStart out of bounds');\n            }\n            if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n            if (end < 0) throw new RangeError('sourceEnd out of bounds');\n\n            // Are we oob?\n            if (end > this.length) end = this.length;\n            if (target.length - targetStart < end - start) {\n              end = target.length - targetStart + start;\n            }\n            var len = end - start;\n            var i;\n            if (this === target && start < targetStart && targetStart < end) {\n              // descending copy from end\n              for (i = len - 1; i >= 0; --i) {\n                target[i + targetStart] = this[i + start];\n              }\n            } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n              // ascending copy from start\n              for (i = 0; i < len; ++i) {\n                target[i + targetStart] = this[i + start];\n              }\n            } else {\n              Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n            }\n            return len;\n          };\n          Buffer.prototype.fill = function fill(val, start, end) {\n            // Handle string cases:\n            if (typeof val === 'string') {\n              if (typeof start === 'string') {\n                start = 0;\n                end = this.length;\n              } else if (typeof end === 'string') {\n                end = this.length;\n              }\n              if (val.length === 1) {\n                var code = val.charCodeAt(0);\n                if (code < 256) {\n                  val = code;\n                }\n              }\n            } else if (typeof val === 'number') {\n              val = val & 255;\n            }\n\n            // Invalid ranges are not set to a default, so can range check early.\n            if (start < 0 || this.length < start || this.length < end) {\n              throw new RangeError('Out of range index');\n            }\n            if (end <= start) {\n              return this;\n            }\n            start = start >>> 0;\n            end = end === undefined ? this.length : end >>> 0;\n            if (!val) val = 0;\n            var i;\n            if (typeof val === 'number') {\n              for (i = start; i < end; ++i) {\n                this[i] = val;\n              }\n            } else {\n              var bytes = Buffer.isBuffer(val) ? val : new Buffer(val);\n              var len = bytes.length;\n              for (i = 0; i < end - start; ++i) {\n                this[i + start] = bytes[i % len];\n              }\n            }\n            return this;\n          };\n          Buffer.concat = function concat(list, length) {\n            if (!isArray(list)) {\n              throw new TypeError('\"list\" argument must be an Array of Buffers');\n            }\n            if (list.length === 0) {\n              return createBuffer(null, 0);\n            }\n            var i;\n            if (length === undefined) {\n              length = 0;\n              for (i = 0; i < list.length; ++i) {\n                length += list[i].length;\n              }\n            }\n            var buffer = allocUnsafe(null, length);\n            var pos = 0;\n            for (i = 0; i < list.length; ++i) {\n              var buf = list[i];\n              if (!Buffer.isBuffer(buf)) {\n                throw new TypeError('\"list\" argument must be an Array of Buffers');\n              }\n              buf.copy(buffer, pos);\n              pos += buf.length;\n            }\n            return buffer;\n          };\n          Buffer.byteLength = byteLength;\n          Buffer.prototype._isBuffer = true;\n          Buffer.isBuffer = function isBuffer(b) {\n            return !!(b != null && b._isBuffer);\n          };\n          module.exports.alloc = function (size) {\n            var buffer = new Buffer(size);\n            buffer.fill(0);\n            return buffer;\n          };\n          module.exports.from = function (data) {\n            return new Buffer(data);\n          };\n        }, {\n          \"isarray\": 33\n        }],\n        29: [function (require, module, exports) {\n          exports.byteLength = byteLength;\n          exports.toByteArray = toByteArray;\n          exports.fromByteArray = fromByteArray;\n          var lookup = [];\n          var revLookup = [];\n          var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n          var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n          for (var i = 0, len = code.length; i < len; ++i) {\n            lookup[i] = code[i];\n            revLookup[code.charCodeAt(i)] = i;\n          }\n\n          // Support decoding URL-safe base64 strings, as Node.js does.\n          // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n          revLookup['-'.charCodeAt(0)] = 62;\n          revLookup['_'.charCodeAt(0)] = 63;\n          function getLens(b64) {\n            var len = b64.length;\n            if (len % 4 > 0) {\n              throw new Error('Invalid string. Length must be a multiple of 4');\n            }\n\n            // Trim off extra bytes after placeholder bytes are found\n            // See: https://github.com/beatgammit/base64-js/issues/42\n            var validLen = b64.indexOf('=');\n            if (validLen === -1) validLen = len;\n            var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n            return [validLen, placeHoldersLen];\n          }\n\n          // base64 is 4/3 + up to two characters of the original data\n          function byteLength(b64) {\n            var lens = getLens(b64);\n            var validLen = lens[0];\n            var placeHoldersLen = lens[1];\n            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n          }\n          function _byteLength(b64, validLen, placeHoldersLen) {\n            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n          }\n          function toByteArray(b64) {\n            var tmp;\n            var lens = getLens(b64);\n            var validLen = lens[0];\n            var placeHoldersLen = lens[1];\n            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n            var curByte = 0;\n\n            // if there are placeholders, only get up to the last complete 4 chars\n            var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n            var i;\n            for (i = 0; i < len; i += 4) {\n              tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n              arr[curByte++] = tmp >> 16 & 0xFF;\n              arr[curByte++] = tmp >> 8 & 0xFF;\n              arr[curByte++] = tmp & 0xFF;\n            }\n            if (placeHoldersLen === 2) {\n              tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n              arr[curByte++] = tmp & 0xFF;\n            }\n            if (placeHoldersLen === 1) {\n              tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n              arr[curByte++] = tmp >> 8 & 0xFF;\n              arr[curByte++] = tmp & 0xFF;\n            }\n            return arr;\n          }\n          function tripletToBase64(num) {\n            return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n          }\n          function encodeChunk(uint8, start, end) {\n            var tmp;\n            var output = [];\n            for (var i = start; i < end; i += 3) {\n              tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n              output.push(tripletToBase64(tmp));\n            }\n            return output.join('');\n          }\n          function fromByteArray(uint8) {\n            var tmp;\n            var len = uint8.length;\n            var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n            var parts = [];\n            var maxChunkLength = 16383; // must be multiple of 3\n\n            // go through the array every three bytes, we'll deal with trailing stuff later\n            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n              parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n            }\n\n            // pad the end with zeros, but make sure to not forget the extra bytes\n            if (extraBytes === 1) {\n              tmp = uint8[len - 1];\n              parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n            } else if (extraBytes === 2) {\n              tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n              parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n            }\n            return parts.join('');\n          }\n        }, {}],\n        30: [function (require, module, exports) {\n          var base64 = require('base64-js');\n          var ieee754 = require('ieee754');\n          var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : null;\n          exports.Buffer = Buffer;\n          exports.SlowBuffer = SlowBuffer;\n          exports.INSPECT_MAX_BYTES = 50;\n          var K_MAX_LENGTH = 0x7fffffff;\n          exports.kMaxLength = K_MAX_LENGTH;\n\n          /**\n           * If `Buffer.TYPED_ARRAY_SUPPORT`:\n           *   === true    Use Uint8Array implementation (fastest)\n           *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n           *               implementation (most compatible, even IE6)\n           *\n           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n           * Opera 11.6+, iOS 4.2+.\n           *\n           * We report that the browser does not support typed arrays if the are not subclassable\n           * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n           * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n           * for __proto__ and has a buggy typed array implementation.\n           */\n          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n          if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {\n            console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');\n          }\n          function typedArraySupport() {\n            // Can typed array instances can be augmented?\n            try {\n              var arr = new Uint8Array(1);\n              var proto = {\n                foo: function () {\n                  return 42;\n                }\n              };\n              Object.setPrototypeOf(proto, Uint8Array.prototype);\n              Object.setPrototypeOf(arr, proto);\n              return arr.foo() === 42;\n            } catch (e) {\n              return false;\n            }\n          }\n          Object.defineProperty(Buffer.prototype, 'parent', {\n            enumerable: true,\n            get: function () {\n              if (!Buffer.isBuffer(this)) return undefined;\n              return this.buffer;\n            }\n          });\n          Object.defineProperty(Buffer.prototype, 'offset', {\n            enumerable: true,\n            get: function () {\n              if (!Buffer.isBuffer(this)) return undefined;\n              return this.byteOffset;\n            }\n          });\n          function createBuffer(length) {\n            if (length > K_MAX_LENGTH) {\n              throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n            }\n            // Return an augmented `Uint8Array` instance\n            var buf = new Uint8Array(length);\n            Object.setPrototypeOf(buf, Buffer.prototype);\n            return buf;\n          }\n\n          /**\n           * The Buffer constructor returns instances of `Uint8Array` that have their\n           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n           * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n           * returns a single octet.\n           *\n           * The `Uint8Array` prototype remains unmodified.\n           */\n\n          function Buffer(arg, encodingOrOffset, length) {\n            // Common case.\n            if (typeof arg === 'number') {\n              if (typeof encodingOrOffset === 'string') {\n                throw new TypeError('The \"string\" argument must be of type string. Received type number');\n              }\n              return allocUnsafe(arg);\n            }\n            return from(arg, encodingOrOffset, length);\n          }\n\n          // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n          if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {\n            Object.defineProperty(Buffer, Symbol.species, {\n              value: null,\n              configurable: true,\n              enumerable: false,\n              writable: false\n            });\n          }\n          Buffer.poolSize = 8192; // not used by this implementation\n\n          function from(value, encodingOrOffset, length) {\n            if (typeof value === 'string') {\n              return fromString(value, encodingOrOffset);\n            }\n            if (ArrayBuffer.isView(value)) {\n              return fromArrayLike(value);\n            }\n            if (value == null) {\n              throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n            }\n            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n              return fromArrayBuffer(value, encodingOrOffset, length);\n            }\n            if (typeof value === 'number') {\n              throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n            }\n            var valueOf = value.valueOf && value.valueOf();\n            if (valueOf != null && valueOf !== value) {\n              return Buffer.from(valueOf, encodingOrOffset, length);\n            }\n            var b = fromObject(value);\n            if (b) return b;\n            if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {\n              return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n            }\n            throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n          }\n\n          /**\n           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n           * if value is a number.\n           * Buffer.from(str[, encoding])\n           * Buffer.from(array)\n           * Buffer.from(buffer)\n           * Buffer.from(arrayBuffer[, byteOffset[, length]])\n           **/\n          Buffer.from = function (value, encodingOrOffset, length) {\n            return from(value, encodingOrOffset, length);\n          };\n\n          // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n          // https://github.com/feross/buffer/pull/148\n          Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\n          Object.setPrototypeOf(Buffer, Uint8Array);\n          function assertSize(size) {\n            if (typeof size !== 'number') {\n              throw new TypeError('\"size\" argument must be of type number');\n            } else if (size < 0) {\n              throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n            }\n          }\n          function alloc(size, fill, encoding) {\n            assertSize(size);\n            if (size <= 0) {\n              return createBuffer(size);\n            }\n            if (fill !== undefined) {\n              // Only pay attention to encoding if it's a string. This\n              // prevents accidentally sending in a number that would\n              // be interpretted as a start offset.\n              return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n            }\n            return createBuffer(size);\n          }\n\n          /**\n           * Creates a new filled Buffer instance.\n           * alloc(size[, fill[, encoding]])\n           **/\n          Buffer.alloc = function (size, fill, encoding) {\n            return alloc(size, fill, encoding);\n          };\n          function allocUnsafe(size) {\n            assertSize(size);\n            return createBuffer(size < 0 ? 0 : checked(size) | 0);\n          }\n\n          /**\n           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n           * */\n          Buffer.allocUnsafe = function (size) {\n            return allocUnsafe(size);\n          };\n          /**\n           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n           */\n          Buffer.allocUnsafeSlow = function (size) {\n            return allocUnsafe(size);\n          };\n          function fromString(string, encoding) {\n            if (typeof encoding !== 'string' || encoding === '') {\n              encoding = 'utf8';\n            }\n            if (!Buffer.isEncoding(encoding)) {\n              throw new TypeError('Unknown encoding: ' + encoding);\n            }\n            var length = byteLength(string, encoding) | 0;\n            var buf = createBuffer(length);\n            var actual = buf.write(string, encoding);\n            if (actual !== length) {\n              // Writing a hex string, for example, that contains invalid characters will\n              // cause everything after the first invalid character to be ignored. (e.g.\n              // 'abxxcd' will be treated as 'ab')\n              buf = buf.slice(0, actual);\n            }\n            return buf;\n          }\n          function fromArrayLike(array) {\n            var length = array.length < 0 ? 0 : checked(array.length) | 0;\n            var buf = createBuffer(length);\n            for (var i = 0; i < length; i += 1) {\n              buf[i] = array[i] & 255;\n            }\n            return buf;\n          }\n          function fromArrayBuffer(array, byteOffset, length) {\n            if (byteOffset < 0 || array.byteLength < byteOffset) {\n              throw new RangeError('\"offset\" is outside of buffer bounds');\n            }\n            if (array.byteLength < byteOffset + (length || 0)) {\n              throw new RangeError('\"length\" is outside of buffer bounds');\n            }\n            var buf;\n            if (byteOffset === undefined && length === undefined) {\n              buf = new Uint8Array(array);\n            } else if (length === undefined) {\n              buf = new Uint8Array(array, byteOffset);\n            } else {\n              buf = new Uint8Array(array, byteOffset, length);\n            }\n\n            // Return an augmented `Uint8Array` instance\n            Object.setPrototypeOf(buf, Buffer.prototype);\n            return buf;\n          }\n          function fromObject(obj) {\n            if (Buffer.isBuffer(obj)) {\n              var len = checked(obj.length) | 0;\n              var buf = createBuffer(len);\n              if (buf.length === 0) {\n                return buf;\n              }\n              obj.copy(buf, 0, 0, len);\n              return buf;\n            }\n            if (obj.length !== undefined) {\n              if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n                return createBuffer(0);\n              }\n              return fromArrayLike(obj);\n            }\n            if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n              return fromArrayLike(obj.data);\n            }\n          }\n          function checked(length) {\n            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n            // length is NaN (which is otherwise coerced to zero.)\n            if (length >= K_MAX_LENGTH) {\n              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n            }\n            return length | 0;\n          }\n          function SlowBuffer(length) {\n            if (+length != length) {\n              // eslint-disable-line eqeqeq\n              length = 0;\n            }\n            return Buffer.alloc(+length);\n          }\n          Buffer.isBuffer = function isBuffer(b) {\n            return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n          };\n\n          Buffer.compare = function compare(a, b) {\n            if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n            if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n              throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n            }\n            if (a === b) return 0;\n            var x = a.length;\n            var y = b.length;\n            for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n              if (a[i] !== b[i]) {\n                x = a[i];\n                y = b[i];\n                break;\n              }\n            }\n            if (x < y) return -1;\n            if (y < x) return 1;\n            return 0;\n          };\n          Buffer.isEncoding = function isEncoding(encoding) {\n            switch (String(encoding).toLowerCase()) {\n              case 'hex':\n              case 'utf8':\n              case 'utf-8':\n              case 'ascii':\n              case 'latin1':\n              case 'binary':\n              case 'base64':\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return true;\n              default:\n                return false;\n            }\n          };\n          Buffer.concat = function concat(list, length) {\n            if (!Array.isArray(list)) {\n              throw new TypeError('\"list\" argument must be an Array of Buffers');\n            }\n            if (list.length === 0) {\n              return Buffer.alloc(0);\n            }\n            var i;\n            if (length === undefined) {\n              length = 0;\n              for (i = 0; i < list.length; ++i) {\n                length += list[i].length;\n              }\n            }\n            var buffer = Buffer.allocUnsafe(length);\n            var pos = 0;\n            for (i = 0; i < list.length; ++i) {\n              var buf = list[i];\n              if (isInstance(buf, Uint8Array)) {\n                buf = Buffer.from(buf);\n              }\n              if (!Buffer.isBuffer(buf)) {\n                throw new TypeError('\"list\" argument must be an Array of Buffers');\n              }\n              buf.copy(buffer, pos);\n              pos += buf.length;\n            }\n            return buffer;\n          };\n          function byteLength(string, encoding) {\n            if (Buffer.isBuffer(string)) {\n              return string.length;\n            }\n            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n              return string.byteLength;\n            }\n            if (typeof string !== 'string') {\n              throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);\n            }\n            var len = string.length;\n            var mustMatch = arguments.length > 2 && arguments[2] === true;\n            if (!mustMatch && len === 0) return 0;\n\n            // Use a for loop to avoid recursion\n            var loweredCase = false;\n            for (;;) {\n              switch (encoding) {\n                case 'ascii':\n                case 'latin1':\n                case 'binary':\n                  return len;\n                case 'utf8':\n                case 'utf-8':\n                  return utf8ToBytes(string).length;\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return len * 2;\n                case 'hex':\n                  return len >>> 1;\n                case 'base64':\n                  return base64ToBytes(string).length;\n                default:\n                  if (loweredCase) {\n                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n                  }\n\n                  encoding = ('' + encoding).toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          }\n          Buffer.byteLength = byteLength;\n          function slowToString(encoding, start, end) {\n            var loweredCase = false;\n\n            // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n            // property of a typed array.\n\n            // This behaves neither like String nor Uint8Array in that we set start/end\n            // to their upper/lower bounds if the value passed is out of range.\n            // undefined is handled specially as per ECMA-262 6th Edition,\n            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n            if (start === undefined || start < 0) {\n              start = 0;\n            }\n            // Return early if start > this.length. Done here to prevent potential uint32\n            // coercion fail below.\n            if (start > this.length) {\n              return '';\n            }\n            if (end === undefined || end > this.length) {\n              end = this.length;\n            }\n            if (end <= 0) {\n              return '';\n            }\n\n            // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n            end >>>= 0;\n            start >>>= 0;\n            if (end <= start) {\n              return '';\n            }\n            if (!encoding) encoding = 'utf8';\n            while (true) {\n              switch (encoding) {\n                case 'hex':\n                  return hexSlice(this, start, end);\n                case 'utf8':\n                case 'utf-8':\n                  return utf8Slice(this, start, end);\n                case 'ascii':\n                  return asciiSlice(this, start, end);\n                case 'latin1':\n                case 'binary':\n                  return latin1Slice(this, start, end);\n                case 'base64':\n                  return base64Slice(this, start, end);\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return utf16leSlice(this, start, end);\n                default:\n                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                  encoding = (encoding + '').toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          }\n\n          // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n          // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n          // reliably in a browserify context because there could be multiple different\n          // copies of the 'buffer' package in use. This method works even for Buffer\n          // instances that were created from another copy of the `buffer` package.\n          // See: https://github.com/feross/buffer/issues/154\n          Buffer.prototype._isBuffer = true;\n          function swap(b, n, m) {\n            var i = b[n];\n            b[n] = b[m];\n            b[m] = i;\n          }\n          Buffer.prototype.swap16 = function swap16() {\n            var len = this.length;\n            if (len % 2 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 16-bits');\n            }\n            for (var i = 0; i < len; i += 2) {\n              swap(this, i, i + 1);\n            }\n            return this;\n          };\n          Buffer.prototype.swap32 = function swap32() {\n            var len = this.length;\n            if (len % 4 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 32-bits');\n            }\n            for (var i = 0; i < len; i += 4) {\n              swap(this, i, i + 3);\n              swap(this, i + 1, i + 2);\n            }\n            return this;\n          };\n          Buffer.prototype.swap64 = function swap64() {\n            var len = this.length;\n            if (len % 8 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 64-bits');\n            }\n            for (var i = 0; i < len; i += 8) {\n              swap(this, i, i + 7);\n              swap(this, i + 1, i + 6);\n              swap(this, i + 2, i + 5);\n              swap(this, i + 3, i + 4);\n            }\n            return this;\n          };\n          Buffer.prototype.toString = function toString() {\n            var length = this.length;\n            if (length === 0) return '';\n            if (arguments.length === 0) return utf8Slice(this, 0, length);\n            return slowToString.apply(this, arguments);\n          };\n          Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n          Buffer.prototype.equals = function equals(b) {\n            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n            if (this === b) return true;\n            return Buffer.compare(this, b) === 0;\n          };\n          Buffer.prototype.inspect = function inspect() {\n            var str = '';\n            var max = exports.INSPECT_MAX_BYTES;\n            str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n            if (this.length > max) str += ' ... ';\n            return '<Buffer ' + str + '>';\n          };\n          if (customInspectSymbol) {\n            Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n          }\n          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n            if (isInstance(target, Uint8Array)) {\n              target = Buffer.from(target, target.offset, target.byteLength);\n            }\n            if (!Buffer.isBuffer(target)) {\n              throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);\n            }\n            if (start === undefined) {\n              start = 0;\n            }\n            if (end === undefined) {\n              end = target ? target.length : 0;\n            }\n            if (thisStart === undefined) {\n              thisStart = 0;\n            }\n            if (thisEnd === undefined) {\n              thisEnd = this.length;\n            }\n            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n              throw new RangeError('out of range index');\n            }\n            if (thisStart >= thisEnd && start >= end) {\n              return 0;\n            }\n            if (thisStart >= thisEnd) {\n              return -1;\n            }\n            if (start >= end) {\n              return 1;\n            }\n            start >>>= 0;\n            end >>>= 0;\n            thisStart >>>= 0;\n            thisEnd >>>= 0;\n            if (this === target) return 0;\n            var x = thisEnd - thisStart;\n            var y = end - start;\n            var len = Math.min(x, y);\n            var thisCopy = this.slice(thisStart, thisEnd);\n            var targetCopy = target.slice(start, end);\n            for (var i = 0; i < len; ++i) {\n              if (thisCopy[i] !== targetCopy[i]) {\n                x = thisCopy[i];\n                y = targetCopy[i];\n                break;\n              }\n            }\n            if (x < y) return -1;\n            if (y < x) return 1;\n            return 0;\n          };\n\n          // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n          //\n          // Arguments:\n          // - buffer - a Buffer to search\n          // - val - a string, Buffer, or number\n          // - byteOffset - an index into `buffer`; will be clamped to an int32\n          // - encoding - an optional encoding, relevant is val is a string\n          // - dir - true for indexOf, false for lastIndexOf\n          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n            // Empty buffer means no match\n            if (buffer.length === 0) return -1;\n\n            // Normalize byteOffset\n            if (typeof byteOffset === 'string') {\n              encoding = byteOffset;\n              byteOffset = 0;\n            } else if (byteOffset > 0x7fffffff) {\n              byteOffset = 0x7fffffff;\n            } else if (byteOffset < -0x80000000) {\n              byteOffset = -0x80000000;\n            }\n            byteOffset = +byteOffset; // Coerce to Number.\n            if (numberIsNaN(byteOffset)) {\n              // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n              byteOffset = dir ? 0 : buffer.length - 1;\n            }\n\n            // Normalize byteOffset: negative offsets start from the end of the buffer\n            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n            if (byteOffset >= buffer.length) {\n              if (dir) return -1;else byteOffset = buffer.length - 1;\n            } else if (byteOffset < 0) {\n              if (dir) byteOffset = 0;else return -1;\n            }\n\n            // Normalize val\n            if (typeof val === 'string') {\n              val = Buffer.from(val, encoding);\n            }\n\n            // Finally, search either indexOf (if dir is true) or lastIndexOf\n            if (Buffer.isBuffer(val)) {\n              // Special case: looking for empty string/buffer always fails\n              if (val.length === 0) {\n                return -1;\n              }\n              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n            } else if (typeof val === 'number') {\n              val = val & 0xFF; // Search for a byte value [0-255]\n              if (typeof Uint8Array.prototype.indexOf === 'function') {\n                if (dir) {\n                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n                } else {\n                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n                }\n              }\n              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n            }\n            throw new TypeError('val must be string, number or Buffer');\n          }\n          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n            var indexSize = 1;\n            var arrLength = arr.length;\n            var valLength = val.length;\n            if (encoding !== undefined) {\n              encoding = String(encoding).toLowerCase();\n              if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n                if (arr.length < 2 || val.length < 2) {\n                  return -1;\n                }\n                indexSize = 2;\n                arrLength /= 2;\n                valLength /= 2;\n                byteOffset /= 2;\n              }\n            }\n            function read(buf, i) {\n              if (indexSize === 1) {\n                return buf[i];\n              } else {\n                return buf.readUInt16BE(i * indexSize);\n              }\n            }\n            var i;\n            if (dir) {\n              var foundIndex = -1;\n              for (i = byteOffset; i < arrLength; i++) {\n                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                  if (foundIndex === -1) foundIndex = i;\n                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n                } else {\n                  if (foundIndex !== -1) i -= i - foundIndex;\n                  foundIndex = -1;\n                }\n              }\n            } else {\n              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n              for (i = byteOffset; i >= 0; i--) {\n                var found = true;\n                for (var j = 0; j < valLength; j++) {\n                  if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                  }\n                }\n                if (found) return i;\n              }\n            }\n            return -1;\n          }\n          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n            return this.indexOf(val, byteOffset, encoding) !== -1;\n          };\n          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n          };\n          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n          };\n          function hexWrite(buf, string, offset, length) {\n            offset = Number(offset) || 0;\n            var remaining = buf.length - offset;\n            if (!length) {\n              length = remaining;\n            } else {\n              length = Number(length);\n              if (length > remaining) {\n                length = remaining;\n              }\n            }\n            var strLen = string.length;\n            if (length > strLen / 2) {\n              length = strLen / 2;\n            }\n            for (var i = 0; i < length; ++i) {\n              var parsed = parseInt(string.substr(i * 2, 2), 16);\n              if (numberIsNaN(parsed)) return i;\n              buf[offset + i] = parsed;\n            }\n            return i;\n          }\n          function utf8Write(buf, string, offset, length) {\n            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n          }\n          function asciiWrite(buf, string, offset, length) {\n            return blitBuffer(asciiToBytes(string), buf, offset, length);\n          }\n          function latin1Write(buf, string, offset, length) {\n            return asciiWrite(buf, string, offset, length);\n          }\n          function base64Write(buf, string, offset, length) {\n            return blitBuffer(base64ToBytes(string), buf, offset, length);\n          }\n          function ucs2Write(buf, string, offset, length) {\n            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n          }\n          Buffer.prototype.write = function write(string, offset, length, encoding) {\n            // Buffer#write(string)\n            if (offset === undefined) {\n              encoding = 'utf8';\n              length = this.length;\n              offset = 0;\n              // Buffer#write(string, encoding)\n            } else if (length === undefined && typeof offset === 'string') {\n              encoding = offset;\n              length = this.length;\n              offset = 0;\n              // Buffer#write(string, offset[, length][, encoding])\n            } else if (isFinite(offset)) {\n              offset = offset >>> 0;\n              if (isFinite(length)) {\n                length = length >>> 0;\n                if (encoding === undefined) encoding = 'utf8';\n              } else {\n                encoding = length;\n                length = undefined;\n              }\n            } else {\n              throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n            }\n            var remaining = this.length - offset;\n            if (length === undefined || length > remaining) length = remaining;\n            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n              throw new RangeError('Attempt to write outside buffer bounds');\n            }\n            if (!encoding) encoding = 'utf8';\n            var loweredCase = false;\n            for (;;) {\n              switch (encoding) {\n                case 'hex':\n                  return hexWrite(this, string, offset, length);\n                case 'utf8':\n                case 'utf-8':\n                  return utf8Write(this, string, offset, length);\n                case 'ascii':\n                  return asciiWrite(this, string, offset, length);\n                case 'latin1':\n                case 'binary':\n                  return latin1Write(this, string, offset, length);\n                case 'base64':\n                  // Warning: maxLength not taken into account in base64Write\n                  return base64Write(this, string, offset, length);\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return ucs2Write(this, string, offset, length);\n                default:\n                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                  encoding = ('' + encoding).toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          };\n          Buffer.prototype.toJSON = function toJSON() {\n            return {\n              type: 'Buffer',\n              data: Array.prototype.slice.call(this._arr || this, 0)\n            };\n          };\n          function base64Slice(buf, start, end) {\n            if (start === 0 && end === buf.length) {\n              return base64.fromByteArray(buf);\n            } else {\n              return base64.fromByteArray(buf.slice(start, end));\n            }\n          }\n          function utf8Slice(buf, start, end) {\n            end = Math.min(buf.length, end);\n            var res = [];\n            var i = start;\n            while (i < end) {\n              var firstByte = buf[i];\n              var codePoint = null;\n              var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n              if (i + bytesPerSequence <= end) {\n                var secondByte, thirdByte, fourthByte, tempCodePoint;\n                switch (bytesPerSequence) {\n                  case 1:\n                    if (firstByte < 0x80) {\n                      codePoint = firstByte;\n                    }\n                    break;\n                  case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                      if (tempCodePoint > 0x7F) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n                    break;\n                  case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n                    break;\n                  case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n                }\n              }\n              if (codePoint === null) {\n                // we did not generate a valid codePoint so insert a\n                // replacement char (U+FFFD) and advance only 1 byte\n                codePoint = 0xFFFD;\n                bytesPerSequence = 1;\n              } else if (codePoint > 0xFFFF) {\n                // encode to utf16 (surrogate pair dance)\n                codePoint -= 0x10000;\n                res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n                codePoint = 0xDC00 | codePoint & 0x3FF;\n              }\n              res.push(codePoint);\n              i += bytesPerSequence;\n            }\n            return decodeCodePointsArray(res);\n          }\n\n          // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n          // the lowest limit is Chrome, with 0x10000 args.\n          // We go 1 magnitude less, for safety\n          var MAX_ARGUMENTS_LENGTH = 0x1000;\n          function decodeCodePointsArray(codePoints) {\n            var len = codePoints.length;\n            if (len <= MAX_ARGUMENTS_LENGTH) {\n              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n            }\n\n            // Decode in chunks to avoid \"call stack size exceeded\".\n            var res = '';\n            var i = 0;\n            while (i < len) {\n              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n            }\n            return res;\n          }\n          function asciiSlice(buf, start, end) {\n            var ret = '';\n            end = Math.min(buf.length, end);\n            for (var i = start; i < end; ++i) {\n              ret += String.fromCharCode(buf[i] & 0x7F);\n            }\n            return ret;\n          }\n          function latin1Slice(buf, start, end) {\n            var ret = '';\n            end = Math.min(buf.length, end);\n            for (var i = start; i < end; ++i) {\n              ret += String.fromCharCode(buf[i]);\n            }\n            return ret;\n          }\n          function hexSlice(buf, start, end) {\n            var len = buf.length;\n            if (!start || start < 0) start = 0;\n            if (!end || end < 0 || end > len) end = len;\n            var out = '';\n            for (var i = start; i < end; ++i) {\n              out += hexSliceLookupTable[buf[i]];\n            }\n            return out;\n          }\n          function utf16leSlice(buf, start, end) {\n            var bytes = buf.slice(start, end);\n            var res = '';\n            for (var i = 0; i < bytes.length; i += 2) {\n              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n            }\n            return res;\n          }\n          Buffer.prototype.slice = function slice(start, end) {\n            var len = this.length;\n            start = ~~start;\n            end = end === undefined ? len : ~~end;\n            if (start < 0) {\n              start += len;\n              if (start < 0) start = 0;\n            } else if (start > len) {\n              start = len;\n            }\n            if (end < 0) {\n              end += len;\n              if (end < 0) end = 0;\n            } else if (end > len) {\n              end = len;\n            }\n            if (end < start) end = start;\n            var newBuf = this.subarray(start, end);\n            // Return an augmented `Uint8Array` instance\n            Object.setPrototypeOf(newBuf, Buffer.prototype);\n            return newBuf;\n          };\n\n          /*\n           * Need to make sure that buffer isn't trying to write out of bounds.\n           */\n          function checkOffset(offset, ext, length) {\n            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n          }\n          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var val = this[offset];\n            var mul = 1;\n            var i = 0;\n            while (++i < byteLength && (mul *= 0x100)) {\n              val += this[offset + i] * mul;\n            }\n            return val;\n          };\n          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) {\n              checkOffset(offset, byteLength, this.length);\n            }\n            var val = this[offset + --byteLength];\n            var mul = 1;\n            while (byteLength > 0 && (mul *= 0x100)) {\n              val += this[offset + --byteLength] * mul;\n            }\n            return val;\n          };\n          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 1, this.length);\n            return this[offset];\n          };\n          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            return this[offset] | this[offset + 1] << 8;\n          };\n          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            return this[offset] << 8 | this[offset + 1];\n          };\n          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n          };\n          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n          };\n          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var val = this[offset];\n            var mul = 1;\n            var i = 0;\n            while (++i < byteLength && (mul *= 0x100)) {\n              val += this[offset + i] * mul;\n            }\n            mul *= 0x80;\n            if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n            return val;\n          };\n          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var i = byteLength;\n            var mul = 1;\n            var val = this[offset + --i];\n            while (i > 0 && (mul *= 0x100)) {\n              val += this[offset + --i] * mul;\n            }\n            mul *= 0x80;\n            if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n            return val;\n          };\n          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 1, this.length);\n            if (!(this[offset] & 0x80)) return this[offset];\n            return (0xff - this[offset] + 1) * -1;\n          };\n          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            var val = this[offset] | this[offset + 1] << 8;\n            return val & 0x8000 ? val | 0xFFFF0000 : val;\n          };\n          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            var val = this[offset + 1] | this[offset] << 8;\n            return val & 0x8000 ? val | 0xFFFF0000 : val;\n          };\n          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n          };\n          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n          };\n          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return ieee754.read(this, offset, true, 23, 4);\n          };\n          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return ieee754.read(this, offset, false, 23, 4);\n          };\n          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 8, this.length);\n            return ieee754.read(this, offset, true, 52, 8);\n          };\n          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 8, this.length);\n            return ieee754.read(this, offset, false, 52, 8);\n          };\n          function checkInt(buf, value, offset, ext, max, min) {\n            if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n            if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n            if (offset + ext > buf.length) throw new RangeError('Index out of range');\n          }\n          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) {\n              var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n              checkInt(this, value, offset, byteLength, maxBytes, 0);\n            }\n            var mul = 1;\n            var i = 0;\n            this[offset] = value & 0xFF;\n            while (++i < byteLength && (mul *= 0x100)) {\n              this[offset + i] = value / mul & 0xFF;\n            }\n            return offset + byteLength;\n          };\n          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) {\n              var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n              checkInt(this, value, offset, byteLength, maxBytes, 0);\n            }\n            var i = byteLength - 1;\n            var mul = 1;\n            this[offset + i] = value & 0xFF;\n            while (--i >= 0 && (mul *= 0x100)) {\n              this[offset + i] = value / mul & 0xFF;\n            }\n            return offset + byteLength;\n          };\n          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n            this[offset] = value & 0xff;\n            return offset + 1;\n          };\n          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            return offset + 2;\n          };\n          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n            return offset + 2;\n          };\n          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n            this[offset + 3] = value >>> 24;\n            this[offset + 2] = value >>> 16;\n            this[offset + 1] = value >>> 8;\n            this[offset] = value & 0xff;\n            return offset + 4;\n          };\n          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n            return offset + 4;\n          };\n          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) {\n              var limit = Math.pow(2, 8 * byteLength - 1);\n              checkInt(this, value, offset, byteLength, limit - 1, -limit);\n            }\n            var i = 0;\n            var mul = 1;\n            var sub = 0;\n            this[offset] = value & 0xFF;\n            while (++i < byteLength && (mul *= 0x100)) {\n              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n                sub = 1;\n              }\n              this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n            }\n            return offset + byteLength;\n          };\n          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) {\n              var limit = Math.pow(2, 8 * byteLength - 1);\n              checkInt(this, value, offset, byteLength, limit - 1, -limit);\n            }\n            var i = byteLength - 1;\n            var mul = 1;\n            var sub = 0;\n            this[offset + i] = value & 0xFF;\n            while (--i >= 0 && (mul *= 0x100)) {\n              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n                sub = 1;\n              }\n              this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n            }\n            return offset + byteLength;\n          };\n          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n            if (value < 0) value = 0xff + value + 1;\n            this[offset] = value & 0xff;\n            return offset + 1;\n          };\n          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            return offset + 2;\n          };\n          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n            return offset + 2;\n          };\n          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            this[offset + 2] = value >>> 16;\n            this[offset + 3] = value >>> 24;\n            return offset + 4;\n          };\n          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n            if (value < 0) value = 0xffffffff + value + 1;\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n            return offset + 4;\n          };\n          function checkIEEE754(buf, value, offset, ext, max, min) {\n            if (offset + ext > buf.length) throw new RangeError('Index out of range');\n            if (offset < 0) throw new RangeError('Index out of range');\n          }\n          function writeFloat(buf, value, offset, littleEndian, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) {\n              checkIEEE754(buf, value, offset, 4);\n            }\n            ieee754.write(buf, value, offset, littleEndian, 23, 4);\n            return offset + 4;\n          }\n          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n            return writeFloat(this, value, offset, true, noAssert);\n          };\n          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n            return writeFloat(this, value, offset, false, noAssert);\n          };\n          function writeDouble(buf, value, offset, littleEndian, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) {\n              checkIEEE754(buf, value, offset, 8);\n            }\n            ieee754.write(buf, value, offset, littleEndian, 52, 8);\n            return offset + 8;\n          }\n          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n            return writeDouble(this, value, offset, true, noAssert);\n          };\n          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n            return writeDouble(this, value, offset, false, noAssert);\n          };\n\n          // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n          Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n            if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n            if (!start) start = 0;\n            if (!end && end !== 0) end = this.length;\n            if (targetStart >= target.length) targetStart = target.length;\n            if (!targetStart) targetStart = 0;\n            if (end > 0 && end < start) end = start;\n\n            // Copy 0 bytes; we're done\n            if (end === start) return 0;\n            if (target.length === 0 || this.length === 0) return 0;\n\n            // Fatal error conditions\n            if (targetStart < 0) {\n              throw new RangeError('targetStart out of bounds');\n            }\n            if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n            if (end < 0) throw new RangeError('sourceEnd out of bounds');\n\n            // Are we oob?\n            if (end > this.length) end = this.length;\n            if (target.length - targetStart < end - start) {\n              end = target.length - targetStart + start;\n            }\n            var len = end - start;\n            if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n              // Use built-in when available, missing from IE11\n              this.copyWithin(targetStart, start, end);\n            } else if (this === target && start < targetStart && targetStart < end) {\n              // descending copy from end\n              for (var i = len - 1; i >= 0; --i) {\n                target[i + targetStart] = this[i + start];\n              }\n            } else {\n              Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n            }\n            return len;\n          };\n\n          // Usage:\n          //    buffer.fill(number[, offset[, end]])\n          //    buffer.fill(buffer[, offset[, end]])\n          //    buffer.fill(string[, offset[, end]][, encoding])\n          Buffer.prototype.fill = function fill(val, start, end, encoding) {\n            // Handle string cases:\n            if (typeof val === 'string') {\n              if (typeof start === 'string') {\n                encoding = start;\n                start = 0;\n                end = this.length;\n              } else if (typeof end === 'string') {\n                encoding = end;\n                end = this.length;\n              }\n              if (encoding !== undefined && typeof encoding !== 'string') {\n                throw new TypeError('encoding must be a string');\n              }\n              if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n                throw new TypeError('Unknown encoding: ' + encoding);\n              }\n              if (val.length === 1) {\n                var code = val.charCodeAt(0);\n                if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {\n                  // Fast path: If `val` fits into a single byte, use that numeric value.\n                  val = code;\n                }\n              }\n            } else if (typeof val === 'number') {\n              val = val & 255;\n            } else if (typeof val === 'boolean') {\n              val = Number(val);\n            }\n\n            // Invalid ranges are not set to a default, so can range check early.\n            if (start < 0 || this.length < start || this.length < end) {\n              throw new RangeError('Out of range index');\n            }\n            if (end <= start) {\n              return this;\n            }\n            start = start >>> 0;\n            end = end === undefined ? this.length : end >>> 0;\n            if (!val) val = 0;\n            var i;\n            if (typeof val === 'number') {\n              for (i = start; i < end; ++i) {\n                this[i] = val;\n              }\n            } else {\n              var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n              var len = bytes.length;\n              if (len === 0) {\n                throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n              }\n              for (i = 0; i < end - start; ++i) {\n                this[i + start] = bytes[i % len];\n              }\n            }\n            return this;\n          };\n\n          // HELPER FUNCTIONS\n          // ================\n\n          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n          function base64clean(str) {\n            // Node takes equal signs as end of the Base64 encoding\n            str = str.split('=')[0];\n            // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n            str = str.trim().replace(INVALID_BASE64_RE, '');\n            // Node converts strings with length < 2 to ''\n            if (str.length < 2) return '';\n            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n            while (str.length % 4 !== 0) {\n              str = str + '=';\n            }\n            return str;\n          }\n          function utf8ToBytes(string, units) {\n            units = units || Infinity;\n            var codePoint;\n            var length = string.length;\n            var leadSurrogate = null;\n            var bytes = [];\n            for (var i = 0; i < length; ++i) {\n              codePoint = string.charCodeAt(i);\n\n              // is surrogate component\n              if (codePoint > 0xD7FF && codePoint < 0xE000) {\n                // last char was a lead\n                if (!leadSurrogate) {\n                  // no lead yet\n                  if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                  } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                  }\n\n                  // valid lead\n                  leadSurrogate = codePoint;\n                  continue;\n                }\n\n                // 2 leads in a row\n                if (codePoint < 0xDC00) {\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  leadSurrogate = codePoint;\n                  continue;\n                }\n\n                // valid surrogate pair\n                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n              } else if (leadSurrogate) {\n                // valid bmp char, but last char was a lead\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n              }\n              leadSurrogate = null;\n\n              // encode utf8\n              if (codePoint < 0x80) {\n                if ((units -= 1) < 0) break;\n                bytes.push(codePoint);\n              } else if (codePoint < 0x800) {\n                if ((units -= 2) < 0) break;\n                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n              } else if (codePoint < 0x10000) {\n                if ((units -= 3) < 0) break;\n                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n              } else if (codePoint < 0x110000) {\n                if ((units -= 4) < 0) break;\n                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n              } else {\n                throw new Error('Invalid code point');\n              }\n            }\n            return bytes;\n          }\n          function asciiToBytes(str) {\n            var byteArray = [];\n            for (var i = 0; i < str.length; ++i) {\n              // Node's code seems to be doing this and not & 0x7F..\n              byteArray.push(str.charCodeAt(i) & 0xFF);\n            }\n            return byteArray;\n          }\n          function utf16leToBytes(str, units) {\n            var c, hi, lo;\n            var byteArray = [];\n            for (var i = 0; i < str.length; ++i) {\n              if ((units -= 2) < 0) break;\n              c = str.charCodeAt(i);\n              hi = c >> 8;\n              lo = c % 256;\n              byteArray.push(lo);\n              byteArray.push(hi);\n            }\n            return byteArray;\n          }\n          function base64ToBytes(str) {\n            return base64.toByteArray(base64clean(str));\n          }\n          function blitBuffer(src, dst, offset, length) {\n            for (var i = 0; i < length; ++i) {\n              if (i + offset >= dst.length || i >= src.length) break;\n              dst[i + offset] = src[i];\n            }\n            return i;\n          }\n\n          // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n          // the `instanceof` check but they should be treated as of that type.\n          // See: https://github.com/feross/buffer/issues/166\n          function isInstance(obj, type) {\n            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n          }\n          function numberIsNaN(obj) {\n            // For IE11 support\n            return obj !== obj; // eslint-disable-line no-self-compare\n          }\n\n          // Create lookup table for `toString('hex')`\n          // See: https://github.com/feross/buffer/issues/219\n          var hexSliceLookupTable = function () {\n            var alphabet = '0123456789abcdef';\n            var table = new Array(256);\n            for (var i = 0; i < 16; ++i) {\n              var i16 = i * 16;\n              for (var j = 0; j < 16; ++j) {\n                table[i16 + j] = alphabet[i] + alphabet[j];\n              }\n            }\n            return table;\n          }();\n        }, {\n          \"base64-js\": 29,\n          \"ieee754\": 32\n        }],\n        31: [function (require, module, exports) {\n          /******************************************************************************\n           * Created 2008-08-19.\n           *\n           * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n           *\n           * Copyright (C) 2008\n           *   Wyatt Baldwin <self@wyattbaldwin.com>\n           *   All rights reserved\n           *\n           * Licensed under the MIT license.\n           *\n           *   http://www.opensource.org/licenses/mit-license.php\n           *\n           * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n           * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n           * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n           * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n           * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n           * THE SOFTWARE.\n           *****************************************************************************/\n          var dijkstra = {\n            single_source_shortest_paths: function (graph, s, d) {\n              // Predecessor map for each node that has been encountered.\n              // node ID => predecessor node ID\n              var predecessors = {};\n\n              // Costs of shortest paths from s to all nodes encountered.\n              // node ID => cost\n              var costs = {};\n              costs[s] = 0;\n\n              // Costs of shortest paths from s to all nodes encountered; differs from\n              // `costs` in that it provides easy access to the node that currently has\n              // the known shortest path from s.\n              // XXX: Do we actually need both `costs` and `open`?\n              var open = dijkstra.PriorityQueue.make();\n              open.push(s, 0);\n              var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;\n              while (!open.empty()) {\n                // In the nodes remaining in graph that have a known cost from s,\n                // find the node, u, that currently has the shortest path from s.\n                closest = open.pop();\n                u = closest.value;\n                cost_of_s_to_u = closest.cost;\n\n                // Get nodes adjacent to u...\n                adjacent_nodes = graph[u] || {};\n\n                // ...and explore the edges that connect u to those nodes, updating\n                // the cost of the shortest paths to any or all of those nodes as\n                // necessary. v is the node across the current edge from u.\n                for (v in adjacent_nodes) {\n                  if (adjacent_nodes.hasOwnProperty(v)) {\n                    // Get the cost of the edge running from u to v.\n                    cost_of_e = adjacent_nodes[v];\n\n                    // Cost of s to u plus the cost of u to v across e--this is *a*\n                    // cost from s to v that may or may not be less than the current\n                    // known cost to v.\n                    cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n\n                    // If we haven't visited v yet OR if the current known cost from s to\n                    // v is greater than the new cost we just found (cost of s to u plus\n                    // cost of u to v across e), update v's cost in the cost list and\n                    // update v's predecessor in the predecessor list (it's now u).\n                    cost_of_s_to_v = costs[v];\n                    first_visit = typeof costs[v] === 'undefined';\n                    if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n                      costs[v] = cost_of_s_to_u_plus_cost_of_e;\n                      open.push(v, cost_of_s_to_u_plus_cost_of_e);\n                      predecessors[v] = u;\n                    }\n                  }\n                }\n              }\n              if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {\n                var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n                throw new Error(msg);\n              }\n              return predecessors;\n            },\n            extract_shortest_path_from_predecessor_list: function (predecessors, d) {\n              var nodes = [];\n              var u = d;\n              var predecessor;\n              while (u) {\n                nodes.push(u);\n                predecessor = predecessors[u];\n                u = predecessors[u];\n              }\n              nodes.reverse();\n              return nodes;\n            },\n            find_path: function (graph, s, d) {\n              var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n              return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);\n            },\n            /**\n             * A very naive priority queue implementation.\n             */\n            PriorityQueue: {\n              make: function (opts) {\n                var T = dijkstra.PriorityQueue,\n                  t = {},\n                  key;\n                opts = opts || {};\n                for (key in T) {\n                  if (T.hasOwnProperty(key)) {\n                    t[key] = T[key];\n                  }\n                }\n                t.queue = [];\n                t.sorter = opts.sorter || T.default_sorter;\n                return t;\n              },\n              default_sorter: function (a, b) {\n                return a.cost - b.cost;\n              },\n              /**\n               * Add a new item to the queue and ensure the highest priority element\n               * is at the front of the queue.\n               */\n              push: function (value, cost) {\n                var item = {\n                  value: value,\n                  cost: cost\n                };\n                this.queue.push(item);\n                this.queue.sort(this.sorter);\n              },\n              /**\n               * Return the highest priority element in the queue.\n               */\n              pop: function () {\n                return this.queue.shift();\n              },\n              empty: function () {\n                return this.queue.length === 0;\n              }\n            }\n          };\n\n          // node.js module exports\n          if (typeof module !== 'undefined') {\n            module.exports = dijkstra;\n          }\n        }, {}],\n        32: [function (require, module, exports) {\n          exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n            var e, m;\n            var eLen = nBytes * 8 - mLen - 1;\n            var eMax = (1 << eLen) - 1;\n            var eBias = eMax >> 1;\n            var nBits = -7;\n            var i = isLE ? nBytes - 1 : 0;\n            var d = isLE ? -1 : 1;\n            var s = buffer[offset + i];\n            i += d;\n            e = s & (1 << -nBits) - 1;\n            s >>= -nBits;\n            nBits += eLen;\n            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n            m = e & (1 << -nBits) - 1;\n            e >>= -nBits;\n            nBits += mLen;\n            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n            if (e === 0) {\n              e = 1 - eBias;\n            } else if (e === eMax) {\n              return m ? NaN : (s ? -1 : 1) * Infinity;\n            } else {\n              m = m + Math.pow(2, mLen);\n              e = e - eBias;\n            }\n            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n          };\n          exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n            var e, m, c;\n            var eLen = nBytes * 8 - mLen - 1;\n            var eMax = (1 << eLen) - 1;\n            var eBias = eMax >> 1;\n            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n            var i = isLE ? 0 : nBytes - 1;\n            var d = isLE ? 1 : -1;\n            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n            value = Math.abs(value);\n            if (isNaN(value) || value === Infinity) {\n              m = isNaN(value) ? 1 : 0;\n              e = eMax;\n            } else {\n              e = Math.floor(Math.log(value) / Math.LN2);\n              if (value * (c = Math.pow(2, -e)) < 1) {\n                e--;\n                c *= 2;\n              }\n              if (e + eBias >= 1) {\n                value += rt / c;\n              } else {\n                value += rt * Math.pow(2, 1 - eBias);\n              }\n              if (value * c >= 2) {\n                e++;\n                c /= 2;\n              }\n              if (e + eBias >= eMax) {\n                m = 0;\n                e = eMax;\n              } else if (e + eBias >= 1) {\n                m = (value * c - 1) * Math.pow(2, mLen);\n                e = e + eBias;\n              } else {\n                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n                e = 0;\n              }\n            }\n            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n            e = e << mLen | m;\n            eLen += mLen;\n            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n            buffer[offset + i - d] |= s * 128;\n          };\n        }, {}],\n        33: [function (require, module, exports) {\n          var toString = {}.toString;\n          module.exports = Array.isArray || function (arr) {\n            return toString.call(arr) == '[object Array]';\n          };\n        }, {}]\n      }, {}, [24])(24);\n    });\n  });\n  var index = {\n    name: 'qrcode',\n    props: {\n      /**\n       * The value of the QR code.\n       */\n      value: null,\n      /**\n       * The options for the QR code generator.\n       * {@link https://github.com/soldair/node-qrcode#qr-code-options}\n       */\n      options: Object,\n      /**\n       * The tag name of the component's root element.\n       */\n      tag: {\n        type: String,\n        default: 'canvas'\n      }\n    },\n    render: function render(createElement) {\n      return createElement(this.tag, this.$slots.default);\n    },\n    watch: {\n      $props: {\n        deep: true,\n        immediate: true,\n        /**\n         * Update the QR code when props changed.\n         */\n        handler: function handler() {\n          if (this.$el) {\n            this.generate();\n          }\n        }\n      }\n    },\n    methods: {\n      /**\n       * Generate QR code.\n       */\n      generate: function generate() {\n        var _this = this;\n        var options = this.options,\n          tag = this.tag;\n        var value = String(this.value);\n        if (tag === 'canvas') {\n          qrcode.toCanvas(this.$el, value, options, function (error) {\n            /* istanbul ignore if */\n            if (error) {\n              throw error;\n            }\n          });\n        } else if (tag === 'img') {\n          qrcode.toDataURL(value, options, function (error, url) {\n            /* istanbul ignore if */\n            if (error) {\n              throw error;\n            }\n            _this.$el.src = url;\n          });\n        } else {\n          qrcode.toString(value, options, function (error, string) {\n            /* istanbul ignore if */\n            if (error) {\n              throw error;\n            }\n            _this.$el.innerHTML = string;\n          });\n        }\n      }\n    },\n    mounted: function mounted() {\n      this.generate();\n    }\n  };\n  return index;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNoZW5mZW5neXVhbi92dWUtcXJjb2RlL2Rpc3QvdnVlLXFyY29kZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQTBDQTtBQUNBO0FBQ0E7O0FBMENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFJQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUVBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC8uL25vZGVfbW9kdWxlcy9AY2hlbmZlbmd5dWFuL3Z1ZS1xcmNvZGUvZGlzdC92dWUtcXJjb2RlLmpzPzc5MjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiB2dWUtcXJjb2RlIHYxLjAuMlxuICogaHR0cHM6Ly9mZW5neXVhbmNoZW4uZ2l0aHViLmlvL3Z1ZS1xcmNvZGVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOC1wcmVzZW50IENoZW4gRmVuZ3l1YW5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMjAtMDEtMThUMDY6MDQ6MzMuMjIyWlxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuVnVlUXJjb2RlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdGZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSAoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSByb2xsdXAtcGx1Z2luLWNvbW1vbmpzJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0dmFyIHFyY29kZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0KGZ1bmN0aW9uKGYpe3ttb2R1bGUuZXhwb3J0cz1mKCk7fX0pKGZ1bmN0aW9uKCl7cmV0dXJuIChmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIGNvbW1vbmpzUmVxdWlyZSYmY29tbW9uanNSZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpO31yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBjb21tb25qc1JlcXVpcmUmJmNvbW1vbmpzUmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHQvLyBjYW4tcHJvbWlzZSBoYXMgYSBjcmFzaCBpbiBzb21lIHZlcnNpb25zIG9mIHJlYWN0IG5hdGl2ZSB0aGF0IGRvbnQgaGF2ZVxuXHQvLyBzdGFuZGFyZCBnbG9iYWwgb2JqZWN0c1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vc29sZGFpci9ub2RlLXFyY29kZS9pc3N1ZXMvMTU3XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nICYmIFByb21pc2UucHJvdG90eXBlICYmIFByb21pc2UucHJvdG90eXBlLnRoZW5cblx0fTtcblxuXHR9LHt9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblx0LyoqXG5cdCAqIEFsaWdubWVudCBwYXR0ZXJuIGFyZSBmaXhlZCByZWZlcmVuY2UgcGF0dGVybiBpbiBkZWZpbmVkIHBvc2l0aW9uc1xuXHQgKiBpbiBhIG1hdHJpeCBzeW1ib2xvZ3ksIHdoaWNoIGVuYWJsZXMgdGhlIGRlY29kZSBzb2Z0d2FyZSB0byByZS1zeW5jaHJvbmlzZVxuXHQgKiB0aGUgY29vcmRpbmF0ZSBtYXBwaW5nIG9mIHRoZSBpbWFnZSBtb2R1bGVzIGluIHRoZSBldmVudCBvZiBtb2RlcmF0ZSBhbW91bnRzXG5cdCAqIG9mIGRpc3RvcnRpb24gb2YgdGhlIGltYWdlLlxuXHQgKlxuXHQgKiBBbGlnbm1lbnQgcGF0dGVybnMgYXJlIHByZXNlbnQgb25seSBpbiBRUiBDb2RlIHN5bWJvbHMgb2YgdmVyc2lvbiAyIG9yIGxhcmdlclxuXHQgKiBhbmQgdGhlaXIgbnVtYmVyIGRlcGVuZHMgb24gdGhlIHN5bWJvbCB2ZXJzaW9uLlxuXHQgKi9cblxuXHR2YXIgZ2V0U3ltYm9sU2l6ZSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5nZXRTeW1ib2xTaXplO1xuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlIHJvdy9jb2x1bW4gY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciBtb2R1bGUgb2YgZWFjaCBhbGlnbm1lbnQgcGF0dGVyblxuXHQgKiBmb3IgdGhlIHNwZWNpZmllZCBRUiBDb2RlIHZlcnNpb24uXG5cdCAqXG5cdCAqIFRoZSBhbGlnbm1lbnQgcGF0dGVybnMgYXJlIHBvc2l0aW9uZWQgc3ltbWV0cmljYWxseSBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgZGlhZ29uYWxcblx0ICogcnVubmluZyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHN5bWJvbCB0byB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lci5cblx0ICpcblx0ICogU2luY2UgcG9zaXRpb25zIGFyZSBzaW1tZXRyaWNhbCBvbmx5IGhhbGYgb2YgdGhlIGNvb3JkaW5hdGVzIGFyZSByZXR1cm5lZC5cblx0ICogRWFjaCBpdGVtIG9mIHRoZSBhcnJheSB3aWxsIHJlcHJlc2VudCBpbiB0dXJuIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGUuXG5cdCAqIEBzZWUge0BsaW5rIGdldFBvc2l0aW9uc31cblx0ICpcblx0ICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uIFFSIENvZGUgdmVyc2lvblxuXHQgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgQXJyYXkgb2YgY29vcmRpbmF0ZVxuXHQgKi9cblx0ZXhwb3J0cy5nZXRSb3dDb2xDb29yZHMgPSBmdW5jdGlvbiBnZXRSb3dDb2xDb29yZHMgKHZlcnNpb24pIHtcblx0ICBpZiAodmVyc2lvbiA9PT0gMSkgcmV0dXJuIFtdXG5cblx0ICB2YXIgcG9zQ291bnQgPSBNYXRoLmZsb29yKHZlcnNpb24gLyA3KSArIDI7XG5cdCAgdmFyIHNpemUgPSBnZXRTeW1ib2xTaXplKHZlcnNpb24pO1xuXHQgIHZhciBpbnRlcnZhbHMgPSBzaXplID09PSAxNDUgPyAyNiA6IE1hdGguY2VpbCgoc2l6ZSAtIDEzKSAvICgyICogcG9zQ291bnQgLSAyKSkgKiAyO1xuXHQgIHZhciBwb3NpdGlvbnMgPSBbc2l6ZSAtIDddOyAvLyBMYXN0IGNvb3JkIGlzIGFsd2F5cyAoc2l6ZSAtIDcpXG5cblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IHBvc0NvdW50IC0gMTsgaSsrKSB7XG5cdCAgICBwb3NpdGlvbnNbaV0gPSBwb3NpdGlvbnNbaSAtIDFdIC0gaW50ZXJ2YWxzO1xuXHQgIH1cblxuXHQgIHBvc2l0aW9ucy5wdXNoKDYpOyAvLyBGaXJzdCBjb29yZCBpcyBhbHdheXMgNlxuXG5cdCAgcmV0dXJuIHBvc2l0aW9ucy5yZXZlcnNlKClcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBwb3NpdGlvbnMgb2YgZWFjaCBhbGlnbm1lbnQgcGF0dGVybi5cblx0ICogRWFjaCBhcnJheSdzIGVsZW1lbnQgcmVwcmVzZW50IHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIHBhdHRlcm4gYXMgKHgsIHkpIGNvb3JkaW5hdGVzXG5cdCAqXG5cdCAqIENvb3JkaW5hdGVzIGFyZSBjYWxjdWxhdGVkIGV4cGFuZGluZyB0aGUgcm93L2NvbHVtbiBjb29yZGluYXRlcyByZXR1cm5lZCBieSB7QGxpbmsgZ2V0Um93Q29sQ29vcmRzfVxuXHQgKiBhbmQgZmlsdGVyaW5nIG91dCB0aGUgaXRlbXMgdGhhdCBvdmVybGFwcyB3aXRoIGZpbmRlciBwYXR0ZXJuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIEZvciBhIFZlcnNpb24gNyBzeW1ib2wge0BsaW5rIGdldFJvd0NvbENvb3Jkc30gcmV0dXJucyB2YWx1ZXMgNiwgMjIgYW5kIDM4LlxuXHQgKiBUaGUgYWxpZ25tZW50IHBhdHRlcm5zLCB0aGVyZWZvcmUsIGFyZSB0byBiZSBjZW50ZXJlZCBvbiAocm93LCBjb2x1bW4pXG5cdCAqIHBvc2l0aW9ucyAoNiwyMiksICgyMiw2KSwgKDIyLDIyKSwgKDIyLDM4KSwgKDM4LDIyKSwgKDM4LDM4KS5cblx0ICogTm90ZSB0aGF0IHRoZSBjb29yZGluYXRlcyAoNiw2KSwgKDYsMzgpLCAoMzgsNikgYXJlIG9jY3VwaWVkIGJ5IGZpbmRlciBwYXR0ZXJuc1xuXHQgKiBhbmQgYXJlIG5vdCB0aGVyZWZvcmUgdXNlZCBmb3IgYWxpZ25tZW50IHBhdHRlcm5zLlxuXHQgKlxuXHQgKiB2YXIgcG9zID0gZ2V0UG9zaXRpb25zKDcpXG5cdCAqIC8vIFtbNiwyMl0sIFsyMiw2XSwgWzIyLDIyXSwgWzIyLDM4XSwgWzM4LDIyXSwgWzM4LDM4XV1cblx0ICpcblx0ICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uIFFSIENvZGUgdmVyc2lvblxuXHQgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgQXJyYXkgb2YgY29vcmRpbmF0ZXNcblx0ICovXG5cdGV4cG9ydHMuZ2V0UG9zaXRpb25zID0gZnVuY3Rpb24gZ2V0UG9zaXRpb25zICh2ZXJzaW9uKSB7XG5cdCAgdmFyIGNvb3JkcyA9IFtdO1xuXHQgIHZhciBwb3MgPSBleHBvcnRzLmdldFJvd0NvbENvb3Jkcyh2ZXJzaW9uKTtcblx0ICB2YXIgcG9zTGVuZ3RoID0gcG9zLmxlbmd0aDtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zTGVuZ3RoOyBpKyspIHtcblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9zTGVuZ3RoOyBqKyspIHtcblx0ICAgICAgLy8gU2tpcCBpZiBwb3NpdGlvbiBpcyBvY2N1cGllZCBieSBmaW5kZXIgcGF0dGVybnNcblx0ICAgICAgaWYgKChpID09PSAwICYmIGogPT09IDApIHx8ICAgICAgICAgICAgIC8vIHRvcC1sZWZ0XG5cdCAgICAgICAgICAoaSA9PT0gMCAmJiBqID09PSBwb3NMZW5ndGggLSAxKSB8fCAvLyBib3R0b20tbGVmdFxuXHQgICAgICAgICAgKGkgPT09IHBvc0xlbmd0aCAtIDEgJiYgaiA9PT0gMCkpIHsgLy8gdG9wLXJpZ2h0XG5cdCAgICAgICAgY29udGludWVcblx0ICAgICAgfVxuXG5cdCAgICAgIGNvb3Jkcy5wdXNoKFtwb3NbaV0sIHBvc1tqXV0pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBjb29yZHNcblx0fTtcblxuXHR9LHtcIi4vdXRpbHNcIjoyMX1dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHR2YXIgTW9kZSA9IHJlcXVpcmUoJy4vbW9kZScpO1xuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBjaGFyYWN0ZXJzIGF2YWlsYWJsZSBpbiBhbHBoYW51bWVyaWMgbW9kZVxuXHQgKlxuXHQgKiBBcyBwZXIgUVIgQ29kZSBzcGVjaWZpY2F0aW9uLCB0byBlYWNoIGNoYXJhY3RlclxuXHQgKiBpcyBhc3NpZ25lZCBhIHZhbHVlIGZyb20gMCB0byA0NCB3aGljaCBpbiB0aGlzIGNhc2UgY29pbmNpZGVzXG5cdCAqIHdpdGggdGhlIGFycmF5IGluZGV4XG5cdCAqXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICovXG5cdHZhciBBTFBIQV9OVU1fQ0hBUlMgPSBbXG5cdCAgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLFxuXHQgICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJyxcblx0ICAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsXG5cdCAgJyAnLCAnJCcsICclJywgJyonLCAnKycsICctJywgJy4nLCAnLycsICc6J1xuXHRdO1xuXG5cdGZ1bmN0aW9uIEFscGhhbnVtZXJpY0RhdGEgKGRhdGEpIHtcblx0ICB0aGlzLm1vZGUgPSBNb2RlLkFMUEhBTlVNRVJJQztcblx0ICB0aGlzLmRhdGEgPSBkYXRhO1xuXHR9XG5cblx0QWxwaGFudW1lcmljRGF0YS5nZXRCaXRzTGVuZ3RoID0gZnVuY3Rpb24gZ2V0Qml0c0xlbmd0aCAobGVuZ3RoKSB7XG5cdCAgcmV0dXJuIDExICogTWF0aC5mbG9vcihsZW5ndGggLyAyKSArIDYgKiAobGVuZ3RoICUgMilcblx0fTtcblxuXHRBbHBoYW51bWVyaWNEYXRhLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGggKCkge1xuXHQgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoXG5cdH07XG5cblx0QWxwaGFudW1lcmljRGF0YS5wcm90b3R5cGUuZ2V0Qml0c0xlbmd0aCA9IGZ1bmN0aW9uIGdldEJpdHNMZW5ndGggKCkge1xuXHQgIHJldHVybiBBbHBoYW51bWVyaWNEYXRhLmdldEJpdHNMZW5ndGgodGhpcy5kYXRhLmxlbmd0aClcblx0fTtcblxuXHRBbHBoYW51bWVyaWNEYXRhLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChiaXRCdWZmZXIpIHtcblx0ICB2YXIgaTtcblxuXHQgIC8vIElucHV0IGRhdGEgY2hhcmFjdGVycyBhcmUgZGl2aWRlZCBpbnRvIGdyb3VwcyBvZiB0d28gY2hhcmFjdGVyc1xuXHQgIC8vIGFuZCBlbmNvZGVkIGFzIDExLWJpdCBiaW5hcnkgY29kZXMuXG5cdCAgZm9yIChpID0gMDsgaSArIDIgPD0gdGhpcy5kYXRhLmxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAvLyBUaGUgY2hhcmFjdGVyIHZhbHVlIG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbXVsdGlwbGllZCBieSA0NVxuXHQgICAgdmFyIHZhbHVlID0gQUxQSEFfTlVNX0NIQVJTLmluZGV4T2YodGhpcy5kYXRhW2ldKSAqIDQ1O1xuXG5cdCAgICAvLyBUaGUgY2hhcmFjdGVyIHZhbHVlIG9mIHRoZSBzZWNvbmQgZGlnaXQgaXMgYWRkZWQgdG8gdGhlIHByb2R1Y3Rcblx0ICAgIHZhbHVlICs9IEFMUEhBX05VTV9DSEFSUy5pbmRleE9mKHRoaXMuZGF0YVtpICsgMV0pO1xuXG5cdCAgICAvLyBUaGUgc3VtIGlzIHRoZW4gc3RvcmVkIGFzIDExLWJpdCBiaW5hcnkgbnVtYmVyXG5cdCAgICBiaXRCdWZmZXIucHV0KHZhbHVlLCAxMSk7XG5cdCAgfVxuXG5cdCAgLy8gSWYgdGhlIG51bWJlciBvZiBpbnB1dCBkYXRhIGNoYXJhY3RlcnMgaXMgbm90IGEgbXVsdGlwbGUgb2YgdHdvLFxuXHQgIC8vIHRoZSBjaGFyYWN0ZXIgdmFsdWUgb2YgdGhlIGZpbmFsIGNoYXJhY3RlciBpcyBlbmNvZGVkIGFzIGEgNi1iaXQgYmluYXJ5IG51bWJlci5cblx0ICBpZiAodGhpcy5kYXRhLmxlbmd0aCAlIDIpIHtcblx0ICAgIGJpdEJ1ZmZlci5wdXQoQUxQSEFfTlVNX0NIQVJTLmluZGV4T2YodGhpcy5kYXRhW2ldKSwgNik7XG5cdCAgfVxuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQWxwaGFudW1lcmljRGF0YTtcblxuXHR9LHtcIi4vbW9kZVwiOjE0fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cdGZ1bmN0aW9uIEJpdEJ1ZmZlciAoKSB7XG5cdCAgdGhpcy5idWZmZXIgPSBbXTtcblx0ICB0aGlzLmxlbmd0aCA9IDA7XG5cdH1cblxuXHRCaXRCdWZmZXIucHJvdG90eXBlID0ge1xuXG5cdCAgZ2V0OiBmdW5jdGlvbiAoaW5kZXgpIHtcblx0ICAgIHZhciBidWZJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyA4KTtcblx0ICAgIHJldHVybiAoKHRoaXMuYnVmZmVyW2J1ZkluZGV4XSA+Pj4gKDcgLSBpbmRleCAlIDgpKSAmIDEpID09PSAxXG5cdCAgfSxcblxuXHQgIHB1dDogZnVuY3Rpb24gKG51bSwgbGVuZ3RoKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMucHV0Qml0KCgobnVtID4+PiAobGVuZ3RoIC0gaSAtIDEpKSAmIDEpID09PSAxKTtcblx0ICAgIH1cblx0ICB9LFxuXG5cdCAgZ2V0TGVuZ3RoSW5CaXRzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5sZW5ndGhcblx0ICB9LFxuXG5cdCAgcHV0Qml0OiBmdW5jdGlvbiAoYml0KSB7XG5cdCAgICB2YXIgYnVmSW5kZXggPSBNYXRoLmZsb29yKHRoaXMubGVuZ3RoIC8gOCk7XG5cdCAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoIDw9IGJ1ZkluZGV4KSB7XG5cdCAgICAgIHRoaXMuYnVmZmVyLnB1c2goMCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChiaXQpIHtcblx0ICAgICAgdGhpcy5idWZmZXJbYnVmSW5kZXhdIHw9ICgweDgwID4+PiAodGhpcy5sZW5ndGggJSA4KSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoKys7XG5cdCAgfVxuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQml0QnVmZmVyO1xuXG5cdH0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHR2YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWxzL2J1ZmZlcicpO1xuXG5cdC8qKlxuXHQgKiBIZWxwZXIgY2xhc3MgdG8gaGFuZGxlIFFSIENvZGUgc3ltYm9sIG1vZHVsZXNcblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgU3ltYm9sIHNpemVcblx0ICovXG5cdGZ1bmN0aW9uIEJpdE1hdHJpeCAoc2l6ZSkge1xuXHQgIGlmICghc2l6ZSB8fCBzaXplIDwgMSkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdCaXRNYXRyaXggc2l6ZSBtdXN0IGJlIGRlZmluZWQgYW5kIGdyZWF0ZXIgdGhhbiAwJylcblx0ICB9XG5cblx0ICB0aGlzLnNpemUgPSBzaXplO1xuXHQgIHRoaXMuZGF0YSA9IEJ1ZmZlclV0aWwuYWxsb2Moc2l6ZSAqIHNpemUpO1xuXHQgIHRoaXMucmVzZXJ2ZWRCaXQgPSBCdWZmZXJVdGlsLmFsbG9jKHNpemUgKiBzaXplKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgYml0IHZhbHVlIGF0IHNwZWNpZmllZCBsb2NhdGlvblxuXHQgKiBJZiByZXNlcnZlZCBmbGFnIGlzIHNldCwgdGhpcyBiaXQgd2lsbCBiZSBpZ25vcmVkIGR1cmluZyBtYXNraW5nIHByb2Nlc3Ncblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9ICByb3dcblx0ICogQHBhcmFtIHtOdW1iZXJ9ICBjb2xcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlc2VydmVkXG5cdCAqL1xuXHRCaXRNYXRyaXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChyb3csIGNvbCwgdmFsdWUsIHJlc2VydmVkKSB7XG5cdCAgdmFyIGluZGV4ID0gcm93ICogdGhpcy5zaXplICsgY29sO1xuXHQgIHRoaXMuZGF0YVtpbmRleF0gPSB2YWx1ZTtcblx0ICBpZiAocmVzZXJ2ZWQpIHRoaXMucmVzZXJ2ZWRCaXRbaW5kZXhdID0gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBiaXQgdmFsdWUgYXQgc3BlY2lmaWVkIGxvY2F0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSAge051bWJlcn0gIHJvd1xuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9ICBjb2xcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdEJpdE1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XG5cdCAgcmV0dXJuIHRoaXMuZGF0YVtyb3cgKiB0aGlzLnNpemUgKyBjb2xdXG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgeG9yIG9wZXJhdG9yIGF0IHNwZWNpZmllZCBsb2NhdGlvblxuXHQgKiAodXNlZCBkdXJpbmcgbWFza2luZyBwcm9jZXNzKVxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gIHJvd1xuXHQgKiBAcGFyYW0ge051bWJlcn0gIGNvbFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqL1xuXHRCaXRNYXRyaXgucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChyb3csIGNvbCwgdmFsdWUpIHtcblx0ICB0aGlzLmRhdGFbcm93ICogdGhpcy5zaXplICsgY29sXSBePSB2YWx1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgYml0IGF0IHNwZWNpZmllZCBsb2NhdGlvbiBpcyByZXNlcnZlZFxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gICByb3dcblx0ICogQHBhcmFtIHtOdW1iZXJ9ICAgY29sXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRCaXRNYXRyaXgucHJvdG90eXBlLmlzUmVzZXJ2ZWQgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcblx0ICByZXR1cm4gdGhpcy5yZXNlcnZlZEJpdFtyb3cgKiB0aGlzLnNpemUgKyBjb2xdXG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBCaXRNYXRyaXg7XG5cblx0fSx7XCIuLi91dGlscy9idWZmZXJcIjoyOH1dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHR2YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWxzL2J1ZmZlcicpO1xuXHR2YXIgTW9kZSA9IHJlcXVpcmUoJy4vbW9kZScpO1xuXG5cdGZ1bmN0aW9uIEJ5dGVEYXRhIChkYXRhKSB7XG5cdCAgdGhpcy5tb2RlID0gTW9kZS5CWVRFO1xuXHQgIHRoaXMuZGF0YSA9IEJ1ZmZlclV0aWwuZnJvbShkYXRhKTtcblx0fVxuXG5cdEJ5dGVEYXRhLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoIChsZW5ndGgpIHtcblx0ICByZXR1cm4gbGVuZ3RoICogOFxuXHR9O1xuXG5cdEJ5dGVEYXRhLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGggKCkge1xuXHQgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoXG5cdH07XG5cblx0Qnl0ZURhdGEucHJvdG90eXBlLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoICgpIHtcblx0ICByZXR1cm4gQnl0ZURhdGEuZ2V0Qml0c0xlbmd0aCh0aGlzLmRhdGEubGVuZ3RoKVxuXHR9O1xuXG5cdEJ5dGVEYXRhLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChiaXRCdWZmZXIpIHtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgIGJpdEJ1ZmZlci5wdXQodGhpcy5kYXRhW2ldLCA4KTtcblx0ICB9XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBCeXRlRGF0YTtcblxuXHR9LHtcIi4uL3V0aWxzL2J1ZmZlclwiOjI4LFwiLi9tb2RlXCI6MTR9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblx0dmFyIEVDTGV2ZWwgPSByZXF1aXJlKCcuL2Vycm9yLWNvcnJlY3Rpb24tbGV2ZWwnKTtcclxuXHJcblx0dmFyIEVDX0JMT0NLU19UQUJMRSA9IFtcclxuXHQvLyBMICBNICBRICBIXHJcblx0ICAxLCAxLCAxLCAxLFxyXG5cdCAgMSwgMSwgMSwgMSxcclxuXHQgIDEsIDEsIDIsIDIsXHJcblx0ICAxLCAyLCAyLCA0LFxyXG5cdCAgMSwgMiwgNCwgNCxcclxuXHQgIDIsIDQsIDQsIDQsXHJcblx0ICAyLCA0LCA2LCA1LFxyXG5cdCAgMiwgNCwgNiwgNixcclxuXHQgIDIsIDUsIDgsIDgsXHJcblx0ICA0LCA1LCA4LCA4LFxyXG5cdCAgNCwgNSwgOCwgMTEsXHJcblx0ICA0LCA4LCAxMCwgMTEsXHJcblx0ICA0LCA5LCAxMiwgMTYsXHJcblx0ICA0LCA5LCAxNiwgMTYsXHJcblx0ICA2LCAxMCwgMTIsIDE4LFxyXG5cdCAgNiwgMTAsIDE3LCAxNixcclxuXHQgIDYsIDExLCAxNiwgMTksXHJcblx0ICA2LCAxMywgMTgsIDIxLFxyXG5cdCAgNywgMTQsIDIxLCAyNSxcclxuXHQgIDgsIDE2LCAyMCwgMjUsXHJcblx0ICA4LCAxNywgMjMsIDI1LFxyXG5cdCAgOSwgMTcsIDIzLCAzNCxcclxuXHQgIDksIDE4LCAyNSwgMzAsXHJcblx0ICAxMCwgMjAsIDI3LCAzMixcclxuXHQgIDEyLCAyMSwgMjksIDM1LFxyXG5cdCAgMTIsIDIzLCAzNCwgMzcsXHJcblx0ICAxMiwgMjUsIDM0LCA0MCxcclxuXHQgIDEzLCAyNiwgMzUsIDQyLFxyXG5cdCAgMTQsIDI4LCAzOCwgNDUsXHJcblx0ICAxNSwgMjksIDQwLCA0OCxcclxuXHQgIDE2LCAzMSwgNDMsIDUxLFxyXG5cdCAgMTcsIDMzLCA0NSwgNTQsXHJcblx0ICAxOCwgMzUsIDQ4LCA1NyxcclxuXHQgIDE5LCAzNywgNTEsIDYwLFxyXG5cdCAgMTksIDM4LCA1MywgNjMsXHJcblx0ICAyMCwgNDAsIDU2LCA2NixcclxuXHQgIDIxLCA0MywgNTksIDcwLFxyXG5cdCAgMjIsIDQ1LCA2MiwgNzQsXHJcblx0ICAyNCwgNDcsIDY1LCA3NyxcclxuXHQgIDI1LCA0OSwgNjgsIDgxXHJcblx0XTtcclxuXHJcblx0dmFyIEVDX0NPREVXT1JEU19UQUJMRSA9IFtcclxuXHQvLyBMICBNICBRICBIXHJcblx0ICA3LCAxMCwgMTMsIDE3LFxyXG5cdCAgMTAsIDE2LCAyMiwgMjgsXHJcblx0ICAxNSwgMjYsIDM2LCA0NCxcclxuXHQgIDIwLCAzNiwgNTIsIDY0LFxyXG5cdCAgMjYsIDQ4LCA3MiwgODgsXHJcblx0ICAzNiwgNjQsIDk2LCAxMTIsXHJcblx0ICA0MCwgNzIsIDEwOCwgMTMwLFxyXG5cdCAgNDgsIDg4LCAxMzIsIDE1NixcclxuXHQgIDYwLCAxMTAsIDE2MCwgMTkyLFxyXG5cdCAgNzIsIDEzMCwgMTkyLCAyMjQsXHJcblx0ICA4MCwgMTUwLCAyMjQsIDI2NCxcclxuXHQgIDk2LCAxNzYsIDI2MCwgMzA4LFxyXG5cdCAgMTA0LCAxOTgsIDI4OCwgMzUyLFxyXG5cdCAgMTIwLCAyMTYsIDMyMCwgMzg0LFxyXG5cdCAgMTMyLCAyNDAsIDM2MCwgNDMyLFxyXG5cdCAgMTQ0LCAyODAsIDQwOCwgNDgwLFxyXG5cdCAgMTY4LCAzMDgsIDQ0OCwgNTMyLFxyXG5cdCAgMTgwLCAzMzgsIDUwNCwgNTg4LFxyXG5cdCAgMTk2LCAzNjQsIDU0NiwgNjUwLFxyXG5cdCAgMjI0LCA0MTYsIDYwMCwgNzAwLFxyXG5cdCAgMjI0LCA0NDIsIDY0NCwgNzUwLFxyXG5cdCAgMjUyLCA0NzYsIDY5MCwgODE2LFxyXG5cdCAgMjcwLCA1MDQsIDc1MCwgOTAwLFxyXG5cdCAgMzAwLCA1NjAsIDgxMCwgOTYwLFxyXG5cdCAgMzEyLCA1ODgsIDg3MCwgMTA1MCxcclxuXHQgIDMzNiwgNjQ0LCA5NTIsIDExMTAsXHJcblx0ICAzNjAsIDcwMCwgMTAyMCwgMTIwMCxcclxuXHQgIDM5MCwgNzI4LCAxMDUwLCAxMjYwLFxyXG5cdCAgNDIwLCA3ODQsIDExNDAsIDEzNTAsXHJcblx0ICA0NTAsIDgxMiwgMTIwMCwgMTQ0MCxcclxuXHQgIDQ4MCwgODY4LCAxMjkwLCAxNTMwLFxyXG5cdCAgNTEwLCA5MjQsIDEzNTAsIDE2MjAsXHJcblx0ICA1NDAsIDk4MCwgMTQ0MCwgMTcxMCxcclxuXHQgIDU3MCwgMTAzNiwgMTUzMCwgMTgwMCxcclxuXHQgIDU3MCwgMTA2NCwgMTU5MCwgMTg5MCxcclxuXHQgIDYwMCwgMTEyMCwgMTY4MCwgMTk4MCxcclxuXHQgIDYzMCwgMTIwNCwgMTc3MCwgMjEwMCxcclxuXHQgIDY2MCwgMTI2MCwgMTg2MCwgMjIyMCxcclxuXHQgIDcyMCwgMTMxNiwgMTk1MCwgMjMxMCxcclxuXHQgIDc1MCwgMTM3MiwgMjA0MCwgMjQzMFxyXG5cdF07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGJsb2NrIHRoYXQgdGhlIFFSIENvZGUgc2hvdWxkIGNvbnRhaW5cclxuXHQgKiBmb3IgdGhlIHNwZWNpZmllZCB2ZXJzaW9uIGFuZCBlcnJvciBjb3JyZWN0aW9uIGxldmVsLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uICAgICAgICAgICAgICBRUiBDb2RlIHZlcnNpb25cclxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IGVycm9yQ29ycmVjdGlvbkxldmVsIEVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgIE51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGJsb2Nrc1xyXG5cdCAqL1xyXG5cdGV4cG9ydHMuZ2V0QmxvY2tzQ291bnQgPSBmdW5jdGlvbiBnZXRCbG9ja3NDb3VudCAodmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcclxuXHQgIHN3aXRjaCAoZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcclxuXHQgICAgY2FzZSBFQ0xldmVsLkw6XHJcblx0ICAgICAgcmV0dXJuIEVDX0JMT0NLU19UQUJMRVsodmVyc2lvbiAtIDEpICogNCArIDBdXHJcblx0ICAgIGNhc2UgRUNMZXZlbC5NOlxyXG5cdCAgICAgIHJldHVybiBFQ19CTE9DS1NfVEFCTEVbKHZlcnNpb24gLSAxKSAqIDQgKyAxXVxyXG5cdCAgICBjYXNlIEVDTGV2ZWwuUTpcclxuXHQgICAgICByZXR1cm4gRUNfQkxPQ0tTX1RBQkxFWyh2ZXJzaW9uIC0gMSkgKiA0ICsgMl1cclxuXHQgICAgY2FzZSBFQ0xldmVsLkg6XHJcblx0ICAgICAgcmV0dXJuIEVDX0JMT0NLU19UQUJMRVsodmVyc2lvbiAtIDEpICogNCArIDNdXHJcblx0ICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgcmV0dXJuIHVuZGVmaW5lZFxyXG5cdCAgfVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3JkcyB0byB1c2UgZm9yIHRoZSBzcGVjaWZpZWRcclxuXHQgKiB2ZXJzaW9uIGFuZCBlcnJvciBjb3JyZWN0aW9uIGxldmVsLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uICAgICAgICAgICAgICBRUiBDb2RlIHZlcnNpb25cclxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IGVycm9yQ29ycmVjdGlvbkxldmVsIEVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgIE51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xyXG5cdCAqL1xyXG5cdGV4cG9ydHMuZ2V0VG90YWxDb2Rld29yZHNDb3VudCA9IGZ1bmN0aW9uIGdldFRvdGFsQ29kZXdvcmRzQ291bnQgKHZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XHJcblx0ICBzd2l0Y2ggKGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XHJcblx0ICAgIGNhc2UgRUNMZXZlbC5MOlxyXG5cdCAgICAgIHJldHVybiBFQ19DT0RFV09SRFNfVEFCTEVbKHZlcnNpb24gLSAxKSAqIDQgKyAwXVxyXG5cdCAgICBjYXNlIEVDTGV2ZWwuTTpcclxuXHQgICAgICByZXR1cm4gRUNfQ09ERVdPUkRTX1RBQkxFWyh2ZXJzaW9uIC0gMSkgKiA0ICsgMV1cclxuXHQgICAgY2FzZSBFQ0xldmVsLlE6XHJcblx0ICAgICAgcmV0dXJuIEVDX0NPREVXT1JEU19UQUJMRVsodmVyc2lvbiAtIDEpICogNCArIDJdXHJcblx0ICAgIGNhc2UgRUNMZXZlbC5IOlxyXG5cdCAgICAgIHJldHVybiBFQ19DT0RFV09SRFNfVEFCTEVbKHZlcnNpb24gLSAxKSAqIDQgKyAzXVxyXG5cdCAgICBkZWZhdWx0OlxyXG5cdCAgICAgIHJldHVybiB1bmRlZmluZWRcclxuXHQgIH1cclxuXHR9O1xyXG5cblx0fSx7XCIuL2Vycm9yLWNvcnJlY3Rpb24tbGV2ZWxcIjo4fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cdGV4cG9ydHMuTCA9IHsgYml0OiAxIH07XG5cdGV4cG9ydHMuTSA9IHsgYml0OiAwIH07XG5cdGV4cG9ydHMuUSA9IHsgYml0OiAzIH07XG5cdGV4cG9ydHMuSCA9IHsgYml0OiAyIH07XG5cblx0ZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nKSB7XG5cdCAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtIGlzIG5vdCBhIHN0cmluZycpXG5cdCAgfVxuXG5cdCAgdmFyIGxjU3RyID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG5cblx0ICBzd2l0Y2ggKGxjU3RyKSB7XG5cdCAgICBjYXNlICdsJzpcblx0ICAgIGNhc2UgJ2xvdyc6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLkxcblxuXHQgICAgY2FzZSAnbSc6XG5cdCAgICBjYXNlICdtZWRpdW0nOlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5NXG5cblx0ICAgIGNhc2UgJ3EnOlxuXHQgICAgY2FzZSAncXVhcnRpbGUnOlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5RXG5cblx0ICAgIGNhc2UgJ2gnOlxuXHQgICAgY2FzZSAnaGlnaCc6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLkhcblxuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIEVDIExldmVsOiAnICsgc3RyaW5nKVxuXHQgIH1cblx0fVxuXG5cdGV4cG9ydHMuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQgKGxldmVsKSB7XG5cdCAgcmV0dXJuIGxldmVsICYmIHR5cGVvZiBsZXZlbC5iaXQgIT09ICd1bmRlZmluZWQnICYmXG5cdCAgICBsZXZlbC5iaXQgPj0gMCAmJiBsZXZlbC5iaXQgPCA0XG5cdH07XG5cblx0ZXhwb3J0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHQgIGlmIChleHBvcnRzLmlzVmFsaWQodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gdmFsdWVcblx0ICB9XG5cblx0ICB0cnkge1xuXHQgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUpXG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuXHQgIH1cblx0fTtcblxuXHR9LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblx0dmFyIGdldFN5bWJvbFNpemUgPSByZXF1aXJlKCcuL3V0aWxzJykuZ2V0U3ltYm9sU2l6ZTtcblx0dmFyIEZJTkRFUl9QQVRURVJOX1NJWkUgPSA3O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9ucyBvZiBlYWNoIGZpbmRlciBwYXR0ZXJuLlxuXHQgKiBFYWNoIGFycmF5J3MgZWxlbWVudCByZXByZXNlbnQgdGhlIHRvcC1sZWZ0IHBvaW50IG9mIHRoZSBwYXR0ZXJuIGFzICh4LCB5KSBjb29yZGluYXRlc1xuXHQgKlxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHZlcnNpb24gUVIgQ29kZSB2ZXJzaW9uXG5cdCAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBBcnJheSBvZiBjb29yZGluYXRlc1xuXHQgKi9cblx0ZXhwb3J0cy5nZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiBnZXRQb3NpdGlvbnMgKHZlcnNpb24pIHtcblx0ICB2YXIgc2l6ZSA9IGdldFN5bWJvbFNpemUodmVyc2lvbik7XG5cblx0ICByZXR1cm4gW1xuXHQgICAgLy8gdG9wLWxlZnRcblx0ICAgIFswLCAwXSxcblx0ICAgIC8vIHRvcC1yaWdodFxuXHQgICAgW3NpemUgLSBGSU5ERVJfUEFUVEVSTl9TSVpFLCAwXSxcblx0ICAgIC8vIGJvdHRvbS1sZWZ0XG5cdCAgICBbMCwgc2l6ZSAtIEZJTkRFUl9QQVRURVJOX1NJWkVdXG5cdCAgXVxuXHR9O1xuXG5cdH0se1wiLi91dGlsc1wiOjIxfV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHR2YXIgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblx0dmFyIEcxNSA9ICgxIDw8IDEwKSB8ICgxIDw8IDgpIHwgKDEgPDwgNSkgfCAoMSA8PCA0KSB8ICgxIDw8IDIpIHwgKDEgPDwgMSkgfCAoMSA8PCAwKTtcblx0dmFyIEcxNV9NQVNLID0gKDEgPDwgMTQpIHwgKDEgPDwgMTIpIHwgKDEgPDwgMTApIHwgKDEgPDwgNCkgfCAoMSA8PCAxKTtcblx0dmFyIEcxNV9CQ0ggPSBVdGlscy5nZXRCQ0hEaWdpdChHMTUpO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGZvcm1hdCBpbmZvcm1hdGlvbiB3aXRoIHJlbGF0aXZlIGVycm9yIGNvcnJlY3Rpb24gYml0c1xuXHQgKlxuXHQgKiBUaGUgZm9ybWF0IGluZm9ybWF0aW9uIGlzIGEgMTUtYml0IHNlcXVlbmNlIGNvbnRhaW5pbmcgNSBkYXRhIGJpdHMsXG5cdCAqIHdpdGggMTAgZXJyb3IgY29ycmVjdGlvbiBiaXRzIGNhbGN1bGF0ZWQgdXNpbmcgdGhlICgxNSwgNSkgQkNIIGNvZGUuXG5cdCAqXG5cdCAqIEBwYXJhbSAge051bWJlcn0gZXJyb3JDb3JyZWN0aW9uTGV2ZWwgRXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc2sgICAgICAgICAgICAgICAgIE1hc2sgcGF0dGVyblxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgIEVuY29kZWQgZm9ybWF0IGluZm9ybWF0aW9uIGJpdHNcblx0ICovXG5cdGV4cG9ydHMuZ2V0RW5jb2RlZEJpdHMgPSBmdW5jdGlvbiBnZXRFbmNvZGVkQml0cyAoZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIG1hc2spIHtcblx0ICB2YXIgZGF0YSA9ICgoZXJyb3JDb3JyZWN0aW9uTGV2ZWwuYml0IDw8IDMpIHwgbWFzayk7XG5cdCAgdmFyIGQgPSBkYXRhIDw8IDEwO1xuXG5cdCAgd2hpbGUgKFV0aWxzLmdldEJDSERpZ2l0KGQpIC0gRzE1X0JDSCA+PSAwKSB7XG5cdCAgICBkIF49IChHMTUgPDwgKFV0aWxzLmdldEJDSERpZ2l0KGQpIC0gRzE1X0JDSCkpO1xuXHQgIH1cblxuXHQgIC8vIHhvciBmaW5hbCBkYXRhIHdpdGggbWFzayBwYXR0ZXJuIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0XG5cdCAgLy8gbm8gY29tYmluYXRpb24gb2YgRXJyb3IgQ29ycmVjdGlvbiBMZXZlbCBhbmQgZGF0YSBtYXNrIHBhdHRlcm5cblx0ICAvLyB3aWxsIHJlc3VsdCBpbiBhbiBhbGwtemVybyBkYXRhIHN0cmluZ1xuXHQgIHJldHVybiAoKGRhdGEgPDwgMTApIHwgZCkgXiBHMTVfTUFTS1xuXHR9O1xuXG5cdH0se1wiLi91dGlsc1wiOjIxfV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHR2YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWxzL2J1ZmZlcicpO1xuXG5cdHZhciBFWFBfVEFCTEUgPSBCdWZmZXJVdGlsLmFsbG9jKDUxMik7XG5cdHZhciBMT0dfVEFCTEUgPSBCdWZmZXJVdGlsLmFsbG9jKDI1Nilcblx0LyoqXG5cdCAqIFByZWNvbXB1dGUgdGhlIGxvZyBhbmQgYW50aS1sb2cgdGFibGVzIGZvciBmYXN0ZXIgY29tcHV0YXRpb24gbGF0ZXJcblx0ICpcblx0ICogRm9yIGVhY2ggcG9zc2libGUgdmFsdWUgaW4gdGhlIGdhbG9pcyBmaWVsZCAyXjgsIHdlIHdpbGwgcHJlLWNvbXB1dGVcblx0ICogdGhlIGxvZ2FyaXRobSBhbmQgYW50aS1sb2dhcml0aG0gKGV4cG9uZW50aWFsKSBvZiB0aGlzIHZhbHVlXG5cdCAqXG5cdCAqIHJlZiB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpdmVyc2l0eS5vcmcvd2lraS9SZWVkJUUyJTgwJTkzU29sb21vbl9jb2Rlc19mb3JfY29kZXJzI0ludHJvZHVjdGlvbl90b19tYXRoZW1hdGljYWxfZmllbGRzfVxuXHQgKi9cblx0OyhmdW5jdGlvbiBpbml0VGFibGVzICgpIHtcblx0ICB2YXIgeCA9IDE7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTU7IGkrKykge1xuXHQgICAgRVhQX1RBQkxFW2ldID0geDtcblx0ICAgIExPR19UQUJMRVt4XSA9IGk7XG5cblx0ICAgIHggPDw9IDE7IC8vIG11bHRpcGx5IGJ5IDJcblxuXHQgICAgLy8gVGhlIFFSIGNvZGUgc3BlY2lmaWNhdGlvbiBzYXlzIHRvIHVzZSBieXRlLXdpc2UgbW9kdWxvIDEwMDAxMTEwMSBhcml0aG1ldGljLlxuXHQgICAgLy8gVGhpcyBtZWFucyB0aGF0IHdoZW4gYSBudW1iZXIgaXMgMjU2IG9yIGxhcmdlciwgaXQgc2hvdWxkIGJlIFhPUmVkIHdpdGggMHgxMUQuXG5cdCAgICBpZiAoeCAmIDB4MTAwKSB7IC8vIHNpbWlsYXIgdG8geCA+PSAyNTYsIGJ1dCBhIGxvdCBmYXN0ZXIgKGJlY2F1c2UgMHgxMDAgPT0gMjU2KVxuXHQgICAgICB4IF49IDB4MTFEO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIE9wdGltaXphdGlvbjogZG91YmxlIHRoZSBzaXplIG9mIHRoZSBhbnRpLWxvZyB0YWJsZSBzbyB0aGF0IHdlIGRvbid0IG5lZWQgdG8gbW9kIDI1NSB0b1xuXHQgIC8vIHN0YXkgaW5zaWRlIHRoZSBib3VuZHMgKGJlY2F1c2Ugd2Ugd2lsbCBtYWlubHkgdXNlIHRoaXMgdGFibGUgZm9yIHRoZSBtdWx0aXBsaWNhdGlvbiBvZlxuXHQgIC8vIHR3byBHRiBudW1iZXJzLCBubyBtb3JlKS5cblx0ICAvLyBAc2VlIHtAbGluayBtdWx9XG5cdCAgZm9yIChpID0gMjU1OyBpIDwgNTEyOyBpKyspIHtcblx0ICAgIEVYUF9UQUJMRVtpXSA9IEVYUF9UQUJMRVtpIC0gMjU1XTtcblx0ICB9XG5cdH0oKSk7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgbG9nIHZhbHVlIG9mIG4gaW5zaWRlIEdhbG9pcyBGaWVsZFxuXHQgKlxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IG5cblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKi9cblx0ZXhwb3J0cy5sb2cgPSBmdW5jdGlvbiBsb2cgKG4pIHtcblx0ICBpZiAobiA8IDEpIHRocm93IG5ldyBFcnJvcignbG9nKCcgKyBuICsgJyknKVxuXHQgIHJldHVybiBMT0dfVEFCTEVbbl1cblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbnRpLWxvZyB2YWx1ZSBvZiBuIGluc2lkZSBHYWxvaXMgRmllbGRcblx0ICpcblx0ICogQHBhcmFtICB7TnVtYmVyfSBuXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICovXG5cdGV4cG9ydHMuZXhwID0gZnVuY3Rpb24gZXhwIChuKSB7XG5cdCAgcmV0dXJuIEVYUF9UQUJMRVtuXVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIHR3byBudW1iZXIgaW5zaWRlIEdhbG9pcyBGaWVsZFxuXHQgKlxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtICB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICovXG5cdGV4cG9ydHMubXVsID0gZnVuY3Rpb24gbXVsICh4LCB5KSB7XG5cdCAgaWYgKHggPT09IDAgfHwgeSA9PT0gMCkgcmV0dXJuIDBcblxuXHQgIC8vIHNob3VsZCBiZSBFWFBfVEFCTEVbKExPR19UQUJMRVt4XSArIExPR19UQUJMRVt5XSkgJSAyNTVdIGlmIEVYUF9UQUJMRSB3YXNuJ3Qgb3ZlcnNpemVkXG5cdCAgLy8gQHNlZSB7QGxpbmsgaW5pdFRhYmxlc31cblx0ICByZXR1cm4gRVhQX1RBQkxFW0xPR19UQUJMRVt4XSArIExPR19UQUJMRVt5XV1cblx0fTtcblxuXHR9LHtcIi4uL3V0aWxzL2J1ZmZlclwiOjI4fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHR2YXIgTW9kZSA9IHJlcXVpcmUoJy4vbW9kZScpO1xuXHR2YXIgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblx0ZnVuY3Rpb24gS2FuamlEYXRhIChkYXRhKSB7XG5cdCAgdGhpcy5tb2RlID0gTW9kZS5LQU5KSTtcblx0ICB0aGlzLmRhdGEgPSBkYXRhO1xuXHR9XG5cblx0S2FuamlEYXRhLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoIChsZW5ndGgpIHtcblx0ICByZXR1cm4gbGVuZ3RoICogMTNcblx0fTtcblxuXHRLYW5qaURhdGEucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCAoKSB7XG5cdCAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGhcblx0fTtcblxuXHRLYW5qaURhdGEucHJvdG90eXBlLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoICgpIHtcblx0ICByZXR1cm4gS2FuamlEYXRhLmdldEJpdHNMZW5ndGgodGhpcy5kYXRhLmxlbmd0aClcblx0fTtcblxuXHRLYW5qaURhdGEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJpdEJ1ZmZlcikge1xuXHQgIHZhciBpO1xuXG5cdCAgLy8gSW4gdGhlIFNoaWZ0IEpJUyBzeXN0ZW0sIEthbmppIGNoYXJhY3RlcnMgYXJlIHJlcHJlc2VudGVkIGJ5IGEgdHdvIGJ5dGUgY29tYmluYXRpb24uXG5cdCAgLy8gVGhlc2UgYnl0ZSB2YWx1ZXMgYXJlIHNoaWZ0ZWQgZnJvbSB0aGUgSklTIFggMDIwOCB2YWx1ZXMuXG5cdCAgLy8gSklTIFggMDIwOCBnaXZlcyBkZXRhaWxzIG9mIHRoZSBzaGlmdCBjb2RlZCByZXByZXNlbnRhdGlvbi5cblx0ICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgdmFsdWUgPSBVdGlscy50b1NKSVModGhpcy5kYXRhW2ldKTtcblxuXHQgICAgLy8gRm9yIGNoYXJhY3RlcnMgd2l0aCBTaGlmdCBKSVMgdmFsdWVzIGZyb20gMHg4MTQwIHRvIDB4OUZGQzpcblx0ICAgIGlmICh2YWx1ZSA+PSAweDgxNDAgJiYgdmFsdWUgPD0gMHg5RkZDKSB7XG5cdCAgICAgIC8vIFN1YnRyYWN0IDB4ODE0MCBmcm9tIFNoaWZ0IEpJUyB2YWx1ZVxuXHQgICAgICB2YWx1ZSAtPSAweDgxNDA7XG5cblx0ICAgIC8vIEZvciBjaGFyYWN0ZXJzIHdpdGggU2hpZnQgSklTIHZhbHVlcyBmcm9tIDB4RTA0MCB0byAweEVCQkZcblx0ICAgIH0gZWxzZSBpZiAodmFsdWUgPj0gMHhFMDQwICYmIHZhbHVlIDw9IDB4RUJCRikge1xuXHQgICAgICAvLyBTdWJ0cmFjdCAweEMxNDAgZnJvbSBTaGlmdCBKSVMgdmFsdWVcblx0ICAgICAgdmFsdWUgLT0gMHhDMTQwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKFxuXHQgICAgICAgICdJbnZhbGlkIFNKSVMgY2hhcmFjdGVyOiAnICsgdGhpcy5kYXRhW2ldICsgJ1xcbicgK1xuXHQgICAgICAgICdNYWtlIHN1cmUgeW91ciBjaGFyc2V0IGlzIFVURi04Jylcblx0ICAgIH1cblxuXHQgICAgLy8gTXVsdGlwbHkgbW9zdCBzaWduaWZpY2FudCBieXRlIG9mIHJlc3VsdCBieSAweEMwXG5cdCAgICAvLyBhbmQgYWRkIGxlYXN0IHNpZ25pZmljYW50IGJ5dGUgdG8gcHJvZHVjdFxuXHQgICAgdmFsdWUgPSAoKCh2YWx1ZSA+Pj4gOCkgJiAweGZmKSAqIDB4QzApICsgKHZhbHVlICYgMHhmZik7XG5cblx0ICAgIC8vIENvbnZlcnQgcmVzdWx0IHRvIGEgMTMtYml0IGJpbmFyeSBzdHJpbmdcblx0ICAgIGJpdEJ1ZmZlci5wdXQodmFsdWUsIDEzKTtcblx0ICB9XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBLYW5qaURhdGE7XG5cblx0fSx7XCIuL21vZGVcIjoxNCxcIi4vdXRpbHNcIjoyMX1dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblx0LyoqXG5cdCAqIERhdGEgbWFzayBwYXR0ZXJuIHJlZmVyZW5jZVxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0ZXhwb3J0cy5QYXR0ZXJucyA9IHtcblx0ICBQQVRURVJOMDAwOiAwLFxuXHQgIFBBVFRFUk4wMDE6IDEsXG5cdCAgUEFUVEVSTjAxMDogMixcblx0ICBQQVRURVJOMDExOiAzLFxuXHQgIFBBVFRFUk4xMDA6IDQsXG5cdCAgUEFUVEVSTjEwMTogNSxcblx0ICBQQVRURVJOMTEwOiA2LFxuXHQgIFBBVFRFUk4xMTE6IDdcblx0fTtcblxuXHQvKipcblx0ICogV2VpZ2h0ZWQgcGVuYWx0eSBzY29yZXMgZm9yIHRoZSB1bmRlc2lyYWJsZSBmZWF0dXJlc1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0dmFyIFBlbmFsdHlTY29yZXMgPSB7XG5cdCAgTjE6IDMsXG5cdCAgTjI6IDMsXG5cdCAgTjM6IDQwLFxuXHQgIE40OiAxMFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBtYXNrIHBhdHRlcm4gdmFsdWUgaXMgdmFsaWRcblx0ICpcblx0ICogQHBhcmFtICB7TnVtYmVyfSAgbWFzayAgICBNYXNrIHBhdHRlcm5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGV4cG9ydHMuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQgKG1hc2spIHtcblx0ICByZXR1cm4gbWFzayAhPSBudWxsICYmIG1hc2sgIT09ICcnICYmICFpc05hTihtYXNrKSAmJiBtYXNrID49IDAgJiYgbWFzayA8PSA3XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgbWFzayBwYXR0ZXJuIGZyb20gYSB2YWx1ZS5cblx0ICogSWYgdmFsdWUgaXMgbm90IHZhbGlkLCByZXR1cm5zIHVuZGVmaW5lZFxuXHQgKlxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAgICAgICAgTWFzayBwYXR0ZXJuIHZhbHVlXG5cdCAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICBWYWxpZCBtYXNrIHBhdHRlcm4gb3IgdW5kZWZpbmVkXG5cdCAqL1xuXHRleHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tICh2YWx1ZSkge1xuXHQgIHJldHVybiBleHBvcnRzLmlzVmFsaWQodmFsdWUpID8gcGFyc2VJbnQodmFsdWUsIDEwKSA6IHVuZGVmaW5lZFxuXHR9O1xuXG5cdC8qKlxuXHQqIEZpbmQgYWRqYWNlbnQgbW9kdWxlcyBpbiByb3cvY29sdW1uIHdpdGggdGhlIHNhbWUgY29sb3Jcblx0KiBhbmQgYXNzaWduIGEgcGVuYWx0eSB2YWx1ZS5cblx0KlxuXHQqIFBvaW50czogTjEgKyBpXG5cdCogaSBpcyB0aGUgYW1vdW50IGJ5IHdoaWNoIHRoZSBudW1iZXIgb2YgYWRqYWNlbnQgbW9kdWxlcyBvZiB0aGUgc2FtZSBjb2xvciBleGNlZWRzIDVcblx0Ki9cblx0ZXhwb3J0cy5nZXRQZW5hbHR5TjEgPSBmdW5jdGlvbiBnZXRQZW5hbHR5TjEgKGRhdGEpIHtcblx0ICB2YXIgc2l6ZSA9IGRhdGEuc2l6ZTtcblx0ICB2YXIgcG9pbnRzID0gMDtcblx0ICB2YXIgc2FtZUNvdW50Q29sID0gMDtcblx0ICB2YXIgc2FtZUNvdW50Um93ID0gMDtcblx0ICB2YXIgbGFzdENvbCA9IG51bGw7XG5cdCAgdmFyIGxhc3RSb3cgPSBudWxsO1xuXG5cdCAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgc2l6ZTsgcm93KyspIHtcblx0ICAgIHNhbWVDb3VudENvbCA9IHNhbWVDb3VudFJvdyA9IDA7XG5cdCAgICBsYXN0Q29sID0gbGFzdFJvdyA9IG51bGw7XG5cblx0ICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHNpemU7IGNvbCsrKSB7XG5cdCAgICAgIHZhciBtb2R1bGUgPSBkYXRhLmdldChyb3csIGNvbCk7XG5cdCAgICAgIGlmIChtb2R1bGUgPT09IGxhc3RDb2wpIHtcblx0ICAgICAgICBzYW1lQ291bnRDb2wrKztcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAoc2FtZUNvdW50Q29sID49IDUpIHBvaW50cyArPSBQZW5hbHR5U2NvcmVzLk4xICsgKHNhbWVDb3VudENvbCAtIDUpO1xuXHQgICAgICAgIGxhc3RDb2wgPSBtb2R1bGU7XG5cdCAgICAgICAgc2FtZUNvdW50Q29sID0gMTtcblx0ICAgICAgfVxuXG5cdCAgICAgIG1vZHVsZSA9IGRhdGEuZ2V0KGNvbCwgcm93KTtcblx0ICAgICAgaWYgKG1vZHVsZSA9PT0gbGFzdFJvdykge1xuXHQgICAgICAgIHNhbWVDb3VudFJvdysrO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChzYW1lQ291bnRSb3cgPj0gNSkgcG9pbnRzICs9IFBlbmFsdHlTY29yZXMuTjEgKyAoc2FtZUNvdW50Um93IC0gNSk7XG5cdCAgICAgICAgbGFzdFJvdyA9IG1vZHVsZTtcblx0ICAgICAgICBzYW1lQ291bnRSb3cgPSAxO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChzYW1lQ291bnRDb2wgPj0gNSkgcG9pbnRzICs9IFBlbmFsdHlTY29yZXMuTjEgKyAoc2FtZUNvdW50Q29sIC0gNSk7XG5cdCAgICBpZiAoc2FtZUNvdW50Um93ID49IDUpIHBvaW50cyArPSBQZW5hbHR5U2NvcmVzLk4xICsgKHNhbWVDb3VudFJvdyAtIDUpO1xuXHQgIH1cblxuXHQgIHJldHVybiBwb2ludHNcblx0fTtcblxuXHQvKipcblx0ICogRmluZCAyeDIgYmxvY2tzIHdpdGggdGhlIHNhbWUgY29sb3IgYW5kIGFzc2lnbiBhIHBlbmFsdHkgdmFsdWVcblx0ICpcblx0ICogUG9pbnRzOiBOMiAqIChtIC0gMSkgKiAobiAtIDEpXG5cdCAqL1xuXHRleHBvcnRzLmdldFBlbmFsdHlOMiA9IGZ1bmN0aW9uIGdldFBlbmFsdHlOMiAoZGF0YSkge1xuXHQgIHZhciBzaXplID0gZGF0YS5zaXplO1xuXHQgIHZhciBwb2ludHMgPSAwO1xuXG5cdCAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgc2l6ZSAtIDE7IHJvdysrKSB7XG5cdCAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBzaXplIC0gMTsgY29sKyspIHtcblx0ICAgICAgdmFyIGxhc3QgPSBkYXRhLmdldChyb3csIGNvbCkgK1xuXHQgICAgICAgIGRhdGEuZ2V0KHJvdywgY29sICsgMSkgK1xuXHQgICAgICAgIGRhdGEuZ2V0KHJvdyArIDEsIGNvbCkgK1xuXHQgICAgICAgIGRhdGEuZ2V0KHJvdyArIDEsIGNvbCArIDEpO1xuXG5cdCAgICAgIGlmIChsYXN0ID09PSA0IHx8IGxhc3QgPT09IDApIHBvaW50cysrO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBwb2ludHMgKiBQZW5hbHR5U2NvcmVzLk4yXG5cdH07XG5cblx0LyoqXG5cdCAqIEZpbmQgMToxOjM6MToxIHJhdGlvIChkYXJrOmxpZ2h0OmRhcms6bGlnaHQ6ZGFyaykgcGF0dGVybiBpbiByb3cvY29sdW1uLFxuXHQgKiBwcmVjZWRlZCBvciBmb2xsb3dlZCBieSBsaWdodCBhcmVhIDQgbW9kdWxlcyB3aWRlXG5cdCAqXG5cdCAqIFBvaW50czogTjMgKiBudW1iZXIgb2YgcGF0dGVybiBmb3VuZFxuXHQgKi9cblx0ZXhwb3J0cy5nZXRQZW5hbHR5TjMgPSBmdW5jdGlvbiBnZXRQZW5hbHR5TjMgKGRhdGEpIHtcblx0ICB2YXIgc2l6ZSA9IGRhdGEuc2l6ZTtcblx0ICB2YXIgcG9pbnRzID0gMDtcblx0ICB2YXIgYml0c0NvbCA9IDA7XG5cdCAgdmFyIGJpdHNSb3cgPSAwO1xuXG5cdCAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgc2l6ZTsgcm93KyspIHtcblx0ICAgIGJpdHNDb2wgPSBiaXRzUm93ID0gMDtcblx0ICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHNpemU7IGNvbCsrKSB7XG5cdCAgICAgIGJpdHNDb2wgPSAoKGJpdHNDb2wgPDwgMSkgJiAweDdGRikgfCBkYXRhLmdldChyb3csIGNvbCk7XG5cdCAgICAgIGlmIChjb2wgPj0gMTAgJiYgKGJpdHNDb2wgPT09IDB4NUQwIHx8IGJpdHNDb2wgPT09IDB4MDVEKSkgcG9pbnRzKys7XG5cblx0ICAgICAgYml0c1JvdyA9ICgoYml0c1JvdyA8PCAxKSAmIDB4N0ZGKSB8IGRhdGEuZ2V0KGNvbCwgcm93KTtcblx0ICAgICAgaWYgKGNvbCA+PSAxMCAmJiAoYml0c1JvdyA9PT0gMHg1RDAgfHwgYml0c1JvdyA9PT0gMHgwNUQpKSBwb2ludHMrKztcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gcG9pbnRzICogUGVuYWx0eVNjb3Jlcy5OM1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgcHJvcG9ydGlvbiBvZiBkYXJrIG1vZHVsZXMgaW4gZW50aXJlIHN5bWJvbFxuXHQgKlxuXHQgKiBQb2ludHM6IE40ICoga1xuXHQgKlxuXHQgKiBrIGlzIHRoZSByYXRpbmcgb2YgdGhlIGRldmlhdGlvbiBvZiB0aGUgcHJvcG9ydGlvbiBvZiBkYXJrIG1vZHVsZXNcblx0ICogaW4gdGhlIHN5bWJvbCBmcm9tIDUwJSBpbiBzdGVwcyBvZiA1JVxuXHQgKi9cblx0ZXhwb3J0cy5nZXRQZW5hbHR5TjQgPSBmdW5jdGlvbiBnZXRQZW5hbHR5TjQgKGRhdGEpIHtcblx0ICB2YXIgZGFya0NvdW50ID0gMDtcblx0ICB2YXIgbW9kdWxlc0NvdW50ID0gZGF0YS5kYXRhLmxlbmd0aDtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kdWxlc0NvdW50OyBpKyspIGRhcmtDb3VudCArPSBkYXRhLmRhdGFbaV07XG5cblx0ICB2YXIgayA9IE1hdGguYWJzKE1hdGguY2VpbCgoZGFya0NvdW50ICogMTAwIC8gbW9kdWxlc0NvdW50KSAvIDUpIC0gMTApO1xuXG5cdCAgcmV0dXJuIGsgKiBQZW5hbHR5U2NvcmVzLk40XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiBtYXNrIHZhbHVlIGF0IGdpdmVuIHBvc2l0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSAge051bWJlcn0gbWFza1BhdHRlcm4gUGF0dGVybiByZWZlcmVuY2UgdmFsdWVcblx0ICogQHBhcmFtICB7TnVtYmVyfSBpICAgICAgICAgICBSb3dcblx0ICogQHBhcmFtICB7TnVtYmVyfSBqICAgICAgICAgICBDb2x1bW5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICBNYXNrIHZhbHVlXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRNYXNrQXQgKG1hc2tQYXR0ZXJuLCBpLCBqKSB7XG5cdCAgc3dpdGNoIChtYXNrUGF0dGVybikge1xuXHQgICAgY2FzZSBleHBvcnRzLlBhdHRlcm5zLlBBVFRFUk4wMDA6IHJldHVybiAoaSArIGopICUgMiA9PT0gMFxuXHQgICAgY2FzZSBleHBvcnRzLlBhdHRlcm5zLlBBVFRFUk4wMDE6IHJldHVybiBpICUgMiA9PT0gMFxuXHQgICAgY2FzZSBleHBvcnRzLlBhdHRlcm5zLlBBVFRFUk4wMTA6IHJldHVybiBqICUgMyA9PT0gMFxuXHQgICAgY2FzZSBleHBvcnRzLlBhdHRlcm5zLlBBVFRFUk4wMTE6IHJldHVybiAoaSArIGopICUgMyA9PT0gMFxuXHQgICAgY2FzZSBleHBvcnRzLlBhdHRlcm5zLlBBVFRFUk4xMDA6IHJldHVybiAoTWF0aC5mbG9vcihpIC8gMikgKyBNYXRoLmZsb29yKGogLyAzKSkgJSAyID09PSAwXG5cdCAgICBjYXNlIGV4cG9ydHMuUGF0dGVybnMuUEFUVEVSTjEwMTogcmV0dXJuIChpICogaikgJSAyICsgKGkgKiBqKSAlIDMgPT09IDBcblx0ICAgIGNhc2UgZXhwb3J0cy5QYXR0ZXJucy5QQVRURVJOMTEwOiByZXR1cm4gKChpICogaikgJSAyICsgKGkgKiBqKSAlIDMpICUgMiA9PT0gMFxuXHQgICAgY2FzZSBleHBvcnRzLlBhdHRlcm5zLlBBVFRFUk4xMTE6IHJldHVybiAoKGkgKiBqKSAlIDMgKyAoaSArIGopICUgMikgJSAyID09PSAwXG5cblx0ICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignYmFkIG1hc2tQYXR0ZXJuOicgKyBtYXNrUGF0dGVybilcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogQXBwbHkgYSBtYXNrIHBhdHRlcm4gdG8gYSBCaXRNYXRyaXhcblx0ICpcblx0ICogQHBhcmFtICB7TnVtYmVyfSAgICBwYXR0ZXJuIFBhdHRlcm4gcmVmZXJlbmNlIG51bWJlclxuXHQgKiBAcGFyYW0gIHtCaXRNYXRyaXh9IGRhdGEgICAgQml0TWF0cml4IGRhdGFcblx0ICovXG5cdGV4cG9ydHMuYXBwbHlNYXNrID0gZnVuY3Rpb24gYXBwbHlNYXNrIChwYXR0ZXJuLCBkYXRhKSB7XG5cdCAgdmFyIHNpemUgPSBkYXRhLnNpemU7XG5cblx0ICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBzaXplOyBjb2wrKykge1xuXHQgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgc2l6ZTsgcm93KyspIHtcblx0ICAgICAgaWYgKGRhdGEuaXNSZXNlcnZlZChyb3csIGNvbCkpIGNvbnRpbnVlXG5cdCAgICAgIGRhdGEueG9yKHJvdywgY29sLCBnZXRNYXNrQXQocGF0dGVybiwgcm93LCBjb2wpKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGJlc3QgbWFzayBwYXR0ZXJuIGZvciBkYXRhXG5cdCAqXG5cdCAqIEBwYXJhbSAge0JpdE1hdHJpeH0gZGF0YVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IE1hc2sgcGF0dGVybiByZWZlcmVuY2UgbnVtYmVyXG5cdCAqL1xuXHRleHBvcnRzLmdldEJlc3RNYXNrID0gZnVuY3Rpb24gZ2V0QmVzdE1hc2sgKGRhdGEsIHNldHVwRm9ybWF0RnVuYykge1xuXHQgIHZhciBudW1QYXR0ZXJucyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuUGF0dGVybnMpLmxlbmd0aDtcblx0ICB2YXIgYmVzdFBhdHRlcm4gPSAwO1xuXHQgIHZhciBsb3dlclBlbmFsdHkgPSBJbmZpbml0eTtcblxuXHQgIGZvciAodmFyIHAgPSAwOyBwIDwgbnVtUGF0dGVybnM7IHArKykge1xuXHQgICAgc2V0dXBGb3JtYXRGdW5jKHApO1xuXHQgICAgZXhwb3J0cy5hcHBseU1hc2socCwgZGF0YSk7XG5cblx0ICAgIC8vIENhbGN1bGF0ZSBwZW5hbHR5XG5cdCAgICB2YXIgcGVuYWx0eSA9XG5cdCAgICAgIGV4cG9ydHMuZ2V0UGVuYWx0eU4xKGRhdGEpICtcblx0ICAgICAgZXhwb3J0cy5nZXRQZW5hbHR5TjIoZGF0YSkgK1xuXHQgICAgICBleHBvcnRzLmdldFBlbmFsdHlOMyhkYXRhKSArXG5cdCAgICAgIGV4cG9ydHMuZ2V0UGVuYWx0eU40KGRhdGEpO1xuXG5cdCAgICAvLyBVbmRvIHByZXZpb3VzbHkgYXBwbGllZCBtYXNrXG5cdCAgICBleHBvcnRzLmFwcGx5TWFzayhwLCBkYXRhKTtcblxuXHQgICAgaWYgKHBlbmFsdHkgPCBsb3dlclBlbmFsdHkpIHtcblx0ICAgICAgbG93ZXJQZW5hbHR5ID0gcGVuYWx0eTtcblx0ICAgICAgYmVzdFBhdHRlcm4gPSBwO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBiZXN0UGF0dGVyblxuXHR9O1xuXG5cdH0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblx0dmFyIFZlcnNpb25DaGVjayA9IHJlcXVpcmUoJy4vdmVyc2lvbi1jaGVjaycpO1xuXHR2YXIgUmVnZXggPSByZXF1aXJlKCcuL3JlZ2V4Jyk7XG5cblx0LyoqXG5cdCAqIE51bWVyaWMgbW9kZSBlbmNvZGVzIGRhdGEgZnJvbSB0aGUgZGVjaW1hbCBkaWdpdCBzZXQgKDAgLSA5KVxuXHQgKiAoYnl0ZSB2YWx1ZXMgMzBIRVggdG8gMzlIRVgpLlxuXHQgKiBOb3JtYWxseSwgMyBkYXRhIGNoYXJhY3RlcnMgYXJlIHJlcHJlc2VudGVkIGJ5IDEwIGJpdHMuXG5cdCAqXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHRleHBvcnRzLk5VTUVSSUMgPSB7XG5cdCAgaWQ6ICdOdW1lcmljJyxcblx0ICBiaXQ6IDEgPDwgMCxcblx0ICBjY0JpdHM6IFsxMCwgMTIsIDE0XVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbHBoYW51bWVyaWMgbW9kZSBlbmNvZGVzIGRhdGEgZnJvbSBhIHNldCBvZiA0NSBjaGFyYWN0ZXJzLFxuXHQgKiBpLmUuIDEwIG51bWVyaWMgZGlnaXRzICgwIC0gOSksXG5cdCAqICAgICAgMjYgYWxwaGFiZXRpYyBjaGFyYWN0ZXJzIChBIC0gWiksXG5cdCAqICAgYW5kIDkgc3ltYm9scyAoU1AsICQsICUsICosICssIC0sIC4sIC8sIDopLlxuXHQgKiBOb3JtYWxseSwgdHdvIGlucHV0IGNoYXJhY3RlcnMgYXJlIHJlcHJlc2VudGVkIGJ5IDExIGJpdHMuXG5cdCAqXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXHRleHBvcnRzLkFMUEhBTlVNRVJJQyA9IHtcblx0ICBpZDogJ0FscGhhbnVtZXJpYycsXG5cdCAgYml0OiAxIDw8IDEsXG5cdCAgY2NCaXRzOiBbOSwgMTEsIDEzXVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbiBieXRlIG1vZGUsIGRhdGEgaXMgZW5jb2RlZCBhdCA4IGJpdHMgcGVyIGNoYXJhY3Rlci5cblx0ICpcblx0ICogQHR5cGUge09iamVjdH1cblx0ICovXG5cdGV4cG9ydHMuQllURSA9IHtcblx0ICBpZDogJ0J5dGUnLFxuXHQgIGJpdDogMSA8PCAyLFxuXHQgIGNjQml0czogWzgsIDE2LCAxNl1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIEthbmppIG1vZGUgZWZmaWNpZW50bHkgZW5jb2RlcyBLYW5qaSBjaGFyYWN0ZXJzIGluIGFjY29yZGFuY2Ugd2l0aFxuXHQgKiB0aGUgU2hpZnQgSklTIHN5c3RlbSBiYXNlZCBvbiBKSVMgWCAwMjA4LlxuXHQgKiBUaGUgU2hpZnQgSklTIHZhbHVlcyBhcmUgc2hpZnRlZCBmcm9tIHRoZSBKSVMgWCAwMjA4IHZhbHVlcy5cblx0ICogSklTIFggMDIwOCBnaXZlcyBkZXRhaWxzIG9mIHRoZSBzaGlmdCBjb2RlZCByZXByZXNlbnRhdGlvbi5cblx0ICogRWFjaCB0d28tYnl0ZSBjaGFyYWN0ZXIgdmFsdWUgaXMgY29tcGFjdGVkIHRvIGEgMTMtYml0IGJpbmFyeSBjb2Rld29yZC5cblx0ICpcblx0ICogQHR5cGUge09iamVjdH1cblx0ICovXG5cdGV4cG9ydHMuS0FOSkkgPSB7XG5cdCAgaWQ6ICdLYW5qaScsXG5cdCAgYml0OiAxIDw8IDMsXG5cdCAgY2NCaXRzOiBbOCwgMTAsIDEyXVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBNaXhlZCBtb2RlIHdpbGwgY29udGFpbiBhIHNlcXVlbmNlcyBvZiBkYXRhIGluIGEgY29tYmluYXRpb24gb2YgYW55IG9mXG5cdCAqIHRoZSBtb2RlcyBkZXNjcmliZWQgYWJvdmVcblx0ICpcblx0ICogQHR5cGUge09iamVjdH1cblx0ICovXG5cdGV4cG9ydHMuTUlYRUQgPSB7XG5cdCAgYml0OiAtMVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gc3RvcmUgdGhlIGRhdGEgbGVuZ3RoXG5cdCAqIGFjY29yZGluZyB0byBRUiBDb2RlIHNwZWNpZmljYXRpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtNb2RlfSAgIG1vZGUgICAgRGF0YSBtb2RlXG5cdCAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cblx0ICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgIE51bWJlciBvZiBiaXRzXG5cdCAqL1xuXHRleHBvcnRzLmdldENoYXJDb3VudEluZGljYXRvciA9IGZ1bmN0aW9uIGdldENoYXJDb3VudEluZGljYXRvciAobW9kZSwgdmVyc2lvbikge1xuXHQgIGlmICghbW9kZS5jY0JpdHMpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtb2RlOiAnICsgbW9kZSlcblxuXHQgIGlmICghVmVyc2lvbkNoZWNrLmlzVmFsaWQodmVyc2lvbikpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJzaW9uOiAnICsgdmVyc2lvbilcblx0ICB9XG5cblx0ICBpZiAodmVyc2lvbiA+PSAxICYmIHZlcnNpb24gPCAxMCkgcmV0dXJuIG1vZGUuY2NCaXRzWzBdXG5cdCAgZWxzZSBpZiAodmVyc2lvbiA8IDI3KSByZXR1cm4gbW9kZS5jY0JpdHNbMV1cblx0ICByZXR1cm4gbW9kZS5jY0JpdHNbMl1cblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbW9zdCBlZmZpY2llbnQgbW9kZSB0byBzdG9yZSB0aGUgc3BlY2lmaWVkIGRhdGFcblx0ICpcblx0ICogQHBhcmFtICB7U3RyaW5nfSBkYXRhU3RyIElucHV0IGRhdGEgc3RyaW5nXG5cdCAqIEByZXR1cm4ge01vZGV9ICAgICAgICAgICBCZXN0IG1vZGVcblx0ICovXG5cdGV4cG9ydHMuZ2V0QmVzdE1vZGVGb3JEYXRhID0gZnVuY3Rpb24gZ2V0QmVzdE1vZGVGb3JEYXRhIChkYXRhU3RyKSB7XG5cdCAgaWYgKFJlZ2V4LnRlc3ROdW1lcmljKGRhdGFTdHIpKSByZXR1cm4gZXhwb3J0cy5OVU1FUklDXG5cdCAgZWxzZSBpZiAoUmVnZXgudGVzdEFscGhhbnVtZXJpYyhkYXRhU3RyKSkgcmV0dXJuIGV4cG9ydHMuQUxQSEFOVU1FUklDXG5cdCAgZWxzZSBpZiAoUmVnZXgudGVzdEthbmppKGRhdGFTdHIpKSByZXR1cm4gZXhwb3J0cy5LQU5KSVxuXHQgIGVsc2UgcmV0dXJuIGV4cG9ydHMuQllURVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gbW9kZSBuYW1lIGFzIHN0cmluZ1xuXHQgKlxuXHQgKiBAcGFyYW0ge01vZGV9IG1vZGUgTW9kZSBvYmplY3Rcblx0ICogQHJldHVybnMge1N0cmluZ30gIE1vZGUgbmFtZVxuXHQgKi9cblx0ZXhwb3J0cy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChtb2RlKSB7XG5cdCAgaWYgKG1vZGUgJiYgbW9kZS5pZCkgcmV0dXJuIG1vZGUuaWRcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZScpXG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGlucHV0IHBhcmFtIGlzIGEgdmFsaWQgbW9kZSBvYmplY3Rcblx0ICpcblx0ICogQHBhcmFtICAge01vZGV9ICAgIG1vZGUgTW9kZSBvYmplY3Rcblx0ICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdmFsaWQgbW9kZSwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRleHBvcnRzLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkIChtb2RlKSB7XG5cdCAgcmV0dXJuIG1vZGUgJiYgbW9kZS5iaXQgJiYgbW9kZS5jY0JpdHNcblx0fTtcblxuXHQvKipcblx0ICogR2V0IG1vZGUgb2JqZWN0IGZyb20gaXRzIG5hbWVcblx0ICpcblx0ICogQHBhcmFtICAge1N0cmluZ30gc3RyaW5nIE1vZGUgbmFtZVxuXHQgKiBAcmV0dXJucyB7TW9kZX0gICAgICAgICAgTW9kZSBvYmplY3Rcblx0ICovXG5cdGZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZykge1xuXHQgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbSBpcyBub3QgYSBzdHJpbmcnKVxuXHQgIH1cblxuXHQgIHZhciBsY1N0ciA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuXG5cdCAgc3dpdGNoIChsY1N0cikge1xuXHQgICAgY2FzZSAnbnVtZXJpYyc6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLk5VTUVSSUNcblx0ICAgIGNhc2UgJ2FscGhhbnVtZXJpYyc6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLkFMUEhBTlVNRVJJQ1xuXHQgICAgY2FzZSAna2FuamknOlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5LQU5KSVxuXHQgICAgY2FzZSAnYnl0ZSc6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLkJZVEVcblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtb2RlOiAnICsgc3RyaW5nKVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIG1vZGUgZnJvbSBhIHZhbHVlLlxuXHQgKiBJZiB2YWx1ZSBpcyBub3QgYSB2YWxpZCBtb2RlLCByZXR1cm5zIGRlZmF1bHRWYWx1ZVxuXHQgKlxuXHQgKiBAcGFyYW0gIHtNb2RlfFN0cmluZ30gdmFsdWUgICAgICAgIEVuY29kaW5nIG1vZGVcblx0ICogQHBhcmFtICB7TW9kZX0gICAgICAgIGRlZmF1bHRWYWx1ZSBGYWxsYmFjayB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtNb2RlfSAgICAgICAgICAgICAgICAgICAgIEVuY29kaW5nIG1vZGVcblx0ICovXG5cdGV4cG9ydHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcblx0ICBpZiAoZXhwb3J0cy5pc1ZhbGlkKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIHZhbHVlXG5cdCAgfVxuXG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlKVxuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIHJldHVybiBkZWZhdWx0VmFsdWVcblx0ICB9XG5cdH07XG5cblx0fSx7XCIuL3JlZ2V4XCI6MTksXCIuL3ZlcnNpb24tY2hlY2tcIjoyMn1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblx0dmFyIE1vZGUgPSByZXF1aXJlKCcuL21vZGUnKTtcblxuXHRmdW5jdGlvbiBOdW1lcmljRGF0YSAoZGF0YSkge1xuXHQgIHRoaXMubW9kZSA9IE1vZGUuTlVNRVJJQztcblx0ICB0aGlzLmRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cdH1cblxuXHROdW1lcmljRGF0YS5nZXRCaXRzTGVuZ3RoID0gZnVuY3Rpb24gZ2V0Qml0c0xlbmd0aCAobGVuZ3RoKSB7XG5cdCAgcmV0dXJuIDEwICogTWF0aC5mbG9vcihsZW5ndGggLyAzKSArICgobGVuZ3RoICUgMykgPyAoKGxlbmd0aCAlIDMpICogMyArIDEpIDogMClcblx0fTtcblxuXHROdW1lcmljRGF0YS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoICgpIHtcblx0ICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aFxuXHR9O1xuXG5cdE51bWVyaWNEYXRhLnByb3RvdHlwZS5nZXRCaXRzTGVuZ3RoID0gZnVuY3Rpb24gZ2V0Qml0c0xlbmd0aCAoKSB7XG5cdCAgcmV0dXJuIE51bWVyaWNEYXRhLmdldEJpdHNMZW5ndGgodGhpcy5kYXRhLmxlbmd0aClcblx0fTtcblxuXHROdW1lcmljRGF0YS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoYml0QnVmZmVyKSB7XG5cdCAgdmFyIGksIGdyb3VwLCB2YWx1ZTtcblxuXHQgIC8vIFRoZSBpbnB1dCBkYXRhIHN0cmluZyBpcyBkaXZpZGVkIGludG8gZ3JvdXBzIG9mIHRocmVlIGRpZ2l0cyxcblx0ICAvLyBhbmQgZWFjaCBncm91cCBpcyBjb252ZXJ0ZWQgdG8gaXRzIDEwLWJpdCBiaW5hcnkgZXF1aXZhbGVudC5cblx0ICBmb3IgKGkgPSAwOyBpICsgMyA8PSB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IDMpIHtcblx0ICAgIGdyb3VwID0gdGhpcy5kYXRhLnN1YnN0cihpLCAzKTtcblx0ICAgIHZhbHVlID0gcGFyc2VJbnQoZ3JvdXAsIDEwKTtcblxuXHQgICAgYml0QnVmZmVyLnB1dCh2YWx1ZSwgMTApO1xuXHQgIH1cblxuXHQgIC8vIElmIHRoZSBudW1iZXIgb2YgaW5wdXQgZGlnaXRzIGlzIG5vdCBhbiBleGFjdCBtdWx0aXBsZSBvZiB0aHJlZSxcblx0ICAvLyB0aGUgZmluYWwgb25lIG9yIHR3byBkaWdpdHMgYXJlIGNvbnZlcnRlZCB0byA0IG9yIDcgYml0cyByZXNwZWN0aXZlbHkuXG5cdCAgdmFyIHJlbWFpbmluZ051bSA9IHRoaXMuZGF0YS5sZW5ndGggLSBpO1xuXHQgIGlmIChyZW1haW5pbmdOdW0gPiAwKSB7XG5cdCAgICBncm91cCA9IHRoaXMuZGF0YS5zdWJzdHIoaSk7XG5cdCAgICB2YWx1ZSA9IHBhcnNlSW50KGdyb3VwLCAxMCk7XG5cblx0ICAgIGJpdEJ1ZmZlci5wdXQodmFsdWUsIHJlbWFpbmluZ051bSAqIDMgKyAxKTtcblx0ICB9XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBOdW1lcmljRGF0YTtcblxuXHR9LHtcIi4vbW9kZVwiOjE0fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHR2YXIgQnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWxzL2J1ZmZlcicpO1xuXHR2YXIgR0YgPSByZXF1aXJlKCcuL2dhbG9pcy1maWVsZCcpO1xuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIHR3byBwb2x5bm9taWFscyBpbnNpZGUgR2Fsb2lzIEZpZWxkXG5cdCAqXG5cdCAqIEBwYXJhbSAge0J1ZmZlcn0gcDEgUG9seW5vbWlhbFxuXHQgKiBAcGFyYW0gIHtCdWZmZXJ9IHAyIFBvbHlub21pYWxcblx0ICogQHJldHVybiB7QnVmZmVyfSAgICBQcm9kdWN0IG9mIHAxIGFuZCBwMlxuXHQgKi9cblx0ZXhwb3J0cy5tdWwgPSBmdW5jdGlvbiBtdWwgKHAxLCBwMikge1xuXHQgIHZhciBjb2VmZiA9IEJ1ZmZlclV0aWwuYWxsb2MocDEubGVuZ3RoICsgcDIubGVuZ3RoIC0gMSk7XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHAxLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IHAyLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgIGNvZWZmW2kgKyBqXSBePSBHRi5tdWwocDFbaV0sIHAyW2pdKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gY29lZmZcblx0fTtcblxuXHQvKipcblx0ICogQ2FsY3VsYXRlIHRoZSByZW1haW5kZXIgb2YgcG9seW5vbWlhbHMgZGl2aXNpb25cblx0ICpcblx0ICogQHBhcmFtICB7QnVmZmVyfSBkaXZpZGVudCBQb2x5bm9taWFsXG5cdCAqIEBwYXJhbSAge0J1ZmZlcn0gZGl2aXNvciAgUG9seW5vbWlhbFxuXHQgKiBAcmV0dXJuIHtCdWZmZXJ9ICAgICAgICAgIFJlbWFpbmRlclxuXHQgKi9cblx0ZXhwb3J0cy5tb2QgPSBmdW5jdGlvbiBtb2QgKGRpdmlkZW50LCBkaXZpc29yKSB7XG5cdCAgdmFyIHJlc3VsdCA9IEJ1ZmZlclV0aWwuZnJvbShkaXZpZGVudCk7XG5cblx0ICB3aGlsZSAoKHJlc3VsdC5sZW5ndGggLSBkaXZpc29yLmxlbmd0aCkgPj0gMCkge1xuXHQgICAgdmFyIGNvZWZmID0gcmVzdWx0WzBdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpdmlzb3IubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgcmVzdWx0W2ldIF49IEdGLm11bChkaXZpc29yW2ldLCBjb2VmZik7XG5cdCAgICB9XG5cblx0ICAgIC8vIHJlbW92ZSBhbGwgemVyb3MgZnJvbSBidWZmZXIgaGVhZFxuXHQgICAgdmFyIG9mZnNldCA9IDA7XG5cdCAgICB3aGlsZSAob2Zmc2V0IDwgcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbb2Zmc2V0XSA9PT0gMCkgb2Zmc2V0Kys7XG5cdCAgICByZXN1bHQgPSByZXN1bHQuc2xpY2Uob2Zmc2V0KTtcblx0ICB9XG5cblx0ICByZXR1cm4gcmVzdWx0XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGFuIGlycmVkdWNpYmxlIGdlbmVyYXRvciBwb2x5bm9taWFsIG9mIHNwZWNpZmllZCBkZWdyZWVcblx0ICogKHVzZWQgYnkgUmVlZC1Tb2xvbW9uIGVuY29kZXIpXG5cdCAqXG5cdCAqIEBwYXJhbSAge051bWJlcn0gZGVncmVlIERlZ3JlZSBvZiB0aGUgZ2VuZXJhdG9yIHBvbHlub21pYWxcblx0ICogQHJldHVybiB7QnVmZmVyfSAgICAgICAgQnVmZmVyIGNvbnRhaW5pbmcgcG9seW5vbWlhbCBjb2VmZmljaWVudHNcblx0ICovXG5cdGV4cG9ydHMuZ2VuZXJhdGVFQ1BvbHlub21pYWwgPSBmdW5jdGlvbiBnZW5lcmF0ZUVDUG9seW5vbWlhbCAoZGVncmVlKSB7XG5cdCAgdmFyIHBvbHkgPSBCdWZmZXJVdGlsLmZyb20oWzFdKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZ3JlZTsgaSsrKSB7XG5cdCAgICBwb2x5ID0gZXhwb3J0cy5tdWwocG9seSwgWzEsIEdGLmV4cChpKV0pO1xuXHQgIH1cblxuXHQgIHJldHVybiBwb2x5XG5cdH07XG5cblx0fSx7XCIuLi91dGlscy9idWZmZXJcIjoyOCxcIi4vZ2Fsb2lzLWZpZWxkXCI6MTF9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cdHZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbHMvYnVmZmVyJyk7XG5cdHZhciBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblx0dmFyIEVDTGV2ZWwgPSByZXF1aXJlKCcuL2Vycm9yLWNvcnJlY3Rpb24tbGV2ZWwnKTtcblx0dmFyIEJpdEJ1ZmZlciA9IHJlcXVpcmUoJy4vYml0LWJ1ZmZlcicpO1xuXHR2YXIgQml0TWF0cml4ID0gcmVxdWlyZSgnLi9iaXQtbWF0cml4Jyk7XG5cdHZhciBBbGlnbm1lbnRQYXR0ZXJuID0gcmVxdWlyZSgnLi9hbGlnbm1lbnQtcGF0dGVybicpO1xuXHR2YXIgRmluZGVyUGF0dGVybiA9IHJlcXVpcmUoJy4vZmluZGVyLXBhdHRlcm4nKTtcblx0dmFyIE1hc2tQYXR0ZXJuID0gcmVxdWlyZSgnLi9tYXNrLXBhdHRlcm4nKTtcblx0dmFyIEVDQ29kZSA9IHJlcXVpcmUoJy4vZXJyb3ItY29ycmVjdGlvbi1jb2RlJyk7XG5cdHZhciBSZWVkU29sb21vbkVuY29kZXIgPSByZXF1aXJlKCcuL3JlZWQtc29sb21vbi1lbmNvZGVyJyk7XG5cdHZhciBWZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cdHZhciBGb3JtYXRJbmZvID0gcmVxdWlyZSgnLi9mb3JtYXQtaW5mbycpO1xuXHR2YXIgTW9kZSA9IHJlcXVpcmUoJy4vbW9kZScpO1xuXHR2YXIgU2VnbWVudHMgPSByZXF1aXJlKCcuL3NlZ21lbnRzJyk7XG5cdHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG5cdC8qKlxuXHQgKiBRUkNvZGUgZm9yIEphdmFTY3JpcHRcblx0ICpcblx0ICogbW9kaWZpZWQgYnkgUnlhbiBEYXkgZm9yIG5vZGVqcyBzdXBwb3J0XG5cdCAqIENvcHlyaWdodCAoYykgMjAxMSBSeWFuIERheVxuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG5cdCAqICAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0ICpcblx0Ly8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gUVJDb2RlIGZvciBKYXZhU2NyaXB0XG5cdC8vXG5cdC8vIENvcHlyaWdodCAoYykgMjAwOSBLYXp1aGlrbyBBcmFzZVxuXHQvL1xuXHQvLyBVUkw6IGh0dHA6Ly93d3cuZC1wcm9qZWN0LmNvbS9cblx0Ly9cblx0Ly8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuXHQvLyAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdC8vXG5cdC8vIFRoZSB3b3JkIFwiUVIgQ29kZVwiIGlzIHJlZ2lzdGVyZWQgdHJhZGVtYXJrIG9mXG5cdC8vIERFTlNPIFdBVkUgSU5DT1JQT1JBVEVEXG5cdC8vICAgaHR0cDovL3d3dy5kZW5zby13YXZlLmNvbS9xcmNvZGUvZmFxcGF0ZW50LWUuaHRtbFxuXHQvL1xuXHQvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQqL1xuXG5cdC8qKlxuXHQgKiBBZGQgZmluZGVyIHBhdHRlcm5zIGJpdHMgdG8gbWF0cml4XG5cdCAqXG5cdCAqIEBwYXJhbSAge0JpdE1hdHJpeH0gbWF0cml4ICBNb2R1bGVzIG1hdHJpeFxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgIHZlcnNpb24gUVIgQ29kZSB2ZXJzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBzZXR1cEZpbmRlclBhdHRlcm4gKG1hdHJpeCwgdmVyc2lvbikge1xuXHQgIHZhciBzaXplID0gbWF0cml4LnNpemU7XG5cdCAgdmFyIHBvcyA9IEZpbmRlclBhdHRlcm4uZ2V0UG9zaXRpb25zKHZlcnNpb24pO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciByb3cgPSBwb3NbaV1bMF07XG5cdCAgICB2YXIgY29sID0gcG9zW2ldWzFdO1xuXG5cdCAgICBmb3IgKHZhciByID0gLTE7IHIgPD0gNzsgcisrKSB7XG5cdCAgICAgIGlmIChyb3cgKyByIDw9IC0xIHx8IHNpemUgPD0gcm93ICsgcikgY29udGludWVcblxuXHQgICAgICBmb3IgKHZhciBjID0gLTE7IGMgPD0gNzsgYysrKSB7XG5cdCAgICAgICAgaWYgKGNvbCArIGMgPD0gLTEgfHwgc2l6ZSA8PSBjb2wgKyBjKSBjb250aW51ZVxuXG5cdCAgICAgICAgaWYgKChyID49IDAgJiYgciA8PSA2ICYmIChjID09PSAwIHx8IGMgPT09IDYpKSB8fFxuXHQgICAgICAgICAgKGMgPj0gMCAmJiBjIDw9IDYgJiYgKHIgPT09IDAgfHwgciA9PT0gNikpIHx8XG5cdCAgICAgICAgICAociA+PSAyICYmIHIgPD0gNCAmJiBjID49IDIgJiYgYyA8PSA0KSkge1xuXHQgICAgICAgICAgbWF0cml4LnNldChyb3cgKyByLCBjb2wgKyBjLCB0cnVlLCB0cnVlKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgbWF0cml4LnNldChyb3cgKyByLCBjb2wgKyBjLCBmYWxzZSwgdHJ1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCB0aW1pbmcgcGF0dGVybiBiaXRzIHRvIG1hdHJpeFxuXHQgKlxuXHQgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGJlZm9yZSB7QGxpbmsgc2V0dXBBbGlnbm1lbnRQYXR0ZXJufVxuXHQgKlxuXHQgKiBAcGFyYW0gIHtCaXRNYXRyaXh9IG1hdHJpeCBNb2R1bGVzIG1hdHJpeFxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0dXBUaW1pbmdQYXR0ZXJuIChtYXRyaXgpIHtcblx0ICB2YXIgc2l6ZSA9IG1hdHJpeC5zaXplO1xuXG5cdCAgZm9yICh2YXIgciA9IDg7IHIgPCBzaXplIC0gODsgcisrKSB7XG5cdCAgICB2YXIgdmFsdWUgPSByICUgMiA9PT0gMDtcblx0ICAgIG1hdHJpeC5zZXQociwgNiwgdmFsdWUsIHRydWUpO1xuXHQgICAgbWF0cml4LnNldCg2LCByLCB2YWx1ZSwgdHJ1ZSk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhbGlnbm1lbnQgcGF0dGVybnMgYml0cyB0byBtYXRyaXhcblx0ICpcblx0ICogTm90ZTogdGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBhZnRlciB7QGxpbmsgc2V0dXBUaW1pbmdQYXR0ZXJufVxuXHQgKlxuXHQgKiBAcGFyYW0gIHtCaXRNYXRyaXh9IG1hdHJpeCAgTW9kdWxlcyBtYXRyaXhcblx0ICogQHBhcmFtICB7TnVtYmVyfSAgICB2ZXJzaW9uIFFSIENvZGUgdmVyc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0dXBBbGlnbm1lbnRQYXR0ZXJuIChtYXRyaXgsIHZlcnNpb24pIHtcblx0ICB2YXIgcG9zID0gQWxpZ25tZW50UGF0dGVybi5nZXRQb3NpdGlvbnModmVyc2lvbik7XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHBvcy5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIHJvdyA9IHBvc1tpXVswXTtcblx0ICAgIHZhciBjb2wgPSBwb3NbaV1bMV07XG5cblx0ICAgIGZvciAodmFyIHIgPSAtMjsgciA8PSAyOyByKyspIHtcblx0ICAgICAgZm9yICh2YXIgYyA9IC0yOyBjIDw9IDI7IGMrKykge1xuXHQgICAgICAgIGlmIChyID09PSAtMiB8fCByID09PSAyIHx8IGMgPT09IC0yIHx8IGMgPT09IDIgfHxcblx0ICAgICAgICAgIChyID09PSAwICYmIGMgPT09IDApKSB7XG5cdCAgICAgICAgICBtYXRyaXguc2V0KHJvdyArIHIsIGNvbCArIGMsIHRydWUsIHRydWUpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBtYXRyaXguc2V0KHJvdyArIHIsIGNvbCArIGMsIGZhbHNlLCB0cnVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogQWRkIHZlcnNpb24gaW5mbyBiaXRzIHRvIG1hdHJpeFxuXHQgKlxuXHQgKiBAcGFyYW0gIHtCaXRNYXRyaXh9IG1hdHJpeCAgTW9kdWxlcyBtYXRyaXhcblx0ICogQHBhcmFtICB7TnVtYmVyfSAgICB2ZXJzaW9uIFFSIENvZGUgdmVyc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0dXBWZXJzaW9uSW5mbyAobWF0cml4LCB2ZXJzaW9uKSB7XG5cdCAgdmFyIHNpemUgPSBtYXRyaXguc2l6ZTtcblx0ICB2YXIgYml0cyA9IFZlcnNpb24uZ2V0RW5jb2RlZEJpdHModmVyc2lvbik7XG5cdCAgdmFyIHJvdywgY29sLCBtb2Q7XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IDE4OyBpKyspIHtcblx0ICAgIHJvdyA9IE1hdGguZmxvb3IoaSAvIDMpO1xuXHQgICAgY29sID0gaSAlIDMgKyBzaXplIC0gOCAtIDM7XG5cdCAgICBtb2QgPSAoKGJpdHMgPj4gaSkgJiAxKSA9PT0gMTtcblxuXHQgICAgbWF0cml4LnNldChyb3csIGNvbCwgbW9kLCB0cnVlKTtcblx0ICAgIG1hdHJpeC5zZXQoY29sLCByb3csIG1vZCwgdHJ1ZSk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBmb3JtYXQgaW5mbyBiaXRzIHRvIG1hdHJpeFxuXHQgKlxuXHQgKiBAcGFyYW0gIHtCaXRNYXRyaXh9IG1hdHJpeCAgICAgICAgICAgICAgIE1vZHVsZXMgbWF0cml4XG5cdCAqIEBwYXJhbSAge0Vycm9yQ29ycmVjdGlvbkxldmVsfSAgICBlcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG5cdCAqIEBwYXJhbSAge051bWJlcn0gICAgbWFza1BhdHRlcm4gICAgICAgICAgTWFzayBwYXR0ZXJuIHJlZmVyZW5jZSB2YWx1ZVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0dXBGb3JtYXRJbmZvIChtYXRyaXgsIGVycm9yQ29ycmVjdGlvbkxldmVsLCBtYXNrUGF0dGVybikge1xuXHQgIHZhciBzaXplID0gbWF0cml4LnNpemU7XG5cdCAgdmFyIGJpdHMgPSBGb3JtYXRJbmZvLmdldEVuY29kZWRCaXRzKGVycm9yQ29ycmVjdGlvbkxldmVsLCBtYXNrUGF0dGVybik7XG5cdCAgdmFyIGksIG1vZDtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCAxNTsgaSsrKSB7XG5cdCAgICBtb2QgPSAoKGJpdHMgPj4gaSkgJiAxKSA9PT0gMTtcblxuXHQgICAgLy8gdmVydGljYWxcblx0ICAgIGlmIChpIDwgNikge1xuXHQgICAgICBtYXRyaXguc2V0KGksIDgsIG1vZCwgdHJ1ZSk7XG5cdCAgICB9IGVsc2UgaWYgKGkgPCA4KSB7XG5cdCAgICAgIG1hdHJpeC5zZXQoaSArIDEsIDgsIG1vZCwgdHJ1ZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBtYXRyaXguc2V0KHNpemUgLSAxNSArIGksIDgsIG1vZCwgdHJ1ZSk7XG5cdCAgICB9XG5cblx0ICAgIC8vIGhvcml6b250YWxcblx0ICAgIGlmIChpIDwgOCkge1xuXHQgICAgICBtYXRyaXguc2V0KDgsIHNpemUgLSBpIC0gMSwgbW9kLCB0cnVlKTtcblx0ICAgIH0gZWxzZSBpZiAoaSA8IDkpIHtcblx0ICAgICAgbWF0cml4LnNldCg4LCAxNSAtIGkgLSAxICsgMSwgbW9kLCB0cnVlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG1hdHJpeC5zZXQoOCwgMTUgLSBpIC0gMSwgbW9kLCB0cnVlKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBmaXhlZCBtb2R1bGVcblx0ICBtYXRyaXguc2V0KHNpemUgLSA4LCA4LCAxLCB0cnVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgZW5jb2RlZCBkYXRhIGJpdHMgdG8gbWF0cml4XG5cdCAqXG5cdCAqIEBwYXJhbSAge0JpdE1hdHJpeH0gbWF0cml4IE1vZHVsZXMgbWF0cml4XG5cdCAqIEBwYXJhbSAge0J1ZmZlcn0gICAgZGF0YSAgIERhdGEgY29kZXdvcmRzXG5cdCAqL1xuXHRmdW5jdGlvbiBzZXR1cERhdGEgKG1hdHJpeCwgZGF0YSkge1xuXHQgIHZhciBzaXplID0gbWF0cml4LnNpemU7XG5cdCAgdmFyIGluYyA9IC0xO1xuXHQgIHZhciByb3cgPSBzaXplIC0gMTtcblx0ICB2YXIgYml0SW5kZXggPSA3O1xuXHQgIHZhciBieXRlSW5kZXggPSAwO1xuXG5cdCAgZm9yICh2YXIgY29sID0gc2l6ZSAtIDE7IGNvbCA+IDA7IGNvbCAtPSAyKSB7XG5cdCAgICBpZiAoY29sID09PSA2KSBjb2wtLTtcblxuXHQgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCAyOyBjKyspIHtcblx0ICAgICAgICBpZiAoIW1hdHJpeC5pc1Jlc2VydmVkKHJvdywgY29sIC0gYykpIHtcblx0ICAgICAgICAgIHZhciBkYXJrID0gZmFsc2U7XG5cblx0ICAgICAgICAgIGlmIChieXRlSW5kZXggPCBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBkYXJrID0gKCgoZGF0YVtieXRlSW5kZXhdID4+PiBiaXRJbmRleCkgJiAxKSA9PT0gMSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIG1hdHJpeC5zZXQocm93LCBjb2wgLSBjLCBkYXJrKTtcblx0ICAgICAgICAgIGJpdEluZGV4LS07XG5cblx0ICAgICAgICAgIGlmIChiaXRJbmRleCA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgYnl0ZUluZGV4Kys7XG5cdCAgICAgICAgICAgIGJpdEluZGV4ID0gNztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByb3cgKz0gaW5jO1xuXG5cdCAgICAgIGlmIChyb3cgPCAwIHx8IHNpemUgPD0gcm93KSB7XG5cdCAgICAgICAgcm93IC09IGluYztcblx0ICAgICAgICBpbmMgPSAtaW5jO1xuXHQgICAgICAgIGJyZWFrXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIGVuY29kZWQgY29kZXdvcmRzIGZyb20gZGF0YSBpbnB1dFxuXHQgKlxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgdmVyc2lvbiAgICAgICAgICAgICAgUVIgQ29kZSB2ZXJzaW9uXG5cdCAqIEBwYXJhbSAge0Vycm9yQ29ycmVjdGlvbkxldmVsfSAgIGVycm9yQ29ycmVjdGlvbkxldmVsIEVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcblx0ICogQHBhcmFtICB7Qnl0ZURhdGF9IGRhdGEgICAgICAgICAgICAgICAgIERhdGEgaW5wdXRcblx0ICogQHJldHVybiB7QnVmZmVyfSAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlciBjb250YWluaW5nIGVuY29kZWQgY29kZXdvcmRzXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVEYXRhICh2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgc2VnbWVudHMpIHtcblx0ICAvLyBQcmVwYXJlIGRhdGEgYnVmZmVyXG5cdCAgdmFyIGJ1ZmZlciA9IG5ldyBCaXRCdWZmZXIoKTtcblxuXHQgIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIC8vIHByZWZpeCBkYXRhIHdpdGggbW9kZSBpbmRpY2F0b3IgKDQgYml0cylcblx0ICAgIGJ1ZmZlci5wdXQoZGF0YS5tb2RlLmJpdCwgNCk7XG5cblx0ICAgIC8vIFByZWZpeCBkYXRhIHdpdGggY2hhcmFjdGVyIGNvdW50IGluZGljYXRvci5cblx0ICAgIC8vIFRoZSBjaGFyYWN0ZXIgY291bnQgaW5kaWNhdG9yIGlzIGEgc3RyaW5nIG9mIGJpdHMgdGhhdCByZXByZXNlbnRzIHRoZVxuXHQgICAgLy8gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgYmVpbmcgZW5jb2RlZC5cblx0ICAgIC8vIFRoZSBjaGFyYWN0ZXIgY291bnQgaW5kaWNhdG9yIG11c3QgYmUgcGxhY2VkIGFmdGVyIHRoZSBtb2RlIGluZGljYXRvclxuXHQgICAgLy8gYW5kIG11c3QgYmUgYSBjZXJ0YWluIG51bWJlciBvZiBiaXRzIGxvbmcsIGRlcGVuZGluZyBvbiB0aGUgUVIgdmVyc2lvblxuXHQgICAgLy8gYW5kIGRhdGEgbW9kZVxuXHQgICAgLy8gQHNlZSB7QGxpbmsgTW9kZS5nZXRDaGFyQ291bnRJbmRpY2F0b3J9LlxuXHQgICAgYnVmZmVyLnB1dChkYXRhLmdldExlbmd0aCgpLCBNb2RlLmdldENoYXJDb3VudEluZGljYXRvcihkYXRhLm1vZGUsIHZlcnNpb24pKTtcblxuXHQgICAgLy8gYWRkIGJpbmFyeSBkYXRhIHNlcXVlbmNlIHRvIGJ1ZmZlclxuXHQgICAgZGF0YS53cml0ZShidWZmZXIpO1xuXHQgIH0pO1xuXG5cdCAgLy8gQ2FsY3VsYXRlIHJlcXVpcmVkIG51bWJlciBvZiBiaXRzXG5cdCAgdmFyIHRvdGFsQ29kZXdvcmRzID0gVXRpbHMuZ2V0U3ltYm9sVG90YWxDb2Rld29yZHModmVyc2lvbik7XG5cdCAgdmFyIGVjVG90YWxDb2Rld29yZHMgPSBFQ0NvZGUuZ2V0VG90YWxDb2Rld29yZHNDb3VudCh2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCk7XG5cdCAgdmFyIGRhdGFUb3RhbENvZGV3b3Jkc0JpdHMgPSAodG90YWxDb2Rld29yZHMgLSBlY1RvdGFsQ29kZXdvcmRzKSAqIDg7XG5cblx0ICAvLyBBZGQgYSB0ZXJtaW5hdG9yLlxuXHQgIC8vIElmIHRoZSBiaXQgc3RyaW5nIGlzIHNob3J0ZXIgdGhhbiB0aGUgdG90YWwgbnVtYmVyIG9mIHJlcXVpcmVkIGJpdHMsXG5cdCAgLy8gYSB0ZXJtaW5hdG9yIG9mIHVwIHRvIGZvdXIgMHMgbXVzdCBiZSBhZGRlZCB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc3RyaW5nLlxuXHQgIC8vIElmIHRoZSBiaXQgc3RyaW5nIGlzIG1vcmUgdGhhbiBmb3VyIGJpdHMgc2hvcnRlciB0aGFuIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgYml0cyxcblx0ICAvLyBhZGQgZm91ciAwcyB0byB0aGUgZW5kLlxuXHQgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgKyA0IDw9IGRhdGFUb3RhbENvZGV3b3Jkc0JpdHMpIHtcblx0ICAgIGJ1ZmZlci5wdXQoMCwgNCk7XG5cdCAgfVxuXG5cdCAgLy8gSWYgdGhlIGJpdCBzdHJpbmcgaXMgZmV3ZXIgdGhhbiBmb3VyIGJpdHMgc2hvcnRlciwgYWRkIG9ubHkgdGhlIG51bWJlciBvZiAwcyB0aGF0XG5cdCAgLy8gYXJlIG5lZWRlZCB0byByZWFjaCB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGJpdHMuXG5cblx0ICAvLyBBZnRlciBhZGRpbmcgdGhlIHRlcm1pbmF0b3IsIGlmIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgc3RyaW5nIGlzIG5vdCBhIG11bHRpcGxlIG9mIDgsXG5cdCAgLy8gcGFkIHRoZSBzdHJpbmcgb24gdGhlIHJpZ2h0IHdpdGggMHMgdG8gbWFrZSB0aGUgc3RyaW5nJ3MgbGVuZ3RoIGEgbXVsdGlwbGUgb2YgOC5cblx0ICB3aGlsZSAoYnVmZmVyLmdldExlbmd0aEluQml0cygpICUgOCAhPT0gMCkge1xuXHQgICAgYnVmZmVyLnB1dEJpdCgwKTtcblx0ICB9XG5cblx0ICAvLyBBZGQgcGFkIGJ5dGVzIGlmIHRoZSBzdHJpbmcgaXMgc3RpbGwgc2hvcnRlciB0aGFuIHRoZSB0b3RhbCBudW1iZXIgb2YgcmVxdWlyZWQgYml0cy5cblx0ICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB0byBmaWxsIHRoZSBkYXRhIGNhcGFjaXR5IG9mIHRoZSBzeW1ib2wgY29ycmVzcG9uZGluZyB0b1xuXHQgIC8vIHRoZSBWZXJzaW9uIGFuZCBFcnJvciBDb3JyZWN0aW9uIExldmVsIGJ5IGFkZGluZyB0aGUgUGFkIENvZGV3b3JkcyAxMTEwMTEwMCAoMHhFQylcblx0ICAvLyBhbmQgMDAwMTAwMDEgKDB4MTEpIGFsdGVybmF0ZWx5LlxuXHQgIHZhciByZW1haW5pbmdCeXRlID0gKGRhdGFUb3RhbENvZGV3b3Jkc0JpdHMgLSBidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkpIC8gODtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbWFpbmluZ0J5dGU7IGkrKykge1xuXHQgICAgYnVmZmVyLnB1dChpICUgMiA/IDB4MTEgOiAweEVDLCA4KTtcblx0ICB9XG5cblx0ICByZXR1cm4gY3JlYXRlQ29kZXdvcmRzKGJ1ZmZlciwgdmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpXG5cdH1cblxuXHQvKipcblx0ICogRW5jb2RlIGlucHV0IGRhdGEgd2l0aCBSZWVkLVNvbG9tb24gYW5kIHJldHVybiBjb2Rld29yZHMgd2l0aFxuXHQgKiByZWxhdGl2ZSBlcnJvciBjb3JyZWN0aW9uIGJpdHNcblx0ICpcblx0ICogQHBhcmFtICB7Qml0QnVmZmVyfSBiaXRCdWZmZXIgICAgICAgICAgICBEYXRhIHRvIGVuY29kZVxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgIHZlcnNpb24gICAgICAgICAgICAgIFFSIENvZGUgdmVyc2lvblxuXHQgKiBAcGFyYW0gIHtFcnJvckNvcnJlY3Rpb25MZXZlbH0gZXJyb3JDb3JyZWN0aW9uTGV2ZWwgRXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuXHQgKiBAcmV0dXJuIHtCdWZmZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlciBjb250YWluaW5nIGVuY29kZWQgY29kZXdvcmRzXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVDb2Rld29yZHMgKGJpdEJ1ZmZlciwgdmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcblx0ICAvLyBUb3RhbCBjb2Rld29yZHMgZm9yIHRoaXMgUVIgY29kZSB2ZXJzaW9uIChEYXRhICsgRXJyb3IgY29ycmVjdGlvbilcblx0ICB2YXIgdG90YWxDb2Rld29yZHMgPSBVdGlscy5nZXRTeW1ib2xUb3RhbENvZGV3b3Jkcyh2ZXJzaW9uKTtcblxuXHQgIC8vIFRvdGFsIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xuXHQgIHZhciBlY1RvdGFsQ29kZXdvcmRzID0gRUNDb2RlLmdldFRvdGFsQ29kZXdvcmRzQ291bnQodmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuXG5cdCAgLy8gVG90YWwgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzXG5cdCAgdmFyIGRhdGFUb3RhbENvZGV3b3JkcyA9IHRvdGFsQ29kZXdvcmRzIC0gZWNUb3RhbENvZGV3b3JkcztcblxuXHQgIC8vIFRvdGFsIG51bWJlciBvZiBibG9ja3Ncblx0ICB2YXIgZWNUb3RhbEJsb2NrcyA9IEVDQ29kZS5nZXRCbG9ja3NDb3VudCh2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCk7XG5cblx0ICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgYmxvY2tzIGVhY2ggZ3JvdXAgc2hvdWxkIGNvbnRhaW5cblx0ICB2YXIgYmxvY2tzSW5Hcm91cDIgPSB0b3RhbENvZGV3b3JkcyAlIGVjVG90YWxCbG9ja3M7XG5cdCAgdmFyIGJsb2Nrc0luR3JvdXAxID0gZWNUb3RhbEJsb2NrcyAtIGJsb2Nrc0luR3JvdXAyO1xuXG5cdCAgdmFyIHRvdGFsQ29kZXdvcmRzSW5Hcm91cDEgPSBNYXRoLmZsb29yKHRvdGFsQ29kZXdvcmRzIC8gZWNUb3RhbEJsb2Nrcyk7XG5cblx0ICB2YXIgZGF0YUNvZGV3b3Jkc0luR3JvdXAxID0gTWF0aC5mbG9vcihkYXRhVG90YWxDb2Rld29yZHMgLyBlY1RvdGFsQmxvY2tzKTtcblx0ICB2YXIgZGF0YUNvZGV3b3Jkc0luR3JvdXAyID0gZGF0YUNvZGV3b3Jkc0luR3JvdXAxICsgMTtcblxuXHQgIC8vIE51bWJlciBvZiBFQyBjb2Rld29yZHMgaXMgdGhlIHNhbWUgZm9yIGJvdGggZ3JvdXBzXG5cdCAgdmFyIGVjQ291bnQgPSB0b3RhbENvZGV3b3Jkc0luR3JvdXAxIC0gZGF0YUNvZGV3b3Jkc0luR3JvdXAxO1xuXG5cdCAgLy8gSW5pdGlhbGl6ZSBhIFJlZWQtU29sb21vbiBlbmNvZGVyIHdpdGggYSBnZW5lcmF0b3IgcG9seW5vbWlhbCBvZiBkZWdyZWUgZWNDb3VudFxuXHQgIHZhciBycyA9IG5ldyBSZWVkU29sb21vbkVuY29kZXIoZWNDb3VudCk7XG5cblx0ICB2YXIgb2Zmc2V0ID0gMDtcblx0ICB2YXIgZGNEYXRhID0gbmV3IEFycmF5KGVjVG90YWxCbG9ja3MpO1xuXHQgIHZhciBlY0RhdGEgPSBuZXcgQXJyYXkoZWNUb3RhbEJsb2Nrcyk7XG5cdCAgdmFyIG1heERhdGFTaXplID0gMDtcblx0ICB2YXIgYnVmZmVyID0gQnVmZmVyVXRpbC5mcm9tKGJpdEJ1ZmZlci5idWZmZXIpO1xuXG5cdCAgLy8gRGl2aWRlIHRoZSBidWZmZXIgaW50byB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGJsb2Nrc1xuXHQgIGZvciAodmFyIGIgPSAwOyBiIDwgZWNUb3RhbEJsb2NrczsgYisrKSB7XG5cdCAgICB2YXIgZGF0YVNpemUgPSBiIDwgYmxvY2tzSW5Hcm91cDEgPyBkYXRhQ29kZXdvcmRzSW5Hcm91cDEgOiBkYXRhQ29kZXdvcmRzSW5Hcm91cDI7XG5cblx0ICAgIC8vIGV4dHJhY3QgYSBibG9jayBvZiBkYXRhIGZyb20gYnVmZmVyXG5cdCAgICBkY0RhdGFbYl0gPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBkYXRhU2l6ZSk7XG5cblx0ICAgIC8vIENhbGN1bGF0ZSBFQyBjb2Rld29yZHMgZm9yIHRoaXMgZGF0YSBibG9ja1xuXHQgICAgZWNEYXRhW2JdID0gcnMuZW5jb2RlKGRjRGF0YVtiXSk7XG5cblx0ICAgIG9mZnNldCArPSBkYXRhU2l6ZTtcblx0ICAgIG1heERhdGFTaXplID0gTWF0aC5tYXgobWF4RGF0YVNpemUsIGRhdGFTaXplKTtcblx0ICB9XG5cblx0ICAvLyBDcmVhdGUgZmluYWwgZGF0YVxuXHQgIC8vIEludGVybGVhdmUgdGhlIGRhdGEgYW5kIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzIGZyb20gZWFjaCBibG9ja1xuXHQgIHZhciBkYXRhID0gQnVmZmVyVXRpbC5hbGxvYyh0b3RhbENvZGV3b3Jkcyk7XG5cdCAgdmFyIGluZGV4ID0gMDtcblx0ICB2YXIgaSwgcjtcblxuXHQgIC8vIEFkZCBkYXRhIGNvZGV3b3Jkc1xuXHQgIGZvciAoaSA9IDA7IGkgPCBtYXhEYXRhU2l6ZTsgaSsrKSB7XG5cdCAgICBmb3IgKHIgPSAwOyByIDwgZWNUb3RhbEJsb2NrczsgcisrKSB7XG5cdCAgICAgIGlmIChpIDwgZGNEYXRhW3JdLmxlbmd0aCkge1xuXHQgICAgICAgIGRhdGFbaW5kZXgrK10gPSBkY0RhdGFbcl1baV07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBBcHBlZCBFQyBjb2Rld29yZHNcblx0ICBmb3IgKGkgPSAwOyBpIDwgZWNDb3VudDsgaSsrKSB7XG5cdCAgICBmb3IgKHIgPSAwOyByIDwgZWNUb3RhbEJsb2NrczsgcisrKSB7XG5cdCAgICAgIGRhdGFbaW5kZXgrK10gPSBlY0RhdGFbcl1baV07XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGRhdGFcblx0fVxuXG5cdC8qKlxuXHQgKiBCdWlsZCBRUiBDb2RlIHN5bWJvbFxuXHQgKlxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgICAgICAgICAgICAgICAgIElucHV0IHN0cmluZ1xuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHZlcnNpb24gICAgICAgICAgICAgIFFSIENvZGUgdmVyc2lvblxuXHQgKiBAcGFyYW0gIHtFcnJvckNvcnJldGlvbkxldmVsfSBlcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvciBsZXZlbFxuXHQgKiBAcGFyYW0gIHtNYXNrUGF0dGVybn0gbWFza1BhdHRlcm4gICAgIE1hc2sgcGF0dGVyblxuXHQgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHN5bWJvbCBkYXRhXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVTeW1ib2wgKGRhdGEsIHZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsLCBtYXNrUGF0dGVybikge1xuXHQgIHZhciBzZWdtZW50cztcblxuXHQgIGlmIChpc0FycmF5KGRhdGEpKSB7XG5cdCAgICBzZWdtZW50cyA9IFNlZ21lbnRzLmZyb21BcnJheShkYXRhKTtcblx0ICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuXHQgICAgdmFyIGVzdGltYXRlZFZlcnNpb24gPSB2ZXJzaW9uO1xuXG5cdCAgICBpZiAoIWVzdGltYXRlZFZlcnNpb24pIHtcblx0ICAgICAgdmFyIHJhd1NlZ21lbnRzID0gU2VnbWVudHMucmF3U3BsaXQoZGF0YSk7XG5cblx0ICAgICAgLy8gRXN0aW1hdGUgYmVzdCB2ZXJzaW9uIHRoYXQgY2FuIGNvbnRhaW4gcmF3IHNwbGl0dGVkIHNlZ21lbnRzXG5cdCAgICAgIGVzdGltYXRlZFZlcnNpb24gPSBWZXJzaW9uLmdldEJlc3RWZXJzaW9uRm9yRGF0YShyYXdTZWdtZW50cyxcblx0ICAgICAgICBlcnJvckNvcnJlY3Rpb25MZXZlbCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIEJ1aWxkIG9wdGltaXplZCBzZWdtZW50c1xuXHQgICAgLy8gSWYgZXN0aW1hdGVkIHZlcnNpb24gaXMgdW5kZWZpbmVkLCB0cnkgd2l0aCB0aGUgaGlnaGVzdCB2ZXJzaW9uXG5cdCAgICBzZWdtZW50cyA9IFNlZ21lbnRzLmZyb21TdHJpbmcoZGF0YSwgZXN0aW1hdGVkVmVyc2lvbiB8fCA0MCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhJylcblx0ICB9XG5cblx0ICAvLyBHZXQgdGhlIG1pbiB2ZXJzaW9uIHRoYXQgY2FuIGNvbnRhaW4gZGF0YVxuXHQgIHZhciBiZXN0VmVyc2lvbiA9IFZlcnNpb24uZ2V0QmVzdFZlcnNpb25Gb3JEYXRhKHNlZ21lbnRzLFxuXHQgICAgICBlcnJvckNvcnJlY3Rpb25MZXZlbCk7XG5cblx0ICAvLyBJZiBubyB2ZXJzaW9uIGlzIGZvdW5kLCBkYXRhIGNhbm5vdCBiZSBzdG9yZWRcblx0ICBpZiAoIWJlc3RWZXJzaW9uKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhbW91bnQgb2YgZGF0YSBpcyB0b28gYmlnIHRvIGJlIHN0b3JlZCBpbiBhIFFSIENvZGUnKVxuXHQgIH1cblxuXHQgIC8vIElmIG5vdCBzcGVjaWZpZWQsIHVzZSBtaW4gdmVyc2lvbiBhcyBkZWZhdWx0XG5cdCAgaWYgKCF2ZXJzaW9uKSB7XG5cdCAgICB2ZXJzaW9uID0gYmVzdFZlcnNpb247XG5cblx0ICAvLyBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIHZlcnNpb24gY2FuIGNvbnRhaW4gdGhlIGRhdGFcblx0ICB9IGVsc2UgaWYgKHZlcnNpb24gPCBiZXN0VmVyc2lvbikge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdcXG4nICtcblx0ICAgICAgJ1RoZSBjaG9zZW4gUVIgQ29kZSB2ZXJzaW9uIGNhbm5vdCBjb250YWluIHRoaXMgYW1vdW50IG9mIGRhdGEuXFxuJyArXG5cdCAgICAgICdNaW5pbXVtIHZlcnNpb24gcmVxdWlyZWQgdG8gc3RvcmUgY3VycmVudCBkYXRhIGlzOiAnICsgYmVzdFZlcnNpb24gKyAnLlxcbidcblx0ICAgIClcblx0ICB9XG5cblx0ICB2YXIgZGF0YUJpdHMgPSBjcmVhdGVEYXRhKHZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsLCBzZWdtZW50cyk7XG5cblx0ICAvLyBBbGxvY2F0ZSBtYXRyaXggYnVmZmVyXG5cdCAgdmFyIG1vZHVsZUNvdW50ID0gVXRpbHMuZ2V0U3ltYm9sU2l6ZSh2ZXJzaW9uKTtcblx0ICB2YXIgbW9kdWxlcyA9IG5ldyBCaXRNYXRyaXgobW9kdWxlQ291bnQpO1xuXG5cdCAgLy8gQWRkIGZ1bmN0aW9uIG1vZHVsZXNcblx0ICBzZXR1cEZpbmRlclBhdHRlcm4obW9kdWxlcywgdmVyc2lvbik7XG5cdCAgc2V0dXBUaW1pbmdQYXR0ZXJuKG1vZHVsZXMpO1xuXHQgIHNldHVwQWxpZ25tZW50UGF0dGVybihtb2R1bGVzLCB2ZXJzaW9uKTtcblxuXHQgIC8vIEFkZCB0ZW1wb3JhcnkgZHVtbXkgYml0cyBmb3IgZm9ybWF0IGluZm8ganVzdCB0byBzZXQgdGhlbSBhcyByZXNlcnZlZC5cblx0ICAvLyBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IHRoZXNlIGJpdHMgZnJvbSBiZWluZyBtYXNrZWQgYnkge0BsaW5rIE1hc2tQYXR0ZXJuLmFwcGx5TWFza31cblx0ICAvLyBzaW5jZSB0aGUgbWFza2luZyBvcGVyYXRpb24gbXVzdCBiZSBwZXJmb3JtZWQgb25seSBvbiB0aGUgZW5jb2RpbmcgcmVnaW9uLlxuXHQgIC8vIFRoZXNlIGJsb2NrcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggY29ycmVjdCB2YWx1ZXMgbGF0ZXIgaW4gY29kZS5cblx0ICBzZXR1cEZvcm1hdEluZm8obW9kdWxlcywgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIDApO1xuXG5cdCAgaWYgKHZlcnNpb24gPj0gNykge1xuXHQgICAgc2V0dXBWZXJzaW9uSW5mbyhtb2R1bGVzLCB2ZXJzaW9uKTtcblx0ICB9XG5cblx0ICAvLyBBZGQgZGF0YSBjb2Rld29yZHNcblx0ICBzZXR1cERhdGEobW9kdWxlcywgZGF0YUJpdHMpO1xuXG5cdCAgaWYgKGlzTmFOKG1hc2tQYXR0ZXJuKSkge1xuXHQgICAgLy8gRmluZCBiZXN0IG1hc2sgcGF0dGVyblxuXHQgICAgbWFza1BhdHRlcm4gPSBNYXNrUGF0dGVybi5nZXRCZXN0TWFzayhtb2R1bGVzLFxuXHQgICAgICBzZXR1cEZvcm1hdEluZm8uYmluZChudWxsLCBtb2R1bGVzLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkpO1xuXHQgIH1cblxuXHQgIC8vIEFwcGx5IG1hc2sgcGF0dGVyblxuXHQgIE1hc2tQYXR0ZXJuLmFwcGx5TWFzayhtYXNrUGF0dGVybiwgbW9kdWxlcyk7XG5cblx0ICAvLyBSZXBsYWNlIGZvcm1hdCBpbmZvIGJpdHMgd2l0aCBjb3JyZWN0IHZhbHVlc1xuXHQgIHNldHVwRm9ybWF0SW5mbyhtb2R1bGVzLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgbWFza1BhdHRlcm4pO1xuXG5cdCAgcmV0dXJuIHtcblx0ICAgIG1vZHVsZXM6IG1vZHVsZXMsXG5cdCAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuXHQgICAgZXJyb3JDb3JyZWN0aW9uTGV2ZWw6IGVycm9yQ29ycmVjdGlvbkxldmVsLFxuXHQgICAgbWFza1BhdHRlcm46IG1hc2tQYXR0ZXJuLFxuXHQgICAgc2VnbWVudHM6IHNlZ21lbnRzXG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFFSIENvZGVcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gZGF0YSAgICAgICAgICAgICAgICAgSW5wdXQgZGF0YVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICBPcHRpb25hbCBjb25maWd1cmF0aW9uc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy52ZXJzaW9uICAgICAgICAgICAgICBRUiBDb2RlIHZlcnNpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgRXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnRvU0pJU0Z1bmMgICAgICAgICBIZWxwZXIgZnVuYyB0byBjb252ZXJ0IHV0ZjggdG8gc2ppc1xuXHQgKi9cblx0ZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUgKGRhdGEsIG9wdGlvbnMpIHtcblx0ICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnIHx8IGRhdGEgPT09ICcnKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlucHV0IHRleHQnKVxuXHQgIH1cblxuXHQgIHZhciBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVDTGV2ZWwuTTtcblx0ICB2YXIgdmVyc2lvbjtcblx0ICB2YXIgbWFzaztcblxuXHQgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIC8vIFVzZSBoaWdoZXIgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCBhcyBkZWZhdWx0XG5cdCAgICBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVDTGV2ZWwuZnJvbShvcHRpb25zLmVycm9yQ29ycmVjdGlvbkxldmVsLCBFQ0xldmVsLk0pO1xuXHQgICAgdmVyc2lvbiA9IFZlcnNpb24uZnJvbShvcHRpb25zLnZlcnNpb24pO1xuXHQgICAgbWFzayA9IE1hc2tQYXR0ZXJuLmZyb20ob3B0aW9ucy5tYXNrUGF0dGVybik7XG5cblx0ICAgIGlmIChvcHRpb25zLnRvU0pJU0Z1bmMpIHtcblx0ICAgICAgVXRpbHMuc2V0VG9TSklTRnVuY3Rpb24ob3B0aW9ucy50b1NKSVNGdW5jKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gY3JlYXRlU3ltYm9sKGRhdGEsIHZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsLCBtYXNrKVxuXHR9O1xuXG5cdH0se1wiLi4vdXRpbHMvYnVmZmVyXCI6MjgsXCIuL2FsaWdubWVudC1wYXR0ZXJuXCI6MixcIi4vYml0LWJ1ZmZlclwiOjQsXCIuL2JpdC1tYXRyaXhcIjo1LFwiLi9lcnJvci1jb3JyZWN0aW9uLWNvZGVcIjo3LFwiLi9lcnJvci1jb3JyZWN0aW9uLWxldmVsXCI6OCxcIi4vZmluZGVyLXBhdHRlcm5cIjo5LFwiLi9mb3JtYXQtaW5mb1wiOjEwLFwiLi9tYXNrLXBhdHRlcm5cIjoxMyxcIi4vbW9kZVwiOjE0LFwiLi9yZWVkLXNvbG9tb24tZW5jb2RlclwiOjE4LFwiLi9zZWdtZW50c1wiOjIwLFwiLi91dGlsc1wiOjIxLFwiLi92ZXJzaW9uXCI6MjMsXCJpc2FycmF5XCI6MzN9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cdHZhciBCdWZmZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbHMvYnVmZmVyJyk7XG5cdHZhciBQb2x5bm9taWFsID0gcmVxdWlyZSgnLi9wb2x5bm9taWFsJyk7XG5cdHZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cblx0ZnVuY3Rpb24gUmVlZFNvbG9tb25FbmNvZGVyIChkZWdyZWUpIHtcblx0ICB0aGlzLmdlblBvbHkgPSB1bmRlZmluZWQ7XG5cdCAgdGhpcy5kZWdyZWUgPSBkZWdyZWU7XG5cblx0ICBpZiAodGhpcy5kZWdyZWUpIHRoaXMuaW5pdGlhbGl6ZSh0aGlzLmRlZ3JlZSk7XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgZW5jb2Rlci5cblx0ICogVGhlIGlucHV0IHBhcmFtIHNob3VsZCBjb3JyZXNwb25kIHRvIHRoZSBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSAge051bWJlcn0gZGVncmVlXG5cdCAqL1xuXHRSZWVkU29sb21vbkVuY29kZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiBpbml0aWFsaXplIChkZWdyZWUpIHtcblx0ICAvLyBjcmVhdGUgYW4gaXJyZWR1Y2libGUgZ2VuZXJhdG9yIHBvbHlub21pYWxcblx0ICB0aGlzLmRlZ3JlZSA9IGRlZ3JlZTtcblx0ICB0aGlzLmdlblBvbHkgPSBQb2x5bm9taWFsLmdlbmVyYXRlRUNQb2x5bm9taWFsKHRoaXMuZGVncmVlKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5jb2RlcyBhIGNodW5rIG9mIGRhdGFcblx0ICpcblx0ICogQHBhcmFtICB7QnVmZmVyfSBkYXRhIEJ1ZmZlciBjb250YWluaW5nIGlucHV0IGRhdGFcblx0ICogQHJldHVybiB7QnVmZmVyfSAgICAgIEJ1ZmZlciBjb250YWluaW5nIGVuY29kZWQgZGF0YVxuXHQgKi9cblx0UmVlZFNvbG9tb25FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUgKGRhdGEpIHtcblx0ICBpZiAoIXRoaXMuZ2VuUG9seSkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGVyIG5vdCBpbml0aWFsaXplZCcpXG5cdCAgfVxuXG5cdCAgLy8gQ2FsY3VsYXRlIEVDIGZvciB0aGlzIGRhdGEgYmxvY2tcblx0ICAvLyBleHRlbmRzIGRhdGEgc2l6ZSB0byBkYXRhK2dlblBvbHkgc2l6ZVxuXHQgIHZhciBwYWQgPSBCdWZmZXJVdGlsLmFsbG9jKHRoaXMuZGVncmVlKTtcblx0ICB2YXIgcGFkZGVkRGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RhdGEsIHBhZF0sIGRhdGEubGVuZ3RoICsgdGhpcy5kZWdyZWUpO1xuXG5cdCAgLy8gVGhlIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzIGFyZSB0aGUgcmVtYWluZGVyIGFmdGVyIGRpdmlkaW5nIHRoZSBkYXRhIGNvZGV3b3Jkc1xuXHQgIC8vIGJ5IGEgZ2VuZXJhdG9yIHBvbHlub21pYWxcblx0ICB2YXIgcmVtYWluZGVyID0gUG9seW5vbWlhbC5tb2QocGFkZGVkRGF0YSwgdGhpcy5nZW5Qb2x5KTtcblxuXHQgIC8vIHJldHVybiBFQyBkYXRhIGJsb2NrcyAobGFzdCBuIGJ5dGUsIHdoZXJlIG4gaXMgdGhlIGRlZ3JlZSBvZiBnZW5Qb2x5KVxuXHQgIC8vIElmIGNvZWZmaWNpZW50cyBudW1iZXIgaW4gcmVtYWluZGVyIGFyZSBsZXNzIHRoYW4gZ2VuUG9seSBkZWdyZWUsXG5cdCAgLy8gcGFkIHdpdGggMHMgdG8gdGhlIGxlZnQgdG8gcmVhY2ggdGhlIG5lZWRlZCBudW1iZXIgb2YgY29lZmZpY2llbnRzXG5cdCAgdmFyIHN0YXJ0ID0gdGhpcy5kZWdyZWUgLSByZW1haW5kZXIubGVuZ3RoO1xuXHQgIGlmIChzdGFydCA+IDApIHtcblx0ICAgIHZhciBidWZmID0gQnVmZmVyVXRpbC5hbGxvYyh0aGlzLmRlZ3JlZSk7XG5cdCAgICByZW1haW5kZXIuY29weShidWZmLCBzdGFydCk7XG5cblx0ICAgIHJldHVybiBidWZmXG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlbWFpbmRlclxuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gUmVlZFNvbG9tb25FbmNvZGVyO1xuXG5cdH0se1wiLi4vdXRpbHMvYnVmZmVyXCI6MjgsXCIuL3BvbHlub21pYWxcIjoxNixcImJ1ZmZlclwiOjMwfV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHR2YXIgbnVtZXJpYyA9ICdbMC05XSsnO1xuXHR2YXIgYWxwaGFudW1lcmljID0gJ1tBLVogJCUqK1xcXFwtLi86XSsnO1xuXHR2YXIga2FuamkgPSAnKD86W3UzMDAwLXUzMDNGXXxbdTMwNDAtdTMwOUZdfFt1MzBBMC11MzBGRl18JyArXG5cdCAgJ1t1RkYwMC11RkZFRl18W3U0RTAwLXU5RkFGXXxbdTI2MDUtdTI2MDZdfFt1MjE5MC11MjE5NV18dTIwM0J8JyArXG5cdCAgJ1t1MjAxMHUyMDE1dTIwMTh1MjAxOXUyMDI1dTIwMjZ1MjAxQ3UyMDFEdTIyMjV1MjI2MF18JyArXG5cdCAgJ1t1MDM5MS11MDQ1MV18W3UwMEE3dTAwQTh1MDBCMXUwMEI0dTAwRDd1MDBGN10pKyc7XG5cdGthbmppID0ga2FuamkucmVwbGFjZSgvdS9nLCAnXFxcXHUnKTtcblxuXHR2YXIgYnl0ZSA9ICcoPzooPyFbQS1aMC05ICQlKitcXFxcLS4vOl18JyArIGthbmppICsgJykoPzoufFtcXHJcXG5dKSkrJztcblxuXHRleHBvcnRzLktBTkpJID0gbmV3IFJlZ0V4cChrYW5qaSwgJ2cnKTtcblx0ZXhwb3J0cy5CWVRFX0tBTkpJID0gbmV3IFJlZ0V4cCgnW15BLVowLTkgJCUqK1xcXFwtLi86XSsnLCAnZycpO1xuXHRleHBvcnRzLkJZVEUgPSBuZXcgUmVnRXhwKGJ5dGUsICdnJyk7XG5cdGV4cG9ydHMuTlVNRVJJQyA9IG5ldyBSZWdFeHAobnVtZXJpYywgJ2cnKTtcblx0ZXhwb3J0cy5BTFBIQU5VTUVSSUMgPSBuZXcgUmVnRXhwKGFscGhhbnVtZXJpYywgJ2cnKTtcblxuXHR2YXIgVEVTVF9LQU5KSSA9IG5ldyBSZWdFeHAoJ14nICsga2FuamkgKyAnJCcpO1xuXHR2YXIgVEVTVF9OVU1FUklDID0gbmV3IFJlZ0V4cCgnXicgKyBudW1lcmljICsgJyQnKTtcblx0dmFyIFRFU1RfQUxQSEFOVU1FUklDID0gbmV3IFJlZ0V4cCgnXltBLVowLTkgJCUqK1xcXFwtLi86XSskJyk7XG5cblx0ZXhwb3J0cy50ZXN0S2FuamkgPSBmdW5jdGlvbiB0ZXN0S2FuamkgKHN0cikge1xuXHQgIHJldHVybiBURVNUX0tBTkpJLnRlc3Qoc3RyKVxuXHR9O1xuXG5cdGV4cG9ydHMudGVzdE51bWVyaWMgPSBmdW5jdGlvbiB0ZXN0TnVtZXJpYyAoc3RyKSB7XG5cdCAgcmV0dXJuIFRFU1RfTlVNRVJJQy50ZXN0KHN0cilcblx0fTtcblxuXHRleHBvcnRzLnRlc3RBbHBoYW51bWVyaWMgPSBmdW5jdGlvbiB0ZXN0QWxwaGFudW1lcmljIChzdHIpIHtcblx0ICByZXR1cm4gVEVTVF9BTFBIQU5VTUVSSUMudGVzdChzdHIpXG5cdH07XG5cblx0fSx7fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHR2YXIgTW9kZSA9IHJlcXVpcmUoJy4vbW9kZScpO1xuXHR2YXIgTnVtZXJpY0RhdGEgPSByZXF1aXJlKCcuL251bWVyaWMtZGF0YScpO1xuXHR2YXIgQWxwaGFudW1lcmljRGF0YSA9IHJlcXVpcmUoJy4vYWxwaGFudW1lcmljLWRhdGEnKTtcblx0dmFyIEJ5dGVEYXRhID0gcmVxdWlyZSgnLi9ieXRlLWRhdGEnKTtcblx0dmFyIEthbmppRGF0YSA9IHJlcXVpcmUoJy4va2FuamktZGF0YScpO1xuXHR2YXIgUmVnZXggPSByZXF1aXJlKCcuL3JlZ2V4Jyk7XG5cdHZhciBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblx0dmFyIGRpamtzdHJhID0gcmVxdWlyZSgnZGlqa3N0cmFqcycpO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIFVURjggYnl0ZSBsZW5ndGhcblx0ICpcblx0ICogQHBhcmFtICB7U3RyaW5nfSBzdHIgSW5wdXQgc3RyaW5nXG5cdCAqIEByZXR1cm4ge051bWJlcn0gICAgIE51bWJlciBvZiBieXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRTdHJpbmdCeXRlTGVuZ3RoIChzdHIpIHtcblx0ICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpLmxlbmd0aFxuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBhIGxpc3Qgb2Ygc2VnbWVudHMgb2YgdGhlIHNwZWNpZmllZCBtb2RlXG5cdCAqIGZyb20gYSBzdHJpbmdcblx0ICpcblx0ICogQHBhcmFtICB7TW9kZX0gICBtb2RlIFNlZ21lbnQgbW9kZVxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9IHN0ciAgU3RyaW5nIHRvIHByb2Nlc3Ncblx0ICogQHJldHVybiB7QXJyYXl9ICAgICAgIEFycmF5IG9mIG9iamVjdCB3aXRoIHNlZ21lbnRzIGRhdGFcblx0ICovXG5cdGZ1bmN0aW9uIGdldFNlZ21lbnRzIChyZWdleCwgbW9kZSwgc3RyKSB7XG5cdCAgdmFyIHNlZ21lbnRzID0gW107XG5cdCAgdmFyIHJlc3VsdDtcblxuXHQgIHdoaWxlICgocmVzdWx0ID0gcmVnZXguZXhlYyhzdHIpKSAhPT0gbnVsbCkge1xuXHQgICAgc2VnbWVudHMucHVzaCh7XG5cdCAgICAgIGRhdGE6IHJlc3VsdFswXSxcblx0ICAgICAgaW5kZXg6IHJlc3VsdC5pbmRleCxcblx0ICAgICAgbW9kZTogbW9kZSxcblx0ICAgICAgbGVuZ3RoOiByZXN1bHRbMF0ubGVuZ3RoXG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICByZXR1cm4gc2VnbWVudHNcblx0fVxuXG5cdC8qKlxuXHQgKiBFeHRyYWN0cyBhIHNlcmllcyBvZiBzZWdtZW50cyB3aXRoIHRoZSBhcHByb3ByaWF0ZVxuXHQgKiBtb2RlcyBmcm9tIGEgc3RyaW5nXG5cdCAqXG5cdCAqIEBwYXJhbSAge1N0cmluZ30gZGF0YVN0ciBJbnB1dCBzdHJpbmdcblx0ICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIEFycmF5IG9mIG9iamVjdCB3aXRoIHNlZ21lbnRzIGRhdGFcblx0ICovXG5cdGZ1bmN0aW9uIGdldFNlZ21lbnRzRnJvbVN0cmluZyAoZGF0YVN0cikge1xuXHQgIHZhciBudW1TZWdzID0gZ2V0U2VnbWVudHMoUmVnZXguTlVNRVJJQywgTW9kZS5OVU1FUklDLCBkYXRhU3RyKTtcblx0ICB2YXIgYWxwaGFOdW1TZWdzID0gZ2V0U2VnbWVudHMoUmVnZXguQUxQSEFOVU1FUklDLCBNb2RlLkFMUEhBTlVNRVJJQywgZGF0YVN0cik7XG5cdCAgdmFyIGJ5dGVTZWdzO1xuXHQgIHZhciBrYW5qaVNlZ3M7XG5cblx0ICBpZiAoVXRpbHMuaXNLYW5qaU1vZGVFbmFibGVkKCkpIHtcblx0ICAgIGJ5dGVTZWdzID0gZ2V0U2VnbWVudHMoUmVnZXguQllURSwgTW9kZS5CWVRFLCBkYXRhU3RyKTtcblx0ICAgIGthbmppU2VncyA9IGdldFNlZ21lbnRzKFJlZ2V4LktBTkpJLCBNb2RlLktBTkpJLCBkYXRhU3RyKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgYnl0ZVNlZ3MgPSBnZXRTZWdtZW50cyhSZWdleC5CWVRFX0tBTkpJLCBNb2RlLkJZVEUsIGRhdGFTdHIpO1xuXHQgICAga2FuamlTZWdzID0gW107XG5cdCAgfVxuXG5cdCAgdmFyIHNlZ3MgPSBudW1TZWdzLmNvbmNhdChhbHBoYU51bVNlZ3MsIGJ5dGVTZWdzLCBrYW5qaVNlZ3MpO1xuXG5cdCAgcmV0dXJuIHNlZ3Ncblx0ICAgIC5zb3J0KGZ1bmN0aW9uIChzMSwgczIpIHtcblx0ICAgICAgcmV0dXJuIHMxLmluZGV4IC0gczIuaW5kZXhcblx0ICAgIH0pXG5cdCAgICAubWFwKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkYXRhOiBvYmouZGF0YSxcblx0ICAgICAgICBtb2RlOiBvYmoubW9kZSxcblx0ICAgICAgICBsZW5ndGg6IG9iai5sZW5ndGhcblx0ICAgICAgfVxuXHQgICAgfSlcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGhvdyBtYW55IGJpdHMgYXJlIG5lZWRlZCB0byBlbmNvZGUgYSBzdHJpbmcgb2Zcblx0ICogc3BlY2lmaWVkIGxlbmd0aCB3aXRoIHRoZSBzcGVjaWZpZWQgbW9kZVxuXHQgKlxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IGxlbmd0aCBTdHJpbmcgbGVuZ3RoXG5cdCAqIEBwYXJhbSAge01vZGV9IG1vZGUgICAgIFNlZ21lbnQgbW9kZVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICBCaXQgbGVuZ3RoXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRTZWdtZW50Qml0c0xlbmd0aCAobGVuZ3RoLCBtb2RlKSB7XG5cdCAgc3dpdGNoIChtb2RlKSB7XG5cdCAgICBjYXNlIE1vZGUuTlVNRVJJQzpcblx0ICAgICAgcmV0dXJuIE51bWVyaWNEYXRhLmdldEJpdHNMZW5ndGgobGVuZ3RoKVxuXHQgICAgY2FzZSBNb2RlLkFMUEhBTlVNRVJJQzpcblx0ICAgICAgcmV0dXJuIEFscGhhbnVtZXJpY0RhdGEuZ2V0Qml0c0xlbmd0aChsZW5ndGgpXG5cdCAgICBjYXNlIE1vZGUuS0FOSkk6XG5cdCAgICAgIHJldHVybiBLYW5qaURhdGEuZ2V0Qml0c0xlbmd0aChsZW5ndGgpXG5cdCAgICBjYXNlIE1vZGUuQllURTpcblx0ICAgICAgcmV0dXJuIEJ5dGVEYXRhLmdldEJpdHNMZW5ndGgobGVuZ3RoKVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBNZXJnZXMgYWRqYWNlbnQgc2VnbWVudHMgd2hpY2ggaGF2ZSB0aGUgc2FtZSBtb2RlXG5cdCAqXG5cdCAqIEBwYXJhbSAge0FycmF5fSBzZWdzIEFycmF5IG9mIG9iamVjdCB3aXRoIHNlZ21lbnRzIGRhdGFcblx0ICogQHJldHVybiB7QXJyYXl9ICAgICAgQXJyYXkgb2Ygb2JqZWN0IHdpdGggc2VnbWVudHMgZGF0YVxuXHQgKi9cblx0ZnVuY3Rpb24gbWVyZ2VTZWdtZW50cyAoc2Vncykge1xuXHQgIHJldHVybiBzZWdzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXJyKSB7XG5cdCAgICB2YXIgcHJldlNlZyA9IGFjYy5sZW5ndGggLSAxID49IDAgPyBhY2NbYWNjLmxlbmd0aCAtIDFdIDogbnVsbDtcblx0ICAgIGlmIChwcmV2U2VnICYmIHByZXZTZWcubW9kZSA9PT0gY3Vyci5tb2RlKSB7XG5cdCAgICAgIGFjY1thY2MubGVuZ3RoIC0gMV0uZGF0YSArPSBjdXJyLmRhdGE7XG5cdCAgICAgIHJldHVybiBhY2Ncblx0ICAgIH1cblxuXHQgICAgYWNjLnB1c2goY3Vycik7XG5cdCAgICByZXR1cm4gYWNjXG5cdCAgfSwgW10pXG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgbGlzdCBvZiBhbGwgcG9zc2libGUgbm9kZXMgY29tYmluYXRpb24gd2hpY2hcblx0ICogd2lsbCBiZSB1c2VkIHRvIGJ1aWxkIGEgc2VnbWVudHMgZ3JhcGguXG5cdCAqXG5cdCAqIE5vZGVzIGFyZSBkaXZpZGVkIGJ5IGdyb3Vwcy4gRWFjaCBncm91cCB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIGFsbCB0aGUgbW9kZXNcblx0ICogaW4gd2hpY2ggaXMgcG9zc2libGUgdG8gZW5jb2RlIHRoZSBnaXZlbiB0ZXh0LlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZSB0aGUgdGV4dCAnMTIzNDUnIGNhbiBiZSBlbmNvZGVkIGFzIE51bWVyaWMsIEFscGhhbnVtZXJpYyBvciBCeXRlLlxuXHQgKiBUaGUgZ3JvdXAgZm9yICcxMjM0NScgd2lsbCBjb250YWluIHRoZW4gMyBvYmplY3RzLCBvbmUgZm9yIGVhY2hcblx0ICogcG9zc2libGUgZW5jb2RpbmcgbW9kZS5cblx0ICpcblx0ICogRWFjaCBub2RlIHJlcHJlc2VudHMgYSBwb3NzaWJsZSBzZWdtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtBcnJheX0gc2VncyBBcnJheSBvZiBvYmplY3Qgd2l0aCBzZWdtZW50cyBkYXRhXG5cdCAqIEByZXR1cm4ge0FycmF5fSAgICAgIEFycmF5IG9mIG9iamVjdCB3aXRoIHNlZ21lbnRzIGRhdGFcblx0ICovXG5cdGZ1bmN0aW9uIGJ1aWxkTm9kZXMgKHNlZ3MpIHtcblx0ICB2YXIgbm9kZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBzZWcgPSBzZWdzW2ldO1xuXG5cdCAgICBzd2l0Y2ggKHNlZy5tb2RlKSB7XG5cdCAgICAgIGNhc2UgTW9kZS5OVU1FUklDOlxuXHQgICAgICAgIG5vZGVzLnB1c2goW3NlZyxcblx0ICAgICAgICAgIHsgZGF0YTogc2VnLmRhdGEsIG1vZGU6IE1vZGUuQUxQSEFOVU1FUklDLCBsZW5ndGg6IHNlZy5sZW5ndGggfSxcblx0ICAgICAgICAgIHsgZGF0YTogc2VnLmRhdGEsIG1vZGU6IE1vZGUuQllURSwgbGVuZ3RoOiBzZWcubGVuZ3RoIH1cblx0ICAgICAgICBdKTtcblx0ICAgICAgICBicmVha1xuXHQgICAgICBjYXNlIE1vZGUuQUxQSEFOVU1FUklDOlxuXHQgICAgICAgIG5vZGVzLnB1c2goW3NlZyxcblx0ICAgICAgICAgIHsgZGF0YTogc2VnLmRhdGEsIG1vZGU6IE1vZGUuQllURSwgbGVuZ3RoOiBzZWcubGVuZ3RoIH1cblx0ICAgICAgICBdKTtcblx0ICAgICAgICBicmVha1xuXHQgICAgICBjYXNlIE1vZGUuS0FOSkk6XG5cdCAgICAgICAgbm9kZXMucHVzaChbc2VnLFxuXHQgICAgICAgICAgeyBkYXRhOiBzZWcuZGF0YSwgbW9kZTogTW9kZS5CWVRFLCBsZW5ndGg6IGdldFN0cmluZ0J5dGVMZW5ndGgoc2VnLmRhdGEpIH1cblx0ICAgICAgICBdKTtcblx0ICAgICAgICBicmVha1xuXHQgICAgICBjYXNlIE1vZGUuQllURTpcblx0ICAgICAgICBub2Rlcy5wdXNoKFtcblx0ICAgICAgICAgIHsgZGF0YTogc2VnLmRhdGEsIG1vZGU6IE1vZGUuQllURSwgbGVuZ3RoOiBnZXRTdHJpbmdCeXRlTGVuZ3RoKHNlZy5kYXRhKSB9XG5cdCAgICAgICAgXSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG5vZGVzXG5cdH1cblxuXHQvKipcblx0ICogQnVpbGRzIGEgZ3JhcGggZnJvbSBhIGxpc3Qgb2Ygbm9kZXMuXG5cdCAqIEFsbCBzZWdtZW50cyBpbiBlYWNoIG5vZGUgZ3JvdXAgd2lsbCBiZSBjb25uZWN0ZWQgd2l0aCBhbGwgdGhlIHNlZ21lbnRzIG9mXG5cdCAqIHRoZSBuZXh0IGdyb3VwIGFuZCBzbyBvbi5cblx0ICpcblx0ICogQXQgZWFjaCBjb25uZWN0aW9uIHdpbGwgYmUgYXNzaWduZWQgYSB3ZWlnaHQgZGVwZW5kaW5nIG9uIHRoZVxuXHQgKiBzZWdtZW50J3MgYnl0ZSBsZW5ndGguXG5cdCAqXG5cdCAqIEBwYXJhbSAge0FycmF5fSBub2RlcyAgICBBcnJheSBvZiBvYmplY3Qgd2l0aCBzZWdtZW50cyBkYXRhXG5cdCAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cblx0ICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIEdyYXBoIG9mIGFsbCBwb3NzaWJsZSBzZWdtZW50c1xuXHQgKi9cblx0ZnVuY3Rpb24gYnVpbGRHcmFwaCAobm9kZXMsIHZlcnNpb24pIHtcblx0ICB2YXIgdGFibGUgPSB7fTtcblx0ICB2YXIgZ3JhcGggPSB7J3N0YXJ0Jzoge319O1xuXHQgIHZhciBwcmV2Tm9kZUlkcyA9IFsnc3RhcnQnXTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBub2RlR3JvdXAgPSBub2Rlc1tpXTtcblx0ICAgIHZhciBjdXJyZW50Tm9kZUlkcyA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVHcm91cC5sZW5ndGg7IGorKykge1xuXHQgICAgICB2YXIgbm9kZSA9IG5vZGVHcm91cFtqXTtcblx0ICAgICAgdmFyIGtleSA9ICcnICsgaSArIGo7XG5cblx0ICAgICAgY3VycmVudE5vZGVJZHMucHVzaChrZXkpO1xuXHQgICAgICB0YWJsZVtrZXldID0geyBub2RlOiBub2RlLCBsYXN0Q291bnQ6IDAgfTtcblx0ICAgICAgZ3JhcGhba2V5XSA9IHt9O1xuXG5cdCAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgcHJldk5vZGVJZHMubGVuZ3RoOyBuKyspIHtcblx0ICAgICAgICB2YXIgcHJldk5vZGVJZCA9IHByZXZOb2RlSWRzW25dO1xuXG5cdCAgICAgICAgaWYgKHRhYmxlW3ByZXZOb2RlSWRdICYmIHRhYmxlW3ByZXZOb2RlSWRdLm5vZGUubW9kZSA9PT0gbm9kZS5tb2RlKSB7XG5cdCAgICAgICAgICBncmFwaFtwcmV2Tm9kZUlkXVtrZXldID1cblx0ICAgICAgICAgICAgZ2V0U2VnbWVudEJpdHNMZW5ndGgodGFibGVbcHJldk5vZGVJZF0ubGFzdENvdW50ICsgbm9kZS5sZW5ndGgsIG5vZGUubW9kZSkgLVxuXHQgICAgICAgICAgICBnZXRTZWdtZW50Qml0c0xlbmd0aCh0YWJsZVtwcmV2Tm9kZUlkXS5sYXN0Q291bnQsIG5vZGUubW9kZSk7XG5cblx0ICAgICAgICAgIHRhYmxlW3ByZXZOb2RlSWRdLmxhc3RDb3VudCArPSBub2RlLmxlbmd0aDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaWYgKHRhYmxlW3ByZXZOb2RlSWRdKSB0YWJsZVtwcmV2Tm9kZUlkXS5sYXN0Q291bnQgPSBub2RlLmxlbmd0aDtcblxuXHQgICAgICAgICAgZ3JhcGhbcHJldk5vZGVJZF1ba2V5XSA9IGdldFNlZ21lbnRCaXRzTGVuZ3RoKG5vZGUubGVuZ3RoLCBub2RlLm1vZGUpICtcblx0ICAgICAgICAgICAgNCArIE1vZGUuZ2V0Q2hhckNvdW50SW5kaWNhdG9yKG5vZGUubW9kZSwgdmVyc2lvbik7IC8vIHN3aXRjaCBjb3N0XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHByZXZOb2RlSWRzID0gY3VycmVudE5vZGVJZHM7XG5cdCAgfVxuXG5cdCAgZm9yIChuID0gMDsgbiA8IHByZXZOb2RlSWRzLmxlbmd0aDsgbisrKSB7XG5cdCAgICBncmFwaFtwcmV2Tm9kZUlkc1tuXV1bJ2VuZCddID0gMDtcblx0ICB9XG5cblx0ICByZXR1cm4geyBtYXA6IGdyYXBoLCB0YWJsZTogdGFibGUgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEJ1aWxkcyBhIHNlZ21lbnQgZnJvbSBhIHNwZWNpZmllZCBkYXRhIGFuZCBtb2RlLlxuXHQgKiBJZiBhIG1vZGUgaXMgbm90IHNwZWNpZmllZCwgdGhlIG1vcmUgc3VpdGFibGUgd2lsbCBiZSB1c2VkLlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgICAgICAgICAgICAgSW5wdXQgZGF0YVxuXHQgKiBAcGFyYW0gIHtNb2RlIHwgU3RyaW5nfSBtb2Rlc0hpbnQgRGF0YSBtb2RlXG5cdCAqIEByZXR1cm4ge1NlZ21lbnR9ICAgICAgICAgICAgICAgICBTZWdtZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBidWlsZFNpbmdsZVNlZ21lbnQgKGRhdGEsIG1vZGVzSGludCkge1xuXHQgIHZhciBtb2RlO1xuXHQgIHZhciBiZXN0TW9kZSA9IE1vZGUuZ2V0QmVzdE1vZGVGb3JEYXRhKGRhdGEpO1xuXG5cdCAgbW9kZSA9IE1vZGUuZnJvbShtb2Rlc0hpbnQsIGJlc3RNb2RlKTtcblxuXHQgIC8vIE1ha2Ugc3VyZSBkYXRhIGNhbiBiZSBlbmNvZGVkXG5cdCAgaWYgKG1vZGUgIT09IE1vZGUuQllURSAmJiBtb2RlLmJpdCA8IGJlc3RNb2RlLmJpdCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBkYXRhICsgJ1wiJyArXG5cdCAgICAgICcgY2Fubm90IGJlIGVuY29kZWQgd2l0aCBtb2RlICcgKyBNb2RlLnRvU3RyaW5nKG1vZGUpICtcblx0ICAgICAgJy5cXG4gU3VnZ2VzdGVkIG1vZGUgaXM6ICcgKyBNb2RlLnRvU3RyaW5nKGJlc3RNb2RlKSlcblx0ICB9XG5cblx0ICAvLyBVc2UgTW9kZS5CWVRFIGlmIEthbmppIHN1cHBvcnQgaXMgZGlzYWJsZWRcblx0ICBpZiAobW9kZSA9PT0gTW9kZS5LQU5KSSAmJiAhVXRpbHMuaXNLYW5qaU1vZGVFbmFibGVkKCkpIHtcblx0ICAgIG1vZGUgPSBNb2RlLkJZVEU7XG5cdCAgfVxuXG5cdCAgc3dpdGNoIChtb2RlKSB7XG5cdCAgICBjYXNlIE1vZGUuTlVNRVJJQzpcblx0ICAgICAgcmV0dXJuIG5ldyBOdW1lcmljRGF0YShkYXRhKVxuXG5cdCAgICBjYXNlIE1vZGUuQUxQSEFOVU1FUklDOlxuXHQgICAgICByZXR1cm4gbmV3IEFscGhhbnVtZXJpY0RhdGEoZGF0YSlcblxuXHQgICAgY2FzZSBNb2RlLktBTkpJOlxuXHQgICAgICByZXR1cm4gbmV3IEthbmppRGF0YShkYXRhKVxuXG5cdCAgICBjYXNlIE1vZGUuQllURTpcblx0ICAgICAgcmV0dXJuIG5ldyBCeXRlRGF0YShkYXRhKVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBCdWlsZHMgYSBsaXN0IG9mIHNlZ21lbnRzIGZyb20gYW4gYXJyYXkuXG5cdCAqIEFycmF5IGNhbiBjb250YWluIFN0cmluZ3Mgb3IgT2JqZWN0cyB3aXRoIHNlZ21lbnQncyBpbmZvLlxuXHQgKlxuXHQgKiBGb3IgZWFjaCBpdGVtIHdoaWNoIGlzIGEgc3RyaW5nLCB3aWxsIGJlIGdlbmVyYXRlZCBhIHNlZ21lbnQgd2l0aCB0aGUgZ2l2ZW5cblx0ICogc3RyaW5nIGFuZCB0aGUgbW9yZSBhcHByb3ByaWF0ZSBlbmNvZGluZyBtb2RlLlxuXHQgKlxuXHQgKiBGb3IgZWFjaCBpdGVtIHdoaWNoIGlzIGFuIG9iamVjdCwgd2lsbCBiZSBnZW5lcmF0ZWQgYSBzZWdtZW50IHdpdGggdGhlIGdpdmVuXG5cdCAqIGRhdGEgYW5kIG1vZGUuXG5cdCAqIE9iamVjdHMgbXVzdCBjb250YWluIGF0IGxlYXN0IHRoZSBwcm9wZXJ0eSBcImRhdGFcIi5cblx0ICogSWYgcHJvcGVydHkgXCJtb2RlXCIgaXMgbm90IHByZXNlbnQsIHRoZSBtb3JlIHN1aXRhYmxlIG1vZGUgd2lsbCBiZSB1c2VkLlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtBcnJheX0gYXJyYXkgQXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHNlZ21lbnRzIGRhdGFcblx0ICogQHJldHVybiB7QXJyYXl9ICAgICAgIEFycmF5IG9mIFNlZ21lbnRzXG5cdCAqL1xuXHRleHBvcnRzLmZyb21BcnJheSA9IGZ1bmN0aW9uIGZyb21BcnJheSAoYXJyYXkpIHtcblx0ICByZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHNlZykge1xuXHQgICAgaWYgKHR5cGVvZiBzZWcgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGFjYy5wdXNoKGJ1aWxkU2luZ2xlU2VnbWVudChzZWcsIG51bGwpKTtcblx0ICAgIH0gZWxzZSBpZiAoc2VnLmRhdGEpIHtcblx0ICAgICAgYWNjLnB1c2goYnVpbGRTaW5nbGVTZWdtZW50KHNlZy5kYXRhLCBzZWcubW9kZSkpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYWNjXG5cdCAgfSwgW10pXG5cdH07XG5cblx0LyoqXG5cdCAqIEJ1aWxkcyBhbiBvcHRpbWl6ZWQgc2VxdWVuY2Ugb2Ygc2VnbWVudHMgZnJvbSBhIHN0cmluZyxcblx0ICogd2hpY2ggd2lsbCBwcm9kdWNlIHRoZSBzaG9ydGVzdCBwb3NzaWJsZSBiaXRzdHJlYW0uXG5cdCAqXG5cdCAqIEBwYXJhbSAge1N0cmluZ30gZGF0YSAgICBJbnB1dCBzdHJpbmdcblx0ICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uIFFSIENvZGUgdmVyc2lvblxuXHQgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgQXJyYXkgb2Ygc2VnbWVudHNcblx0ICovXG5cdGV4cG9ydHMuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIGZyb21TdHJpbmcgKGRhdGEsIHZlcnNpb24pIHtcblx0ICB2YXIgc2VncyA9IGdldFNlZ21lbnRzRnJvbVN0cmluZyhkYXRhLCBVdGlscy5pc0thbmppTW9kZUVuYWJsZWQoKSk7XG5cblx0ICB2YXIgbm9kZXMgPSBidWlsZE5vZGVzKHNlZ3MpO1xuXHQgIHZhciBncmFwaCA9IGJ1aWxkR3JhcGgobm9kZXMsIHZlcnNpb24pO1xuXHQgIHZhciBwYXRoID0gZGlqa3N0cmEuZmluZF9wYXRoKGdyYXBoLm1hcCwgJ3N0YXJ0JywgJ2VuZCcpO1xuXG5cdCAgdmFyIG9wdGltaXplZFNlZ3MgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG5cdCAgICBvcHRpbWl6ZWRTZWdzLnB1c2goZ3JhcGgudGFibGVbcGF0aFtpXV0ubm9kZSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGV4cG9ydHMuZnJvbUFycmF5KG1lcmdlU2VnbWVudHMob3B0aW1pemVkU2VncykpXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwbGl0cyBhIHN0cmluZyBpbiB2YXJpb3VzIHNlZ21lbnRzIHdpdGggdGhlIG1vZGVzIHdoaWNoXG5cdCAqIGJlc3QgcmVwcmVzZW50IHRoZWlyIGNvbnRlbnQuXG5cdCAqIFRoZSBwcm9kdWNlZCBzZWdtZW50cyBhcmUgZmFyIGZyb20gYmVpbmcgb3B0aW1pemVkLlxuXHQgKiBUaGUgb3V0cHV0IG9mIHRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIHRvIGVzdGltYXRlIGEgUVIgQ29kZSB2ZXJzaW9uXG5cdCAqIHdoaWNoIG1heSBjb250YWluIHRoZSBkYXRhLlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IGRhdGEgSW5wdXQgc3RyaW5nXG5cdCAqIEByZXR1cm4ge0FycmF5fSAgICAgICBBcnJheSBvZiBzZWdtZW50c1xuXHQgKi9cblx0ZXhwb3J0cy5yYXdTcGxpdCA9IGZ1bmN0aW9uIHJhd1NwbGl0IChkYXRhKSB7XG5cdCAgcmV0dXJuIGV4cG9ydHMuZnJvbUFycmF5KFxuXHQgICAgZ2V0U2VnbWVudHNGcm9tU3RyaW5nKGRhdGEsIFV0aWxzLmlzS2FuamlNb2RlRW5hYmxlZCgpKVxuXHQgIClcblx0fTtcblxuXHR9LHtcIi4vYWxwaGFudW1lcmljLWRhdGFcIjozLFwiLi9ieXRlLWRhdGFcIjo2LFwiLi9rYW5qaS1kYXRhXCI6MTIsXCIuL21vZGVcIjoxNCxcIi4vbnVtZXJpYy1kYXRhXCI6MTUsXCIuL3JlZ2V4XCI6MTksXCIuL3V0aWxzXCI6MjEsXCJkaWprc3RyYWpzXCI6MzF9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cdHZhciB0b1NKSVNGdW5jdGlvbjtcblx0dmFyIENPREVXT1JEU19DT1VOVCA9IFtcblx0ICAwLCAvLyBOb3QgdXNlZFxuXHQgIDI2LCA0NCwgNzAsIDEwMCwgMTM0LCAxNzIsIDE5NiwgMjQyLCAyOTIsIDM0Nixcblx0ICA0MDQsIDQ2NiwgNTMyLCA1ODEsIDY1NSwgNzMzLCA4MTUsIDkwMSwgOTkxLCAxMDg1LFxuXHQgIDExNTYsIDEyNTgsIDEzNjQsIDE0NzQsIDE1ODgsIDE3MDYsIDE4MjgsIDE5MjEsIDIwNTEsIDIxODUsXG5cdCAgMjMyMywgMjQ2NSwgMjYxMSwgMjc2MSwgMjg3NiwgMzAzNCwgMzE5NiwgMzM2MiwgMzUzMiwgMzcwNlxuXHRdO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBRUiBDb2RlIHNpemUgZm9yIHRoZSBzcGVjaWZpZWQgdmVyc2lvblxuXHQgKlxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHZlcnNpb24gUVIgQ29kZSB2ZXJzaW9uXG5cdCAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICBzaXplIG9mIFFSIGNvZGVcblx0ICovXG5cdGV4cG9ydHMuZ2V0U3ltYm9sU2l6ZSA9IGZ1bmN0aW9uIGdldFN5bWJvbFNpemUgKHZlcnNpb24pIHtcblx0ICBpZiAoIXZlcnNpb24pIHRocm93IG5ldyBFcnJvcignXCJ2ZXJzaW9uXCIgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJylcblx0ICBpZiAodmVyc2lvbiA8IDEgfHwgdmVyc2lvbiA+IDQwKSB0aHJvdyBuZXcgRXJyb3IoJ1widmVyc2lvblwiIHNob3VsZCBiZSBpbiByYW5nZSBmcm9tIDEgdG8gNDAnKVxuXHQgIHJldHVybiB2ZXJzaW9uICogNCArIDE3XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBjb2Rld29yZHMgdXNlZCB0byBzdG9yZSBkYXRhIGFuZCBFQyBpbmZvcm1hdGlvbi5cblx0ICpcblx0ICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uIFFSIENvZGUgdmVyc2lvblxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgRGF0YSBsZW5ndGggaW4gYml0c1xuXHQgKi9cblx0ZXhwb3J0cy5nZXRTeW1ib2xUb3RhbENvZGV3b3JkcyA9IGZ1bmN0aW9uIGdldFN5bWJvbFRvdGFsQ29kZXdvcmRzICh2ZXJzaW9uKSB7XG5cdCAgcmV0dXJuIENPREVXT1JEU19DT1VOVFt2ZXJzaW9uXVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmNvZGUgZGF0YSB3aXRoIEJvc2UtQ2hhdWRodXJpLUhvY3F1ZW5naGVtXG5cdCAqXG5cdCAqIEBwYXJhbSAge051bWJlcn0gZGF0YSBWYWx1ZSB0byBlbmNvZGVcblx0ICogQHJldHVybiB7TnVtYmVyfSAgICAgIEVuY29kZWQgdmFsdWVcblx0ICovXG5cdGV4cG9ydHMuZ2V0QkNIRGlnaXQgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgIHZhciBkaWdpdCA9IDA7XG5cblx0ICB3aGlsZSAoZGF0YSAhPT0gMCkge1xuXHQgICAgZGlnaXQrKztcblx0ICAgIGRhdGEgPj4+PSAxO1xuXHQgIH1cblxuXHQgIHJldHVybiBkaWdpdFxuXHR9O1xuXG5cdGV4cG9ydHMuc2V0VG9TSklTRnVuY3Rpb24gPSBmdW5jdGlvbiBzZXRUb1NKSVNGdW5jdGlvbiAoZikge1xuXHQgIGlmICh0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdcInRvU0pJU0Z1bmNcIiBpcyBub3QgYSB2YWxpZCBmdW5jdGlvbi4nKVxuXHQgIH1cblxuXHQgIHRvU0pJU0Z1bmN0aW9uID0gZjtcblx0fTtcblxuXHRleHBvcnRzLmlzS2FuamlNb2RlRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gdHlwZW9mIHRvU0pJU0Z1bmN0aW9uICE9PSAndW5kZWZpbmVkJ1xuXHR9O1xuXG5cdGV4cG9ydHMudG9TSklTID0gZnVuY3Rpb24gdG9TSklTIChrYW5qaSkge1xuXHQgIHJldHVybiB0b1NKSVNGdW5jdGlvbihrYW5qaSlcblx0fTtcblxuXHR9LHt9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBRUiBDb2RlIHZlcnNpb24gaXMgdmFsaWRcblx0ICpcblx0ICogQHBhcmFtICB7TnVtYmVyfSAgdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICB0cnVlIGlmIHZhbGlkIHZlcnNpb24sIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0ZXhwb3J0cy5pc1ZhbGlkID0gZnVuY3Rpb24gaXNWYWxpZCAodmVyc2lvbikge1xuXHQgIHJldHVybiAhaXNOYU4odmVyc2lvbikgJiYgdmVyc2lvbiA+PSAxICYmIHZlcnNpb24gPD0gNDBcblx0fTtcblxuXHR9LHt9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cdHZhciBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblx0dmFyIEVDQ29kZSA9IHJlcXVpcmUoJy4vZXJyb3ItY29ycmVjdGlvbi1jb2RlJyk7XG5cdHZhciBFQ0xldmVsID0gcmVxdWlyZSgnLi9lcnJvci1jb3JyZWN0aW9uLWxldmVsJyk7XG5cdHZhciBNb2RlID0gcmVxdWlyZSgnLi9tb2RlJyk7XG5cdHZhciBWZXJzaW9uQ2hlY2sgPSByZXF1aXJlKCcuL3ZlcnNpb24tY2hlY2snKTtcblx0dmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cblx0Ly8gR2VuZXJhdG9yIHBvbHlub21pYWwgdXNlZCB0byBlbmNvZGUgdmVyc2lvbiBpbmZvcm1hdGlvblxuXHR2YXIgRzE4ID0gKDEgPDwgMTIpIHwgKDEgPDwgMTEpIHwgKDEgPDwgMTApIHwgKDEgPDwgOSkgfCAoMSA8PCA4KSB8ICgxIDw8IDUpIHwgKDEgPDwgMikgfCAoMSA8PCAwKTtcblx0dmFyIEcxOF9CQ0ggPSBVdGlscy5nZXRCQ0hEaWdpdChHMTgpO1xuXG5cdGZ1bmN0aW9uIGdldEJlc3RWZXJzaW9uRm9yRGF0YUxlbmd0aCAobW9kZSwgbGVuZ3RoLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuXHQgIGZvciAodmFyIGN1cnJlbnRWZXJzaW9uID0gMTsgY3VycmVudFZlcnNpb24gPD0gNDA7IGN1cnJlbnRWZXJzaW9uKyspIHtcblx0ICAgIGlmIChsZW5ndGggPD0gZXhwb3J0cy5nZXRDYXBhY2l0eShjdXJyZW50VmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIG1vZGUpKSB7XG5cdCAgICAgIHJldHVybiBjdXJyZW50VmVyc2lvblxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB1bmRlZmluZWRcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFJlc2VydmVkQml0c0NvdW50IChtb2RlLCB2ZXJzaW9uKSB7XG5cdCAgLy8gQ2hhcmFjdGVyIGNvdW50IGluZGljYXRvciArIG1vZGUgaW5kaWNhdG9yIGJpdHNcblx0ICByZXR1cm4gTW9kZS5nZXRDaGFyQ291bnRJbmRpY2F0b3IobW9kZSwgdmVyc2lvbikgKyA0XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUb3RhbEJpdHNGcm9tRGF0YUFycmF5IChzZWdtZW50cywgdmVyc2lvbikge1xuXHQgIHZhciB0b3RhbEJpdHMgPSAwO1xuXG5cdCAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgdmFyIHJlc2VydmVkQml0cyA9IGdldFJlc2VydmVkQml0c0NvdW50KGRhdGEubW9kZSwgdmVyc2lvbik7XG5cdCAgICB0b3RhbEJpdHMgKz0gcmVzZXJ2ZWRCaXRzICsgZGF0YS5nZXRCaXRzTGVuZ3RoKCk7XG5cdCAgfSk7XG5cblx0ICByZXR1cm4gdG90YWxCaXRzXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCZXN0VmVyc2lvbkZvck1peGVkRGF0YSAoc2VnbWVudHMsIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG5cdCAgZm9yICh2YXIgY3VycmVudFZlcnNpb24gPSAxOyBjdXJyZW50VmVyc2lvbiA8PSA0MDsgY3VycmVudFZlcnNpb24rKykge1xuXHQgICAgdmFyIGxlbmd0aCA9IGdldFRvdGFsQml0c0Zyb21EYXRhQXJyYXkoc2VnbWVudHMsIGN1cnJlbnRWZXJzaW9uKTtcblx0ICAgIGlmIChsZW5ndGggPD0gZXhwb3J0cy5nZXRDYXBhY2l0eShjdXJyZW50VmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIE1vZGUuTUlYRUQpKSB7XG5cdCAgICAgIHJldHVybiBjdXJyZW50VmVyc2lvblxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB1bmRlZmluZWRcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHZlcnNpb24gbnVtYmVyIGZyb20gYSB2YWx1ZS5cblx0ICogSWYgdmFsdWUgaXMgbm90IGEgdmFsaWQgdmVyc2lvbiwgcmV0dXJucyBkZWZhdWx0VmFsdWVcblx0ICpcblx0ICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gdmFsdWUgICAgICAgIFFSIENvZGUgdmVyc2lvblxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICBkZWZhdWx0VmFsdWUgRmFsbGJhY2sgdmFsdWVcblx0ICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIFFSIENvZGUgdmVyc2lvbiBudW1iZXJcblx0ICovXG5cdGV4cG9ydHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcblx0ICBpZiAoVmVyc2lvbkNoZWNrLmlzVmFsaWQodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKVxuXHQgIH1cblxuXHQgIHJldHVybiBkZWZhdWx0VmFsdWVcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBob3cgbXVjaCBkYXRhIGNhbiBiZSBzdG9yZWQgd2l0aCB0aGUgc3BlY2lmaWVkIFFSIGNvZGUgdmVyc2lvblxuXHQgKiBhbmQgZXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuXHQgKlxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHZlcnNpb24gICAgICAgICAgICAgIFFSIENvZGUgdmVyc2lvbiAoMS00MClcblx0ICogQHBhcmFtICB7TnVtYmVyfSBlcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG5cdCAqIEBwYXJhbSAge01vZGV9ICAgbW9kZSAgICAgICAgICAgICAgICAgRGF0YSBtb2RlXG5cdCAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgUXVhbnRpdHkgb2Ygc3RvcmFibGUgZGF0YVxuXHQgKi9cblx0ZXhwb3J0cy5nZXRDYXBhY2l0eSA9IGZ1bmN0aW9uIGdldENhcGFjaXR5ICh2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgbW9kZSkge1xuXHQgIGlmICghVmVyc2lvbkNoZWNrLmlzVmFsaWQodmVyc2lvbikpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBRUiBDb2RlIHZlcnNpb24nKVxuXHQgIH1cblxuXHQgIC8vIFVzZSBCeXRlIG1vZGUgYXMgZGVmYXVsdFxuXHQgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3VuZGVmaW5lZCcpIG1vZGUgPSBNb2RlLkJZVEU7XG5cblx0ICAvLyBUb3RhbCBjb2Rld29yZHMgZm9yIHRoaXMgUVIgY29kZSB2ZXJzaW9uIChEYXRhICsgRXJyb3IgY29ycmVjdGlvbilcblx0ICB2YXIgdG90YWxDb2Rld29yZHMgPSBVdGlscy5nZXRTeW1ib2xUb3RhbENvZGV3b3Jkcyh2ZXJzaW9uKTtcblxuXHQgIC8vIFRvdGFsIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xuXHQgIHZhciBlY1RvdGFsQ29kZXdvcmRzID0gRUNDb2RlLmdldFRvdGFsQ29kZXdvcmRzQ291bnQodmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuXG5cdCAgLy8gVG90YWwgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzXG5cdCAgdmFyIGRhdGFUb3RhbENvZGV3b3Jkc0JpdHMgPSAodG90YWxDb2Rld29yZHMgLSBlY1RvdGFsQ29kZXdvcmRzKSAqIDg7XG5cblx0ICBpZiAobW9kZSA9PT0gTW9kZS5NSVhFRCkgcmV0dXJuIGRhdGFUb3RhbENvZGV3b3Jkc0JpdHNcblxuXHQgIHZhciB1c2FibGVCaXRzID0gZGF0YVRvdGFsQ29kZXdvcmRzQml0cyAtIGdldFJlc2VydmVkQml0c0NvdW50KG1vZGUsIHZlcnNpb24pO1xuXG5cdCAgLy8gUmV0dXJuIG1heCBudW1iZXIgb2Ygc3RvcmFibGUgY29kZXdvcmRzXG5cdCAgc3dpdGNoIChtb2RlKSB7XG5cdCAgICBjYXNlIE1vZGUuTlVNRVJJQzpcblx0ICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHVzYWJsZUJpdHMgLyAxMCkgKiAzKVxuXG5cdCAgICBjYXNlIE1vZGUuQUxQSEFOVU1FUklDOlxuXHQgICAgICByZXR1cm4gTWF0aC5mbG9vcigodXNhYmxlQml0cyAvIDExKSAqIDIpXG5cblx0ICAgIGNhc2UgTW9kZS5LQU5KSTpcblx0ICAgICAgcmV0dXJuIE1hdGguZmxvb3IodXNhYmxlQml0cyAvIDEzKVxuXG5cdCAgICBjYXNlIE1vZGUuQllURTpcblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHJldHVybiBNYXRoLmZsb29yKHVzYWJsZUJpdHMgLyA4KVxuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbWluaW11bSB2ZXJzaW9uIG5lZWRlZCB0byBjb250YWluIHRoZSBhbW91bnQgb2YgZGF0YVxuXHQgKlxuXHQgKiBAcGFyYW0gIHtTZWdtZW50fSBkYXRhICAgICAgICAgICAgICAgICAgICBTZWdtZW50IG9mIGRhdGFcblx0ICogQHBhcmFtICB7TnVtYmVyfSBbZXJyb3JDb3JyZWN0aW9uTGV2ZWw9SF0gRXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuXHQgKiBAcGFyYW0gIHtNb2RlfSBtb2RlICAgICAgICAgICAgICAgICAgICAgICBEYXRhIG1vZGVcblx0ICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgICAgICAgUVIgQ29kZSB2ZXJzaW9uXG5cdCAqL1xuXHRleHBvcnRzLmdldEJlc3RWZXJzaW9uRm9yRGF0YSA9IGZ1bmN0aW9uIGdldEJlc3RWZXJzaW9uRm9yRGF0YSAoZGF0YSwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcblx0ICB2YXIgc2VnO1xuXG5cdCAgdmFyIGVjbCA9IEVDTGV2ZWwuZnJvbShlcnJvckNvcnJlY3Rpb25MZXZlbCwgRUNMZXZlbC5NKTtcblxuXHQgIGlmIChpc0FycmF5KGRhdGEpKSB7XG5cdCAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG5cdCAgICAgIHJldHVybiBnZXRCZXN0VmVyc2lvbkZvck1peGVkRGF0YShkYXRhLCBlY2wpXG5cdCAgICB9XG5cblx0ICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICByZXR1cm4gMVxuXHQgICAgfVxuXG5cdCAgICBzZWcgPSBkYXRhWzBdO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBzZWcgPSBkYXRhO1xuXHQgIH1cblxuXHQgIHJldHVybiBnZXRCZXN0VmVyc2lvbkZvckRhdGFMZW5ndGgoc2VnLm1vZGUsIHNlZy5nZXRMZW5ndGgoKSwgZWNsKVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHZlcnNpb24gaW5mb3JtYXRpb24gd2l0aCByZWxhdGl2ZSBlcnJvciBjb3JyZWN0aW9uIGJpdHNcblx0ICpcblx0ICogVGhlIHZlcnNpb24gaW5mb3JtYXRpb24gaXMgaW5jbHVkZWQgaW4gUVIgQ29kZSBzeW1ib2xzIG9mIHZlcnNpb24gNyBvciBsYXJnZXIuXG5cdCAqIEl0IGNvbnNpc3RzIG9mIGFuIDE4LWJpdCBzZXF1ZW5jZSBjb250YWluaW5nIDYgZGF0YSBiaXRzLFxuXHQgKiB3aXRoIDEyIGVycm9yIGNvcnJlY3Rpb24gYml0cyBjYWxjdWxhdGVkIHVzaW5nIHRoZSAoMTgsIDYpIEdvbGF5IGNvZGUuXG5cdCAqXG5cdCAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cblx0ICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgIEVuY29kZWQgdmVyc2lvbiBpbmZvIGJpdHNcblx0ICovXG5cdGV4cG9ydHMuZ2V0RW5jb2RlZEJpdHMgPSBmdW5jdGlvbiBnZXRFbmNvZGVkQml0cyAodmVyc2lvbikge1xuXHQgIGlmICghVmVyc2lvbkNoZWNrLmlzVmFsaWQodmVyc2lvbikgfHwgdmVyc2lvbiA8IDcpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBRUiBDb2RlIHZlcnNpb24nKVxuXHQgIH1cblxuXHQgIHZhciBkID0gdmVyc2lvbiA8PCAxMjtcblxuXHQgIHdoaWxlIChVdGlscy5nZXRCQ0hEaWdpdChkKSAtIEcxOF9CQ0ggPj0gMCkge1xuXHQgICAgZCBePSAoRzE4IDw8IChVdGlscy5nZXRCQ0hEaWdpdChkKSAtIEcxOF9CQ0gpKTtcblx0ICB9XG5cblx0ICByZXR1cm4gKHZlcnNpb24gPDwgMTIpIHwgZFxuXHR9O1xuXG5cdH0se1wiLi9lcnJvci1jb3JyZWN0aW9uLWNvZGVcIjo3LFwiLi9lcnJvci1jb3JyZWN0aW9uLWxldmVsXCI6OCxcIi4vbW9kZVwiOjE0LFwiLi91dGlsc1wiOjIxLFwiLi92ZXJzaW9uLWNoZWNrXCI6MjIsXCJpc2FycmF5XCI6MzN9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cblx0dmFyIGNhblByb21pc2UgPSByZXF1aXJlKCcuL2Nhbi1wcm9taXNlJyk7XG5cblx0dmFyIFFSQ29kZSA9IHJlcXVpcmUoJy4vY29yZS9xcmNvZGUnKTtcblx0dmFyIENhbnZhc1JlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlci9jYW52YXMnKTtcblx0dmFyIFN2Z1JlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlci9zdmctdGFnLmpzJyk7XG5cblx0ZnVuY3Rpb24gcmVuZGVyQ2FudmFzIChyZW5kZXJGdW5jLCBjYW52YXMsIHRleHQsIG9wdHMsIGNiKSB7XG5cdCAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdCAgdmFyIGFyZ3NOdW0gPSBhcmdzLmxlbmd0aDtcblx0ICB2YXIgaXNMYXN0QXJnQ2IgPSB0eXBlb2YgYXJnc1thcmdzTnVtIC0gMV0gPT09ICdmdW5jdGlvbic7XG5cblx0ICBpZiAoIWlzTGFzdEFyZ0NiICYmICFjYW5Qcm9taXNlKCkpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgcmVxdWlyZWQgYXMgbGFzdCBhcmd1bWVudCcpXG5cdCAgfVxuXG5cdCAgaWYgKGlzTGFzdEFyZ0NiKSB7XG5cdCAgICBpZiAoYXJnc051bSA8IDIpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb28gZmV3IGFyZ3VtZW50cyBwcm92aWRlZCcpXG5cdCAgICB9XG5cblx0ICAgIGlmIChhcmdzTnVtID09PSAyKSB7XG5cdCAgICAgIGNiID0gdGV4dDtcblx0ICAgICAgdGV4dCA9IGNhbnZhcztcblx0ICAgICAgY2FudmFzID0gb3B0cyA9IHVuZGVmaW5lZDtcblx0ICAgIH0gZWxzZSBpZiAoYXJnc051bSA9PT0gMykge1xuXHQgICAgICBpZiAoY2FudmFzLmdldENvbnRleHQgJiYgdHlwZW9mIGNiID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIGNiID0gb3B0cztcblx0ICAgICAgICBvcHRzID0gdW5kZWZpbmVkO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGNiID0gb3B0cztcblx0ICAgICAgICBvcHRzID0gdGV4dDtcblx0ICAgICAgICB0ZXh0ID0gY2FudmFzO1xuXHQgICAgICAgIGNhbnZhcyA9IHVuZGVmaW5lZDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAoYXJnc051bSA8IDEpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb28gZmV3IGFyZ3VtZW50cyBwcm92aWRlZCcpXG5cdCAgICB9XG5cblx0ICAgIGlmIChhcmdzTnVtID09PSAxKSB7XG5cdCAgICAgIHRleHQgPSBjYW52YXM7XG5cdCAgICAgIGNhbnZhcyA9IG9wdHMgPSB1bmRlZmluZWQ7XG5cdCAgICB9IGVsc2UgaWYgKGFyZ3NOdW0gPT09IDIgJiYgIWNhbnZhcy5nZXRDb250ZXh0KSB7XG5cdCAgICAgIG9wdHMgPSB0ZXh0O1xuXHQgICAgICB0ZXh0ID0gY2FudmFzO1xuXHQgICAgICBjYW52YXMgPSB1bmRlZmluZWQ7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgdmFyIGRhdGEgPSBRUkNvZGUuY3JlYXRlKHRleHQsIG9wdHMpO1xuXHQgICAgICAgIHJlc29sdmUocmVuZGVyRnVuYyhkYXRhLCBjYW52YXMsIG9wdHMpKTtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJlamVjdChlKTtcblx0ICAgICAgfVxuXHQgICAgfSlcblx0ICB9XG5cblx0ICB0cnkge1xuXHQgICAgdmFyIGRhdGEgPSBRUkNvZGUuY3JlYXRlKHRleHQsIG9wdHMpO1xuXHQgICAgY2IobnVsbCwgcmVuZGVyRnVuYyhkYXRhLCBjYW52YXMsIG9wdHMpKTtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICBjYihlKTtcblx0ICB9XG5cdH1cblxuXHRleHBvcnRzLmNyZWF0ZSA9IFFSQ29kZS5jcmVhdGU7XG5cdGV4cG9ydHMudG9DYW52YXMgPSByZW5kZXJDYW52YXMuYmluZChudWxsLCBDYW52YXNSZW5kZXJlci5yZW5kZXIpO1xuXHRleHBvcnRzLnRvRGF0YVVSTCA9IHJlbmRlckNhbnZhcy5iaW5kKG51bGwsIENhbnZhc1JlbmRlcmVyLnJlbmRlclRvRGF0YVVSTCk7XG5cblx0Ly8gb25seSBzdmcgZm9yIG5vdy5cblx0ZXhwb3J0cy50b1N0cmluZyA9IHJlbmRlckNhbnZhcy5iaW5kKG51bGwsIGZ1bmN0aW9uIChkYXRhLCBfLCBvcHRzKSB7XG5cdCAgcmV0dXJuIFN2Z1JlbmRlcmVyLnJlbmRlcihkYXRhLCBvcHRzKVxuXHR9KTtcblxuXHR9LHtcIi4vY2FuLXByb21pc2VcIjoxLFwiLi9jb3JlL3FyY29kZVwiOjE3LFwiLi9yZW5kZXJlci9jYW52YXNcIjoyNSxcIi4vcmVuZGVyZXIvc3ZnLXRhZy5qc1wiOjI2fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHR2YXIgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblx0ZnVuY3Rpb24gY2xlYXJDYW52YXMgKGN0eCwgY2FudmFzLCBzaXplKSB7XG5cdCAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG5cdCAgaWYgKCFjYW52YXMuc3R5bGUpIGNhbnZhcy5zdHlsZSA9IHt9O1xuXHQgIGNhbnZhcy5oZWlnaHQgPSBzaXplO1xuXHQgIGNhbnZhcy53aWR0aCA9IHNpemU7XG5cdCAgY2FudmFzLnN0eWxlLmhlaWdodCA9IHNpemUgKyAncHgnO1xuXHQgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHNpemUgKyAncHgnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q2FudmFzRWxlbWVudCAoKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gc3BlY2lmeSBhIGNhbnZhcyBlbGVtZW50Jylcblx0ICB9XG5cdH1cblxuXHRleHBvcnRzLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAocXJEYXRhLCBjYW52YXMsIG9wdGlvbnMpIHtcblx0ICB2YXIgb3B0cyA9IG9wdGlvbnM7XG5cdCAgdmFyIGNhbnZhc0VsID0gY2FudmFzO1xuXG5cdCAgaWYgKHR5cGVvZiBvcHRzID09PSAndW5kZWZpbmVkJyAmJiAoIWNhbnZhcyB8fCAhY2FudmFzLmdldENvbnRleHQpKSB7XG5cdCAgICBvcHRzID0gY2FudmFzO1xuXHQgICAgY2FudmFzID0gdW5kZWZpbmVkO1xuXHQgIH1cblxuXHQgIGlmICghY2FudmFzKSB7XG5cdCAgICBjYW52YXNFbCA9IGdldENhbnZhc0VsZW1lbnQoKTtcblx0ICB9XG5cblx0ICBvcHRzID0gVXRpbHMuZ2V0T3B0aW9ucyhvcHRzKTtcblx0ICB2YXIgc2l6ZSA9IFV0aWxzLmdldEltYWdlV2lkdGgocXJEYXRhLm1vZHVsZXMuc2l6ZSwgb3B0cyk7XG5cblx0ICB2YXIgY3R4ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcblx0ICB2YXIgaW1hZ2UgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHNpemUsIHNpemUpO1xuXHQgIFV0aWxzLnFyVG9JbWFnZURhdGEoaW1hZ2UuZGF0YSwgcXJEYXRhLCBvcHRzKTtcblxuXHQgIGNsZWFyQ2FudmFzKGN0eCwgY2FudmFzRWwsIHNpemUpO1xuXHQgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xuXG5cdCAgcmV0dXJuIGNhbnZhc0VsXG5cdH07XG5cblx0ZXhwb3J0cy5yZW5kZXJUb0RhdGFVUkwgPSBmdW5jdGlvbiByZW5kZXJUb0RhdGFVUkwgKHFyRGF0YSwgY2FudmFzLCBvcHRpb25zKSB7XG5cdCAgdmFyIG9wdHMgPSBvcHRpb25zO1xuXG5cdCAgaWYgKHR5cGVvZiBvcHRzID09PSAndW5kZWZpbmVkJyAmJiAoIWNhbnZhcyB8fCAhY2FudmFzLmdldENvbnRleHQpKSB7XG5cdCAgICBvcHRzID0gY2FudmFzO1xuXHQgICAgY2FudmFzID0gdW5kZWZpbmVkO1xuXHQgIH1cblxuXHQgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuXG5cdCAgdmFyIGNhbnZhc0VsID0gZXhwb3J0cy5yZW5kZXIocXJEYXRhLCBjYW52YXMsIG9wdHMpO1xuXG5cdCAgdmFyIHR5cGUgPSBvcHRzLnR5cGUgfHwgJ2ltYWdlL3BuZyc7XG5cdCAgdmFyIHJlbmRlcmVyT3B0cyA9IG9wdHMucmVuZGVyZXJPcHRzIHx8IHt9O1xuXG5cdCAgcmV0dXJuIGNhbnZhc0VsLnRvRGF0YVVSTCh0eXBlLCByZW5kZXJlck9wdHMucXVhbGl0eSlcblx0fTtcblxuXHR9LHtcIi4vdXRpbHNcIjoyN31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblx0dmFyIFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5cdGZ1bmN0aW9uIGdldENvbG9yQXR0cmliIChjb2xvciwgYXR0cmliKSB7XG5cdCAgdmFyIGFscGhhID0gY29sb3IuYSAvIDI1NTtcblx0ICB2YXIgc3RyID0gYXR0cmliICsgJz1cIicgKyBjb2xvci5oZXggKyAnXCInO1xuXG5cdCAgcmV0dXJuIGFscGhhIDwgMVxuXHQgICAgPyBzdHIgKyAnICcgKyBhdHRyaWIgKyAnLW9wYWNpdHk9XCInICsgYWxwaGEudG9GaXhlZCgyKS5zbGljZSgxKSArICdcIidcblx0ICAgIDogc3RyXG5cdH1cblxuXHRmdW5jdGlvbiBzdmdDbWQgKGNtZCwgeCwgeSkge1xuXHQgIHZhciBzdHIgPSBjbWQgKyB4O1xuXHQgIGlmICh0eXBlb2YgeSAhPT0gJ3VuZGVmaW5lZCcpIHN0ciArPSAnICcgKyB5O1xuXG5cdCAgcmV0dXJuIHN0clxuXHR9XG5cblx0ZnVuY3Rpb24gcXJUb1BhdGggKGRhdGEsIHNpemUsIG1hcmdpbikge1xuXHQgIHZhciBwYXRoID0gJyc7XG5cdCAgdmFyIG1vdmVCeSA9IDA7XG5cdCAgdmFyIG5ld1JvdyA9IGZhbHNlO1xuXHQgIHZhciBsaW5lTGVuZ3RoID0gMDtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIGNvbCA9IE1hdGguZmxvb3IoaSAlIHNpemUpO1xuXHQgICAgdmFyIHJvdyA9IE1hdGguZmxvb3IoaSAvIHNpemUpO1xuXG5cdCAgICBpZiAoIWNvbCAmJiAhbmV3Um93KSBuZXdSb3cgPSB0cnVlO1xuXG5cdCAgICBpZiAoZGF0YVtpXSkge1xuXHQgICAgICBsaW5lTGVuZ3RoKys7XG5cblx0ICAgICAgaWYgKCEoaSA+IDAgJiYgY29sID4gMCAmJiBkYXRhW2kgLSAxXSkpIHtcblx0ICAgICAgICBwYXRoICs9IG5ld1Jvd1xuXHQgICAgICAgICAgPyBzdmdDbWQoJ00nLCBjb2wgKyBtYXJnaW4sIDAuNSArIHJvdyArIG1hcmdpbilcblx0ICAgICAgICAgIDogc3ZnQ21kKCdtJywgbW92ZUJ5LCAwKTtcblxuXHQgICAgICAgIG1vdmVCeSA9IDA7XG5cdCAgICAgICAgbmV3Um93ID0gZmFsc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIShjb2wgKyAxIDwgc2l6ZSAmJiBkYXRhW2kgKyAxXSkpIHtcblx0ICAgICAgICBwYXRoICs9IHN2Z0NtZCgnaCcsIGxpbmVMZW5ndGgpO1xuXHQgICAgICAgIGxpbmVMZW5ndGggPSAwO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBtb3ZlQnkrKztcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gcGF0aFxuXHR9XG5cblx0ZXhwb3J0cy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHFyRGF0YSwgb3B0aW9ucywgY2IpIHtcblx0ICB2YXIgb3B0cyA9IFV0aWxzLmdldE9wdGlvbnMob3B0aW9ucyk7XG5cdCAgdmFyIHNpemUgPSBxckRhdGEubW9kdWxlcy5zaXplO1xuXHQgIHZhciBkYXRhID0gcXJEYXRhLm1vZHVsZXMuZGF0YTtcblx0ICB2YXIgcXJjb2Rlc2l6ZSA9IHNpemUgKyBvcHRzLm1hcmdpbiAqIDI7XG5cblx0ICB2YXIgYmcgPSAhb3B0cy5jb2xvci5saWdodC5hXG5cdCAgICA/ICcnXG5cdCAgICA6ICc8cGF0aCAnICsgZ2V0Q29sb3JBdHRyaWIob3B0cy5jb2xvci5saWdodCwgJ2ZpbGwnKSArXG5cdCAgICAgICcgZD1cIk0wIDBoJyArIHFyY29kZXNpemUgKyAndicgKyBxcmNvZGVzaXplICsgJ0gwelwiLz4nO1xuXG5cdCAgdmFyIHBhdGggPVxuXHQgICAgJzxwYXRoICcgKyBnZXRDb2xvckF0dHJpYihvcHRzLmNvbG9yLmRhcmssICdzdHJva2UnKSArXG5cdCAgICAnIGQ9XCInICsgcXJUb1BhdGgoZGF0YSwgc2l6ZSwgb3B0cy5tYXJnaW4pICsgJ1wiLz4nO1xuXG5cdCAgdmFyIHZpZXdCb3ggPSAndmlld0JveD1cIicgKyAnMCAwICcgKyBxcmNvZGVzaXplICsgJyAnICsgcXJjb2Rlc2l6ZSArICdcIic7XG5cblx0ICB2YXIgd2lkdGggPSAhb3B0cy53aWR0aCA/ICcnIDogJ3dpZHRoPVwiJyArIG9wdHMud2lkdGggKyAnXCIgaGVpZ2h0PVwiJyArIG9wdHMud2lkdGggKyAnXCIgJztcblxuXHQgIHZhciBzdmdUYWcgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArIHdpZHRoICsgdmlld0JveCArICcgc2hhcGUtcmVuZGVyaW5nPVwiY3Jpc3BFZGdlc1wiPicgKyBiZyArIHBhdGggKyAnPC9zdmc+XFxuJztcblxuXHQgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIGNiKG51bGwsIHN2Z1RhZyk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHN2Z1RhZ1xuXHR9O1xuXG5cdH0se1wiLi91dGlsc1wiOjI3fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHRmdW5jdGlvbiBoZXgycmdiYSAoaGV4KSB7XG5cdCAgaWYgKHR5cGVvZiBoZXggPT09ICdudW1iZXInKSB7XG5cdCAgICBoZXggPSBoZXgudG9TdHJpbmcoKTtcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignQ29sb3Igc2hvdWxkIGJlIGRlZmluZWQgYXMgaGV4IHN0cmluZycpXG5cdCAgfVxuXG5cdCAgdmFyIGhleENvZGUgPSBoZXguc2xpY2UoKS5yZXBsYWNlKCcjJywgJycpLnNwbGl0KCcnKTtcblx0ICBpZiAoaGV4Q29kZS5sZW5ndGggPCAzIHx8IGhleENvZGUubGVuZ3RoID09PSA1IHx8IGhleENvZGUubGVuZ3RoID4gOCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBjb2xvcjogJyArIGhleClcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGZyb20gc2hvcnQgdG8gbG9uZyBmb3JtIChmZmYgLT4gZmZmZmZmKVxuXHQgIGlmIChoZXhDb2RlLmxlbmd0aCA9PT0gMyB8fCBoZXhDb2RlLmxlbmd0aCA9PT0gNCkge1xuXHQgICAgaGV4Q29kZSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGhleENvZGUubWFwKGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgIHJldHVybiBbYywgY11cblx0ICAgIH0pKTtcblx0ICB9XG5cblx0ICAvLyBBZGQgZGVmYXVsdCBhbHBoYSB2YWx1ZVxuXHQgIGlmIChoZXhDb2RlLmxlbmd0aCA9PT0gNikgaGV4Q29kZS5wdXNoKCdGJywgJ0YnKTtcblxuXHQgIHZhciBoZXhWYWx1ZSA9IHBhcnNlSW50KGhleENvZGUuam9pbignJyksIDE2KTtcblxuXHQgIHJldHVybiB7XG5cdCAgICByOiAoaGV4VmFsdWUgPj4gMjQpICYgMjU1LFxuXHQgICAgZzogKGhleFZhbHVlID4+IDE2KSAmIDI1NSxcblx0ICAgIGI6IChoZXhWYWx1ZSA+PiA4KSAmIDI1NSxcblx0ICAgIGE6IGhleFZhbHVlICYgMjU1LFxuXHQgICAgaGV4OiAnIycgKyBoZXhDb2RlLnNsaWNlKDAsIDYpLmpvaW4oJycpXG5cdCAgfVxuXHR9XG5cblx0ZXhwb3J0cy5nZXRPcHRpb25zID0gZnVuY3Rpb24gZ2V0T3B0aW9ucyAob3B0aW9ucykge1xuXHQgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXHQgIGlmICghb3B0aW9ucy5jb2xvcikgb3B0aW9ucy5jb2xvciA9IHt9O1xuXG5cdCAgdmFyIG1hcmdpbiA9IHR5cGVvZiBvcHRpb25zLm1hcmdpbiA9PT0gJ3VuZGVmaW5lZCcgfHxcblx0ICAgIG9wdGlvbnMubWFyZ2luID09PSBudWxsIHx8XG5cdCAgICBvcHRpb25zLm1hcmdpbiA8IDAgPyA0IDogb3B0aW9ucy5tYXJnaW47XG5cblx0ICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoICYmIG9wdGlvbnMud2lkdGggPj0gMjEgPyBvcHRpb25zLndpZHRoIDogdW5kZWZpbmVkO1xuXHQgIHZhciBzY2FsZSA9IG9wdGlvbnMuc2NhbGUgfHwgNDtcblxuXHQgIHJldHVybiB7XG5cdCAgICB3aWR0aDogd2lkdGgsXG5cdCAgICBzY2FsZTogd2lkdGggPyA0IDogc2NhbGUsXG5cdCAgICBtYXJnaW46IG1hcmdpbixcblx0ICAgIGNvbG9yOiB7XG5cdCAgICAgIGRhcms6IGhleDJyZ2JhKG9wdGlvbnMuY29sb3IuZGFyayB8fCAnIzAwMDAwMGZmJyksXG5cdCAgICAgIGxpZ2h0OiBoZXgycmdiYShvcHRpb25zLmNvbG9yLmxpZ2h0IHx8ICcjZmZmZmZmZmYnKVxuXHQgICAgfSxcblx0ICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcblx0ICAgIHJlbmRlcmVyT3B0czogb3B0aW9ucy5yZW5kZXJlck9wdHMgfHwge31cblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5nZXRTY2FsZSA9IGZ1bmN0aW9uIGdldFNjYWxlIChxclNpemUsIG9wdHMpIHtcblx0ICByZXR1cm4gb3B0cy53aWR0aCAmJiBvcHRzLndpZHRoID49IHFyU2l6ZSArIG9wdHMubWFyZ2luICogMlxuXHQgICAgPyBvcHRzLndpZHRoIC8gKHFyU2l6ZSArIG9wdHMubWFyZ2luICogMilcblx0ICAgIDogb3B0cy5zY2FsZVxuXHR9O1xuXG5cdGV4cG9ydHMuZ2V0SW1hZ2VXaWR0aCA9IGZ1bmN0aW9uIGdldEltYWdlV2lkdGggKHFyU2l6ZSwgb3B0cykge1xuXHQgIHZhciBzY2FsZSA9IGV4cG9ydHMuZ2V0U2NhbGUocXJTaXplLCBvcHRzKTtcblx0ICByZXR1cm4gTWF0aC5mbG9vcigocXJTaXplICsgb3B0cy5tYXJnaW4gKiAyKSAqIHNjYWxlKVxuXHR9O1xuXG5cdGV4cG9ydHMucXJUb0ltYWdlRGF0YSA9IGZ1bmN0aW9uIHFyVG9JbWFnZURhdGEgKGltZ0RhdGEsIHFyLCBvcHRzKSB7XG5cdCAgdmFyIHNpemUgPSBxci5tb2R1bGVzLnNpemU7XG5cdCAgdmFyIGRhdGEgPSBxci5tb2R1bGVzLmRhdGE7XG5cdCAgdmFyIHNjYWxlID0gZXhwb3J0cy5nZXRTY2FsZShzaXplLCBvcHRzKTtcblx0ICB2YXIgc3ltYm9sU2l6ZSA9IE1hdGguZmxvb3IoKHNpemUgKyBvcHRzLm1hcmdpbiAqIDIpICogc2NhbGUpO1xuXHQgIHZhciBzY2FsZWRNYXJnaW4gPSBvcHRzLm1hcmdpbiAqIHNjYWxlO1xuXHQgIHZhciBwYWxldHRlID0gW29wdHMuY29sb3IubGlnaHQsIG9wdHMuY29sb3IuZGFya107XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbFNpemU7IGkrKykge1xuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzeW1ib2xTaXplOyBqKyspIHtcblx0ICAgICAgdmFyIHBvc0RzdCA9IChpICogc3ltYm9sU2l6ZSArIGopICogNDtcblx0ICAgICAgdmFyIHB4Q29sb3IgPSBvcHRzLmNvbG9yLmxpZ2h0O1xuXG5cdCAgICAgIGlmIChpID49IHNjYWxlZE1hcmdpbiAmJiBqID49IHNjYWxlZE1hcmdpbiAmJlxuXHQgICAgICAgIGkgPCBzeW1ib2xTaXplIC0gc2NhbGVkTWFyZ2luICYmIGogPCBzeW1ib2xTaXplIC0gc2NhbGVkTWFyZ2luKSB7XG5cdCAgICAgICAgdmFyIGlTcmMgPSBNYXRoLmZsb29yKChpIC0gc2NhbGVkTWFyZ2luKSAvIHNjYWxlKTtcblx0ICAgICAgICB2YXIgalNyYyA9IE1hdGguZmxvb3IoKGogLSBzY2FsZWRNYXJnaW4pIC8gc2NhbGUpO1xuXHQgICAgICAgIHB4Q29sb3IgPSBwYWxldHRlW2RhdGFbaVNyYyAqIHNpemUgKyBqU3JjXSA/IDEgOiAwXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGltZ0RhdGFbcG9zRHN0KytdID0gcHhDb2xvci5yO1xuXHQgICAgICBpbWdEYXRhW3Bvc0RzdCsrXSA9IHB4Q29sb3IuZztcblx0ICAgICAgaW1nRGF0YVtwb3NEc3QrK10gPSBweENvbG9yLmI7XG5cdCAgICAgIGltZ0RhdGFbcG9zRHN0XSA9IHB4Q29sb3IuYTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0fSx7fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG5cdHZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG5cdGZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcblx0ICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGJlIGF1Z21lbnRlZD9cblx0ICB0cnkge1xuXHQgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpO1xuXHQgICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19O1xuXHQgICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICByZXR1cm4gZmFsc2Vcblx0ICB9XG5cdH1cblxuXHRCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KCk7XG5cblx0dmFyIEtfTUFYX0xFTkdUSCA9IEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG5cdCAgICA/IDB4N2ZmZmZmZmZcblx0ICAgIDogMHgzZmZmZmZmZjtcblxuXHRmdW5jdGlvbiBCdWZmZXIgKGFyZywgb2Zmc2V0LCBsZW5ndGgpIHtcblx0ICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcblx0ICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgb2Zmc2V0LCBsZW5ndGgpXG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG5cdCAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuXHQgIH1cblxuXHQgIHJldHVybiBmcm9tKHRoaXMsIGFyZywgb2Zmc2V0LCBsZW5ndGgpXG5cdH1cblxuXHRpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcblx0ICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlO1xuXHQgIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xuXG5cdCAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcblx0ICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcblx0ICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuXHQgICAgICB2YWx1ZTogbnVsbCxcblx0ICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgd3JpdGFibGU6IGZhbHNlXG5cdCAgICB9KTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcblx0ICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cblx0ICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcblx0ICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuXHQgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuXHQgIH1cblx0ICByZXR1cm4gbGVuZ3RoIHwgMFxuXHR9XG5cblx0ZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuXHQgIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcblx0ICB2YXIgYnVmO1xuXHQgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuXHQgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcblx0ICAgIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG5cdCAgICBidWYgPSB0aGF0O1xuXHQgICAgaWYgKGJ1ZiA9PT0gbnVsbCkge1xuXHQgICAgICBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG5cdCAgICB9XG5cdCAgICBidWYubGVuZ3RoID0gbGVuZ3RoO1xuXHQgIH1cblxuXHQgIHJldHVybiBidWZcblx0fVxuXG5cdGZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG5cdCAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7XG5cblx0ICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuXHQgICAgICBidWZbaV0gPSAwO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBidWZcblx0fVxuXG5cdGZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZykge1xuXHQgIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZykgfCAwO1xuXHQgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKTtcblxuXHQgIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nKTtcblxuXHQgIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuXHQgICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG5cdCAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuXHQgICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG5cdCAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKTtcblx0ICB9XG5cblx0ICByZXR1cm4gYnVmXG5cdH1cblxuXHRmdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuXHQgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDA7XG5cdCAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1O1xuXHQgIH1cblx0ICByZXR1cm4gYnVmXG5cdH1cblxuXHRmdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcblx0ICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG5cdCAgfVxuXG5cdCAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuXHQgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcblx0ICB9XG5cblx0ICB2YXIgYnVmO1xuXHQgIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KTtcblx0ICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuXHQgIH1cblxuXHQgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuXHQgICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG5cdCAgICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuXHQgICAgYnVmID0gZnJvbUFycmF5TGlrZSh0aGF0LCBidWYpO1xuXHQgIH1cblxuXHQgIHJldHVybiBidWZcblx0fVxuXG5cdGZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuXHQgIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuXHQgICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwO1xuXHQgICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pO1xuXG5cdCAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICByZXR1cm4gYnVmXG5cdCAgICB9XG5cblx0ICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKTtcblx0ICAgIHJldHVybiBidWZcblx0ICB9XG5cblx0ICBpZiAob2JqKSB7XG5cdCAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuXHQgICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG5cdCAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcblx0ICAgIH1cblxuXHQgICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuXHQgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcblx0ICAgIH1cblx0ICB9XG5cblx0ICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcblx0fVxuXG5cdGZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG5cdCAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTtcblx0ICB2YXIgY29kZVBvaW50O1xuXHQgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHQgIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbDtcblx0ICB2YXIgYnl0ZXMgPSBbXTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0ICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG5cdCAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG5cdCAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuXHQgICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuXHQgICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcblx0ICAgICAgICAvLyBubyBsZWFkIHlldFxuXHQgICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcblx0ICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcblx0ICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcblx0ICAgICAgICAgIGNvbnRpbnVlXG5cdCAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG5cdCAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG5cdCAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG5cdCAgICAgICAgICBjb250aW51ZVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIHZhbGlkIGxlYWRcblx0ICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuXG5cdCAgICAgICAgY29udGludWVcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcblx0ICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuXHQgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcblx0ICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuXHQgICAgICAgIGNvbnRpbnVlXG5cdCAgICAgIH1cblxuXHQgICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuXHQgICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuXHQgICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG5cdCAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcblx0ICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuXHQgICAgfVxuXG5cdCAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDtcblxuXHQgICAgLy8gZW5jb2RlIHV0Zjhcblx0ICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG5cdCAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuXHQgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCk7XG5cdCAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG5cdCAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXHQgICAgICBieXRlcy5wdXNoKFxuXHQgICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuXHQgICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG5cdCAgICAgICk7XG5cdCAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcblx0ICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG5cdCAgICAgIGJ5dGVzLnB1c2goXG5cdCAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG5cdCAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuXHQgICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG5cdCAgICAgICk7XG5cdCAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG5cdCAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuXHQgICAgICBieXRlcy5wdXNoKFxuXHQgICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcblx0ICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG5cdCAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuXHQgICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG5cdCAgICAgICk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGJ5dGVzXG5cdH1cblxuXHRmdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcpIHtcblx0ICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcblx0ICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcblx0ICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuXHQgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG5cdCAgfVxuXHQgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHQgICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG5cdCAgfVxuXG5cdCAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG5cdCAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuXHQgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuXHR9XG5cblx0ZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHQgICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuXHQgICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuXHQgIH1cblx0ICByZXR1cm4gaVxuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcblx0ICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuXHR9XG5cblx0ZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHQgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgb2Zmc2V0LCBsZW5ndGgpXG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlKVxuXHQgIH1cblxuXHQgIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxuXHR9XG5cblx0QnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcblx0ICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgb2Zmc2V0ID0gMDtcblx0ICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblx0ICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblx0ICAgIG9mZnNldCA9IDA7XG5cdCAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXSlcblx0ICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcblx0ICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG5cdCAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuXHQgICAgICBsZW5ndGggPSBsZW5ndGggfCAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcblx0ICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmc7XG5cblx0ICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuXHQgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcblx0ICB9XG5cblx0ICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cdH07XG5cblx0QnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG5cdCAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXHQgIHN0YXJ0ID0gfn5zdGFydDtcblx0ICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kO1xuXG5cdCAgaWYgKHN0YXJ0IDwgMCkge1xuXHQgICAgc3RhcnQgKz0gbGVuO1xuXHQgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuXHQgIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcblx0ICAgIHN0YXJ0ID0gbGVuO1xuXHQgIH1cblxuXHQgIGlmIChlbmQgPCAwKSB7XG5cdCAgICBlbmQgKz0gbGVuO1xuXHQgICAgaWYgKGVuZCA8IDApIGVuZCA9IDA7XG5cdCAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcblx0ICAgIGVuZCA9IGxlbjtcblx0ICB9XG5cblx0ICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuXG5cdCAgdmFyIG5ld0J1Zjtcblx0ICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcblx0ICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG5cdCAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuXHQgICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0O1xuXHQgICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuXHQgICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF07XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG5ld0J1ZlxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcblx0ICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG5cdCAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aDtcblx0ICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoO1xuXHQgIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcblx0ICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cblx0ICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcblx0ICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcblx0ICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuXHQgIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcblx0ICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG5cdCAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG5cdCAgfVxuXHQgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcblx0ICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuXHQgIC8vIEFyZSB3ZSBvb2I/XG5cdCAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcblx0ICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcblx0ICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0O1xuXHQgIH1cblxuXHQgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcblx0ICB2YXIgaTtcblxuXHQgIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuXHQgICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG5cdCAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuXHQgICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcblx0ICAgIH1cblx0ICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG5cdCAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcblx0ICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF07XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuXHQgICAgICB0YXJnZXQsXG5cdCAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcblx0ICAgICAgdGFyZ2V0U3RhcnRcblx0ICAgICk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGxlblxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCkge1xuXHQgIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG5cdCAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuXHQgICAgICBzdGFydCA9IDA7XG5cdCAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuXHQgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcblx0ICAgIH1cblx0ICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCk7XG5cdCAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG5cdCAgICAgICAgdmFsID0gY29kZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcblx0ICAgIHZhbCA9IHZhbCAmIDI1NTtcblx0ICB9XG5cblx0ICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cblx0ICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuXHQgIH1cblxuXHQgIGlmIChlbmQgPD0gc3RhcnQpIHtcblx0ICAgIHJldHVybiB0aGlzXG5cdCAgfVxuXG5cdCAgc3RhcnQgPSBzdGFydCA+Pj4gMDtcblx0ICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuXG5cdCAgaWYgKCF2YWwpIHZhbCA9IDA7XG5cblx0ICB2YXIgaTtcblx0ICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcblx0ICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcblx0ICAgICAgdGhpc1tpXSA9IHZhbDtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcblx0ICAgICAgPyB2YWxcblx0ICAgICAgOiBuZXcgQnVmZmVyKHZhbCk7XG5cdCAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcblx0ICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXNcblx0fTtcblxuXHRCdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcblx0ICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG5cdCAgfVxuXG5cdCAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gY3JlYXRlQnVmZmVyKG51bGwsIDApXG5cdCAgfVxuXG5cdCAgdmFyIGk7XG5cdCAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBsZW5ndGggPSAwO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBidWZmZXIgPSBhbGxvY1Vuc2FmZShudWxsLCBsZW5ndGgpO1xuXHQgIHZhciBwb3MgPSAwO1xuXHQgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG5cdCAgICB2YXIgYnVmID0gbGlzdFtpXTtcblx0ICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcblx0ICAgIH1cblx0ICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcblx0ICAgIHBvcyArPSBidWYubGVuZ3RoO1xuXHQgIH1cblx0ICByZXR1cm4gYnVmZmVyXG5cdH07XG5cblx0QnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTtcblx0QnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcblx0ICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzLmFsbG9jID0gZnVuY3Rpb24gKHNpemUpIHtcblx0ICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihzaXplKTtcblx0ICBidWZmZXIuZmlsbCgwKTtcblx0ICByZXR1cm4gYnVmZmVyXG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMuZnJvbSA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSlcblx0fTtcblxuXHR9LHtcImlzYXJyYXlcIjozM31dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuXHRleHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXk7XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXk7XG5cblx0dmFyIGxvb2t1cCA9IFtdO1xuXHR2YXIgcmV2TG9va3VwID0gW107XG5cdHZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXk7XG5cblx0dmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdCAgbG9va3VwW2ldID0gY29kZVtpXTtcblx0ICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG5cdH1cblxuXHQvLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG5cdC8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcblx0cmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyO1xuXHRyZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjM7XG5cblx0ZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG5cdCAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cblx0ICBpZiAobGVuICUgNCA+IDApIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdCAgfVxuXG5cdCAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG5cdCAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG5cdCAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKTtcblx0ICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlbjtcblxuXHQgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG5cdCAgICA/IDBcblx0ICAgIDogNCAtICh2YWxpZExlbiAlIDQpO1xuXG5cdCAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxuXHR9XG5cblx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdGZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuXHQgIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpO1xuXHQgIHZhciB2YWxpZExlbiA9IGxlbnNbMF07XG5cdCAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV07XG5cdCAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG5cdH1cblxuXHRmdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG5cdCAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG5cdH1cblxuXHRmdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG5cdCAgdmFyIHRtcDtcblx0ICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTtcblx0ICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdO1xuXHQgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdO1xuXG5cdCAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSk7XG5cblx0ICB2YXIgY3VyQnl0ZSA9IDA7XG5cblx0ICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdCAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcblx0ICAgID8gdmFsaWRMZW4gLSA0XG5cdCAgICA6IHZhbGlkTGVuO1xuXG5cdCAgdmFyIGk7XG5cdCAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG5cdCAgICB0bXAgPVxuXHQgICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuXHQgICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcblx0ICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcblx0ICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG5cdCAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRjtcblx0ICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG5cdCAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkY7XG5cdCAgfVxuXG5cdCAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuXHQgICAgdG1wID1cblx0ICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuXHQgICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCk7XG5cdCAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkY7XG5cdCAgfVxuXG5cdCAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuXHQgICAgdG1wID1cblx0ICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcblx0ICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcblx0ICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpO1xuXHQgICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRjtcblx0ICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRjtcblx0ICB9XG5cblx0ICByZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHQgIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuXHQgICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcblx0ICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcblx0ICAgIGxvb2t1cFtudW0gJiAweDNGXVxuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG5cdCAgdmFyIHRtcDtcblx0ICB2YXIgb3V0cHV0ID0gW107XG5cdCAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcblx0ICAgIHRtcCA9XG5cdCAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcblx0ICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcblx0ICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpO1xuXHQgICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuXHQgIH1cblx0ICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG5cdH1cblxuXHRmdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuXHQgIHZhciB0bXA7XG5cdCAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcblx0ICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDM7IC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdCAgdmFyIHBhcnRzID0gW107XG5cdCAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7IC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG5cdCAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHQgIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcblx0ICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG5cdCAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcblx0ICAgICkpO1xuXHQgIH1cblxuXHQgIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0ICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuXHQgICAgdG1wID0gdWludDhbbGVuIC0gMV07XG5cdCAgICBwYXJ0cy5wdXNoKFxuXHQgICAgICBsb29rdXBbdG1wID4+IDJdICtcblx0ICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG5cdCAgICAgICc9PSdcblx0ICAgICk7XG5cdCAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG5cdCAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXTtcblx0ICAgIHBhcnRzLnB1c2goXG5cdCAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcblx0ICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG5cdCAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuXHQgICAgICAnPSdcblx0ICAgICk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG5cdH1cblxuXHR9LHt9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cblx0dmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpO1xuXHR2YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKTtcblx0dmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuXHQgICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKVxuXHQgICAgPyBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXG5cdCAgICA6IG51bGw7XG5cblx0ZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG5cdGV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXI7XG5cdGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuXHR2YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZjtcblx0ZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIO1xuXG5cdC8qKlxuXHQgKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuXHQgKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuXHQgKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3Rcblx0ICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcblx0ICpcblx0ICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuXHQgKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG5cdCAqXG5cdCAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuXHQgKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG5cdCAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcblx0ICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG5cdCAqL1xuXHRCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KCk7XG5cblx0aWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgY29uc29sZS5lcnJvcihcblx0ICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG5cdCAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG5cdCAgKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcblx0ICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKTtcblx0ICAgIHZhciBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH07XG5cdCAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKTtcblx0ICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKTtcblx0ICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgICAgcmV0dXJuIGZhbHNlXG5cdCAgfVxuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG5cdCAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG5cdCAgICByZXR1cm4gdGhpcy5idWZmZXJcblx0ICB9XG5cdH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuXHQgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuXHQgICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuXHQgIH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcblx0ICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG5cdCAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuXHQgIH1cblx0ICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuXHQgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHQgIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpO1xuXHQgIHJldHVybiBidWZcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcblx0ICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuXHQgKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG5cdCAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG5cdCAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG5cdCAqXG5cdCAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cblx0ICovXG5cblx0ZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuXHQgIC8vIENvbW1vbiBjYXNlLlxuXHQgIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuXHQgICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuXHQgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHQgICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcblx0ICAgICAgKVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcblx0ICB9XG5cdCAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG5cdH1cblxuXHQvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuXHQgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG5cdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcblx0ICAgIHZhbHVlOiBudWxsLFxuXHQgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICB3cml0YWJsZTogZmFsc2Vcblx0ICB9KTtcblx0fVxuXG5cdEJ1ZmZlci5wb29sU2l6ZSA9IDgxOTI7IC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuXHRmdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuXHQgIH1cblxuXHQgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcblx0ICB9XG5cblx0ICBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcblx0ICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuXHQgICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG5cdCAgICApXG5cdCAgfVxuXG5cdCAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuXHQgICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcblx0ICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcblx0ICB9XG5cblx0ICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcblx0ICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuXHQgICAgKVxuXHQgIH1cblxuXHQgIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKCk7XG5cdCAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuXHQgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcblx0ICB9XG5cblx0ICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpO1xuXHQgIGlmIChiKSByZXR1cm4gYlxuXG5cdCAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG5cdCAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICByZXR1cm4gQnVmZmVyLmZyb20oXG5cdCAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcblx0ICAgIClcblx0ICB9XG5cblx0ICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuXHQgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuXHQgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuXHQgIClcblx0fVxuXG5cdC8qKlxuXHQgKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuXHQgKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cblx0ICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuXHQgKiBCdWZmZXIuZnJvbShhcnJheSlcblx0ICogQnVmZmVyLmZyb20oYnVmZmVyKVxuXHQgKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcblx0ICoqL1xuXHRCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcblx0fTtcblxuXHQvLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSk7XG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpO1xuXG5cdGZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcblx0ICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcblx0ICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG5cdCAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcblx0ICBhc3NlcnRTaXplKHNpemUpO1xuXHQgIGlmIChzaXplIDw9IDApIHtcblx0ICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcblx0ICB9XG5cdCAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcblx0ICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcblx0ICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cblx0ICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG5cdCAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG5cdCAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcblx0ICB9XG5cdCAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cblx0ICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuXHQgKiovXG5cdEJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuXHQgIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcblx0fTtcblxuXHRmdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuXHQgIGFzc2VydFNpemUoc2l6ZSk7XG5cdCAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcblx0fVxuXG5cdC8qKlxuXHQgKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuXHQgKiAqL1xuXHRCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuXHQgIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxuXHR9O1xuXHQvKipcblx0ICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG5cdCAqL1xuXHRCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcblx0ICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcblx0fTtcblxuXHRmdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG5cdCAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG5cdCAgICBlbmNvZGluZyA9ICd1dGY4Jztcblx0ICB9XG5cblx0ICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuXHQgIH1cblxuXHQgIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDtcblx0ICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCk7XG5cblx0ICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpO1xuXG5cdCAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG5cdCAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcblx0ICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG5cdCAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcblx0ICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpO1xuXHQgIH1cblxuXHQgIHJldHVybiBidWZcblx0fVxuXG5cdGZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG5cdCAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcblx0ICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTU7XG5cdCAgfVxuXHQgIHJldHVybiBidWZcblx0fVxuXG5cdGZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuXHQgIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuXHQgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcblx0ICB9XG5cblx0ICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG5cdCAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuXHQgIH1cblxuXHQgIHZhciBidWY7XG5cdCAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuXHQgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuXHQgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2Vcblx0ICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKTtcblxuXHQgIHJldHVybiBidWZcblx0fVxuXG5cdGZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuXHQgIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuXHQgICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwO1xuXHQgICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pO1xuXG5cdCAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICByZXR1cm4gYnVmXG5cdCAgICB9XG5cblx0ICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKTtcblx0ICAgIHJldHVybiBidWZcblx0ICB9XG5cblx0ICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG5cdCAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcblx0ICAgIH1cblx0ICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcblx0ICB9XG5cblx0ICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG5cdCAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcblx0ICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cblx0ICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcblx0ICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuXHQgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuXHQgIH1cblx0ICByZXR1cm4gbGVuZ3RoIHwgMFxuXHR9XG5cblx0ZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG5cdCAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG5cdCAgICBsZW5ndGggPSAwO1xuXHQgIH1cblx0ICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG5cdH1cblxuXHRCdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuXHQgIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcblx0ICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcblx0fTtcblxuXHRCdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcblx0ICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpO1xuXHQgIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG5cdCAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcblx0ICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG5cdCAgICApXG5cdCAgfVxuXG5cdCAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cblx0ICB2YXIgeCA9IGEubGVuZ3RoO1xuXHQgIHZhciB5ID0gYi5sZW5ndGg7XG5cblx0ICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuXHQgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcblx0ICAgICAgeCA9IGFbaV07XG5cdCAgICAgIHkgPSBiW2ldO1xuXHQgICAgICBicmVha1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmICh4IDwgeSkgcmV0dXJuIC0xXG5cdCAgaWYgKHkgPCB4KSByZXR1cm4gMVxuXHQgIHJldHVybiAwXG5cdH07XG5cblx0QnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuXHQgIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG5cdCAgICBjYXNlICdoZXgnOlxuXHQgICAgY2FzZSAndXRmOCc6XG5cdCAgICBjYXNlICd1dGYtOCc6XG5cdCAgICBjYXNlICdhc2NpaSc6XG5cdCAgICBjYXNlICdsYXRpbjEnOlxuXHQgICAgY2FzZSAnYmluYXJ5Jzpcblx0ICAgIGNhc2UgJ2Jhc2U2NCc6XG5cdCAgICBjYXNlICd1Y3MyJzpcblx0ICAgIGNhc2UgJ3Vjcy0yJzpcblx0ICAgIGNhc2UgJ3V0ZjE2bGUnOlxuXHQgICAgY2FzZSAndXRmLTE2bGUnOlxuXHQgICAgICByZXR1cm4gdHJ1ZVxuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgcmV0dXJuIGZhbHNlXG5cdCAgfVxuXHR9O1xuXG5cdEJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuXHQgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcblx0ICB9XG5cblx0ICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcblx0ICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcblx0ICB9XG5cblx0ICB2YXIgaTtcblx0ICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGxlbmd0aCA9IDA7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuXHQgICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuXHQgIHZhciBwb3MgPSAwO1xuXHQgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG5cdCAgICB2YXIgYnVmID0gbGlzdFtpXTtcblx0ICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcblx0ICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKTtcblx0ICAgIH1cblx0ICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcblx0ICAgIH1cblx0ICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcblx0ICAgIHBvcyArPSBidWYubGVuZ3RoO1xuXHQgIH1cblx0ICByZXR1cm4gYnVmZmVyXG5cdH07XG5cblx0ZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuXHQgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuXHQgICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcblx0ICB9XG5cdCAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcblx0ICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuXHQgIH1cblx0ICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG5cdCAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG5cdCAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG5cdCAgICApXG5cdCAgfVxuXG5cdCAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG5cdCAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpO1xuXHQgIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuXHQgIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuXHQgIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuXHQgIGZvciAoOzspIHtcblx0ICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcblx0ICAgICAgY2FzZSAnYXNjaWknOlxuXHQgICAgICBjYXNlICdsYXRpbjEnOlxuXHQgICAgICBjYXNlICdiaW5hcnknOlxuXHQgICAgICAgIHJldHVybiBsZW5cblx0ICAgICAgY2FzZSAndXRmOCc6XG5cdCAgICAgIGNhc2UgJ3V0Zi04Jzpcblx0ICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcblx0ICAgICAgY2FzZSAndWNzMic6XG5cdCAgICAgIGNhc2UgJ3Vjcy0yJzpcblx0ICAgICAgY2FzZSAndXRmMTZsZSc6XG5cdCAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcblx0ICAgICAgICByZXR1cm4gbGVuICogMlxuXHQgICAgICBjYXNlICdoZXgnOlxuXHQgICAgICAgIHJldHVybiBsZW4gPj4+IDFcblx0ICAgICAgY2FzZSAnYmFzZTY0Jzpcblx0ICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuXHQgICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0Zjhcblx0ICAgICAgICB9XG5cdCAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdEJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuXHRmdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG5cdCAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG5cblx0ICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcblx0ICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG5cdCAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG5cdCAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuXHQgIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG5cdCAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG5cdCAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG5cdCAgICBzdGFydCA9IDA7XG5cdCAgfVxuXHQgIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG5cdCAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cblx0ICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuXHQgICAgcmV0dXJuICcnXG5cdCAgfVxuXG5cdCAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG5cdCAgICBlbmQgPSB0aGlzLmxlbmd0aDtcblx0ICB9XG5cblx0ICBpZiAoZW5kIDw9IDApIHtcblx0ICAgIHJldHVybiAnJ1xuXHQgIH1cblxuXHQgIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG5cdCAgZW5kID4+Pj0gMDtcblx0ICBzdGFydCA+Pj49IDA7XG5cblx0ICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG5cdCAgICByZXR1cm4gJydcblx0ICB9XG5cblx0ICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4JztcblxuXHQgIHdoaWxlICh0cnVlKSB7XG5cdCAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG5cdCAgICAgIGNhc2UgJ2hleCc6XG5cdCAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cblx0ICAgICAgY2FzZSAndXRmOCc6XG5cdCAgICAgIGNhc2UgJ3V0Zi04Jzpcblx0ICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cblx0ICAgICAgY2FzZSAnYXNjaWknOlxuXHQgICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cblx0ICAgICAgY2FzZSAnbGF0aW4xJzpcblx0ICAgICAgY2FzZSAnYmluYXJ5Jzpcblx0ICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuXHQgICAgICBjYXNlICdiYXNlNjQnOlxuXHQgICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG5cdCAgICAgIGNhc2UgJ3VjczInOlxuXHQgICAgICBjYXNlICd1Y3MtMic6XG5cdCAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuXHQgICAgICBjYXNlICd1dGYtMTZsZSc6XG5cdCAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG5cdCAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0Ly8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuXHQvLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG5cdC8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG5cdC8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuXHQvLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG5cdC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuXHRCdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7XG5cblx0ZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuXHQgIHZhciBpID0gYltuXTtcblx0ICBiW25dID0gYlttXTtcblx0ICBiW21dID0gaTtcblx0fVxuXG5cdEJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcblx0ICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cdCAgaWYgKGxlbiAlIDIgIT09IDApIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG5cdCAgfVxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcblx0ICAgIHN3YXAodGhpcywgaSwgaSArIDEpO1xuXHQgIH1cblx0ICByZXR1cm4gdGhpc1xuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcblx0ICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cdCAgaWYgKGxlbiAlIDQgIT09IDApIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG5cdCAgfVxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcblx0ICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuXHQgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpO1xuXHQgIH1cblx0ICByZXR1cm4gdGhpc1xuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcblx0ICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cdCAgaWYgKGxlbiAlIDggIT09IDApIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG5cdCAgfVxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcblx0ICAgIHN3YXAodGhpcywgaSwgaSArIDcpO1xuXHQgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuXHQgICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpO1xuXHQgICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpO1xuXHQgIH1cblx0ICByZXR1cm4gdGhpc1xuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG5cdCAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXHQgIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcblx0ICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0fTtcblxuXHRCdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZztcblxuXHRCdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuXHQgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcblx0ICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcblx0ICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcblx0fTtcblxuXHRCdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcblx0ICB2YXIgc3RyID0gJyc7XG5cdCAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVM7XG5cdCAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKTtcblx0ICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnO1xuXHQgIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG5cdH07XG5cdGlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG5cdCAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdDtcblx0fVxuXG5cdEJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG5cdCAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuXHQgICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aCk7XG5cdCAgfVxuXHQgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG5cdCAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcblx0ICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuXHQgICAgKVxuXHQgIH1cblxuXHQgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBzdGFydCA9IDA7XG5cdCAgfVxuXHQgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDA7XG5cdCAgfVxuXHQgIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgdGhpc1N0YXJ0ID0gMDtcblx0ICB9XG5cdCAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoO1xuXHQgIH1cblxuXHQgIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuXHQgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG5cdCAgfVxuXG5cdCAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuXHQgICAgcmV0dXJuIDBcblx0ICB9XG5cdCAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG5cdCAgICByZXR1cm4gLTFcblx0ICB9XG5cdCAgaWYgKHN0YXJ0ID49IGVuZCkge1xuXHQgICAgcmV0dXJuIDFcblx0ICB9XG5cblx0ICBzdGFydCA+Pj49IDA7XG5cdCAgZW5kID4+Pj0gMDtcblx0ICB0aGlzU3RhcnQgPj4+PSAwO1xuXHQgIHRoaXNFbmQgPj4+PSAwO1xuXG5cdCAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuXHQgIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDtcblx0ICB2YXIgeSA9IGVuZCAtIHN0YXJ0O1xuXHQgIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KTtcblxuXHQgIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKTtcblx0ICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcblx0ICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuXHQgICAgICB4ID0gdGhpc0NvcHlbaV07XG5cdCAgICAgIHkgPSB0YXJnZXRDb3B5W2ldO1xuXHQgICAgICBicmVha1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmICh4IDwgeSkgcmV0dXJuIC0xXG5cdCAgaWYgKHkgPCB4KSByZXR1cm4gMVxuXHQgIHJldHVybiAwXG5cdH07XG5cblx0Ly8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuXHQvLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuXHQvL1xuXHQvLyBBcmd1bWVudHM6XG5cdC8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG5cdC8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG5cdC8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuXHQvLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuXHQvLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuXHRmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcblx0ICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcblx0ICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cblx0ICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuXHQgIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcblx0ICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDtcblx0ICAgIGJ5dGVPZmZzZXQgPSAwO1xuXHQgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcblx0ICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmO1xuXHQgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG5cdCAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDA7XG5cdCAgfVxuXHQgIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgLy8gQ29lcmNlIHRvIE51bWJlci5cblx0ICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcblx0ICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuXHQgICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpO1xuXHQgIH1cblxuXHQgIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG5cdCAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7XG5cdCAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuXHQgICAgaWYgKGRpcikgcmV0dXJuIC0xXG5cdCAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMTtcblx0ICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG5cdCAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtcblx0ICAgIGVsc2UgcmV0dXJuIC0xXG5cdCAgfVxuXG5cdCAgLy8gTm9ybWFsaXplIHZhbFxuXHQgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuXHQgICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZyk7XG5cdCAgfVxuXG5cdCAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2Zcblx0ICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcblx0ICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcblx0ICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgIHJldHVybiAtMVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcblx0ICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG5cdCAgICB2YWwgPSB2YWwgJiAweEZGOyAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG5cdCAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgaWYgKGRpcikge1xuXHQgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcblx0ICB9XG5cblx0ICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxuXHR9XG5cblx0ZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuXHQgIHZhciBpbmRleFNpemUgPSAxO1xuXHQgIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoO1xuXHQgIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xuXG5cdCAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcblx0ICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG5cdCAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuXHQgICAgICAgIHJldHVybiAtMVxuXHQgICAgICB9XG5cdCAgICAgIGluZGV4U2l6ZSA9IDI7XG5cdCAgICAgIGFyckxlbmd0aCAvPSAyO1xuXHQgICAgICB2YWxMZW5ndGggLz0gMjtcblx0ICAgICAgYnl0ZU9mZnNldCAvPSAyO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuXHQgICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuXHQgICAgICByZXR1cm4gYnVmW2ldXG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBpO1xuXHQgIGlmIChkaXIpIHtcblx0ICAgIHZhciBmb3VuZEluZGV4ID0gLTE7XG5cdCAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuXHQgICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGk7XG5cdCAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleDtcblx0ICAgICAgICBmb3VuZEluZGV4ID0gLTE7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGg7XG5cdCAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuXHQgICAgICB2YXIgZm91bmQgPSB0cnVlO1xuXHQgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuXHQgICAgICAgICAgZm91bmQgPSBmYWxzZTtcblx0ICAgICAgICAgIGJyZWFrXG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gLTFcblx0fVxuXG5cdEJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuXHQgIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG5cdH07XG5cblx0QnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuXHQgIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuXHQgIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcblx0fTtcblxuXHRmdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMDtcblx0ICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldDtcblx0ICBpZiAoIWxlbmd0aCkge1xuXHQgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcblx0ICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcblx0ICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuXG5cdCAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcblx0ICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7XG5cdCAgfVxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0ICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuXHQgICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG5cdCAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQ7XG5cdCAgfVxuXHQgIHJldHVybiBpXG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuXHQgIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG5cdH1cblxuXHRmdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcblx0ICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcblx0fVxuXG5cdGZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcblx0ICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cdH1cblxuXHRmdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuXHR9XG5cblx0ZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcblx0ICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuXHR9XG5cblx0QnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuXHQgIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG5cdCAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBlbmNvZGluZyA9ICd1dGY4Jztcblx0ICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgb2Zmc2V0ID0gMDtcblx0ICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblx0ICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBlbmNvZGluZyA9IG9mZnNldDtcblx0ICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgb2Zmc2V0ID0gMDtcblx0ICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuXHQgIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuXHQgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcblx0ICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwO1xuXHQgICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCc7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBlbmNvZGluZyA9IGxlbmd0aDtcblx0ICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoXG5cdCAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcblx0ICAgIClcblx0ICB9XG5cblx0ICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG5cdCAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG5cdCAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG5cdCAgfVxuXG5cdCAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cblx0ICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblx0ICBmb3IgKDs7KSB7XG5cdCAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG5cdCAgICAgIGNhc2UgJ2hleCc6XG5cdCAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cblx0ICAgICAgY2FzZSAndXRmOCc6XG5cdCAgICAgIGNhc2UgJ3V0Zi04Jzpcblx0ICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cblx0ICAgICAgY2FzZSAnYXNjaWknOlxuXHQgICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cblx0ICAgICAgY2FzZSAnbGF0aW4xJzpcblx0ICAgICAgY2FzZSAnYmluYXJ5Jzpcblx0ICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuXHQgICAgICBjYXNlICdiYXNlNjQnOlxuXHQgICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG5cdCAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cblx0ICAgICAgY2FzZSAndWNzMic6XG5cdCAgICAgIGNhc2UgJ3Vjcy0yJzpcblx0ICAgICAgY2FzZSAndXRmMTZsZSc6XG5cdCAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcblx0ICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcblx0ICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0QnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuXHQgIHJldHVybiB7XG5cdCAgICB0eXBlOiAnQnVmZmVyJyxcblx0ICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuXHQgIH1cblx0fTtcblxuXHRmdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG5cdCAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zilcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuXHQgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cdCAgdmFyIHJlcyA9IFtdO1xuXG5cdCAgdmFyIGkgPSBzdGFydDtcblx0ICB3aGlsZSAoaSA8IGVuZCkge1xuXHQgICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXTtcblx0ICAgIHZhciBjb2RlUG9pbnQgPSBudWxsO1xuXHQgICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG5cdCAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuXHQgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuXHQgICAgICAgICAgOiAxO1xuXG5cdCAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG5cdCAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQ7XG5cblx0ICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG5cdCAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcblx0ICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgYnJlYWtcblx0ICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcblx0ICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG5cdCAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKTtcblx0ICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG5cdCAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgYnJlYWtcblx0ICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcblx0ICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG5cdCAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcblx0ICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpO1xuXHQgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG5cdCAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgYnJlYWtcblx0ICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcblx0ICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG5cdCAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTtcblx0ICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG5cdCAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKTtcblx0ICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG5cdCAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcblx0ICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuXHQgICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG5cdCAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDtcblx0ICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7XG5cdCAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuXHQgICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuXHQgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcblx0ICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0ICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkY7XG5cdCAgICB9XG5cblx0ICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG5cdCAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG5cdH1cblxuXHQvLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcblx0Ly8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuXHQvLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5cdHZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMDtcblxuXHRmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcblx0ICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdCAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuXHQgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG5cdCAgfVxuXG5cdCAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuXHQgIHZhciByZXMgPSAnJztcblx0ICB2YXIgaSA9IDA7XG5cdCAgd2hpbGUgKGkgPCBsZW4pIHtcblx0ICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuXHQgICAgICBTdHJpbmcsXG5cdCAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcblx0ICAgICk7XG5cdCAgfVxuXHQgIHJldHVybiByZXNcblx0fVxuXG5cdGZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuXHQgIHZhciByZXQgPSAnJztcblx0ICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG5cdCAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcblx0ICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpO1xuXHQgIH1cblx0ICByZXR1cm4gcmV0XG5cdH1cblxuXHRmdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG5cdCAgdmFyIHJldCA9ICcnO1xuXHQgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cblx0ICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuXHQgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJldFxuXHR9XG5cblx0ZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuXHQgIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG5cdCAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDtcblx0ICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG5cdCAgdmFyIG91dCA9ICcnO1xuXHQgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG5cdCAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dO1xuXHQgIH1cblx0ICByZXR1cm4gb3V0XG5cdH1cblxuXHRmdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuXHQgIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKTtcblx0ICB2YXIgcmVzID0gJyc7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXNcblx0fVxuXG5cdEJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuXHQgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblx0ICBzdGFydCA9IH5+c3RhcnQ7XG5cdCAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZDtcblxuXHQgIGlmIChzdGFydCA8IDApIHtcblx0ICAgIHN0YXJ0ICs9IGxlbjtcblx0ICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMDtcblx0ICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG5cdCAgICBzdGFydCA9IGxlbjtcblx0ICB9XG5cblx0ICBpZiAoZW5kIDwgMCkge1xuXHQgICAgZW5kICs9IGxlbjtcblx0ICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwO1xuXHQgIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG5cdCAgICBlbmQgPSBsZW47XG5cdCAgfVxuXG5cdCAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcblxuXHQgIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuXHQgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG5cdCAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSk7XG5cblx0ICByZXR1cm4gbmV3QnVmXG5cdH07XG5cblx0Lypcblx0ICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuXHQgIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG5cdCAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuXHR9XG5cblx0QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuXHQgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcblx0ICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuXHQgIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG5cdCAgdmFyIG11bCA9IDE7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG5cdCAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcblx0ICB9XG5cblx0ICByZXR1cm4gdmFsXG5cdH07XG5cblx0QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuXHQgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcblx0ICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSB7XG5cdCAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblx0ICB9XG5cblx0ICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdO1xuXHQgIHZhciBtdWwgPSAxO1xuXHQgIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuXHQgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bDtcblx0ICB9XG5cblx0ICByZXR1cm4gdmFsXG5cdH07XG5cblx0QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG5cdCAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuXHQgIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuXHQgIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG5cdCAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG5cdCAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcblx0ICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG5cdCAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG5cdCAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcblx0ICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuXHQgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuXHQgICAgdGhpc1tvZmZzZXQgKyAzXSlcblx0fTtcblxuXHRCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuXHQgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcblx0ICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuXHQgIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG5cdCAgdmFyIG11bCA9IDE7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG5cdCAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcblx0ICB9XG5cdCAgbXVsICo9IDB4ODA7XG5cblx0ICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuXHQgIHJldHVybiB2YWxcblx0fTtcblxuXHRCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuXHQgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcblx0ICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuXHQgIHZhciBpID0gYnl0ZUxlbmd0aDtcblx0ICB2YXIgbXVsID0gMTtcblx0ICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldO1xuXHQgIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuXHQgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bDtcblx0ICB9XG5cdCAgbXVsICo9IDB4ODA7XG5cblx0ICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuXHQgIHJldHVybiB2YWxcblx0fTtcblxuXHRCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG5cdCAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuXHQgIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcblx0ICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCk7XG5cdCAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcblx0ICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOCk7XG5cdCAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuXHQgIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG5cdCAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG5cdCAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuXHQgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG5cdH07XG5cblx0QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG5cdCAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcblx0ICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG5cdCAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG5cdCAgICAodGhpc1tvZmZzZXQgKyAzXSlcblx0fTtcblxuXHRCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cdCAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblx0ICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuXHQgIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcblx0fTtcblxuXHRCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcblx0ICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcblx0ICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuXHQgIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcblx0ICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG5cdH1cblxuXHRCdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG5cdCAgdmFsdWUgPSArdmFsdWU7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIHtcblx0ICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG5cdCAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCk7XG5cdCAgfVxuXG5cdCAgdmFyIG11bCA9IDE7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcblx0ICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuXHQgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGO1xuXHQgIH1cblxuXHQgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG5cdH07XG5cblx0QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuXHQgIHZhbHVlID0gK3ZhbHVlO1xuXHQgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcblx0ICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSB7XG5cdCAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuXHQgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuXHQgIH1cblxuXHQgIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG5cdCAgdmFyIG11bCA9IDE7XG5cdCAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcblx0ICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcblx0ICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcblx0ICB9XG5cblx0ICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgdmFsdWUgPSArdmFsdWU7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApO1xuXHQgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuXHQgIHJldHVybiBvZmZzZXQgKyAxXG5cdH07XG5cblx0QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcblx0ICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcblx0ICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcblx0ICByZXR1cm4gb2Zmc2V0ICsgMlxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgdmFsdWUgPSArdmFsdWU7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG5cdCAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcblx0ICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG5cdCAgcmV0dXJuIG9mZnNldCArIDJcblx0fTtcblxuXHRCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIHZhbHVlID0gK3ZhbHVlO1xuXHQgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcblx0ICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7XG5cdCAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuXHQgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuXHQgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuXHQgIHJldHVybiBvZmZzZXQgKyA0XG5cdH07XG5cblx0QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG5cdCAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCk7XG5cdCAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuXHQgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpO1xuXHQgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKTtcblx0ICByZXR1cm4gb2Zmc2V0ICsgNFxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG5cdCAgdmFsdWUgPSArdmFsdWU7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIHtcblx0ICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKTtcblxuXHQgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuXHQgIH1cblxuXHQgIHZhciBpID0gMDtcblx0ICB2YXIgbXVsID0gMTtcblx0ICB2YXIgc3ViID0gMDtcblx0ICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG5cdCAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcblx0ICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG5cdCAgICAgIHN1YiA9IDE7XG5cdCAgICB9XG5cdCAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuXHQgIH1cblxuXHQgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG5cdH07XG5cblx0QnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkge1xuXHQgICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpO1xuXG5cdCAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG5cdCAgfVxuXG5cdCAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcblx0ICB2YXIgbXVsID0gMTtcblx0ICB2YXIgc3ViID0gMDtcblx0ICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGO1xuXHQgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuXHQgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcblx0ICAgICAgc3ViID0gMTtcblx0ICAgIH1cblx0ICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcblx0fTtcblxuXHRCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApO1xuXHQgIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMTtcblx0ICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcblx0ICByZXR1cm4gb2Zmc2V0ICsgMVxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIHZhbHVlID0gK3ZhbHVlO1xuXHQgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcblx0ICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuXHQgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuXHQgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuXHQgIHJldHVybiBvZmZzZXQgKyAyXG5cdH07XG5cblx0QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgdmFsdWUgPSArdmFsdWU7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG5cdCAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KTtcblx0ICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZik7XG5cdCAgcmV0dXJuIG9mZnNldCArIDJcblx0fTtcblxuXHRCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuXHQgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuXHQgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuXHQgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTtcblx0ICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7XG5cdCAgcmV0dXJuIG9mZnNldCArIDRcblx0fTtcblxuXHRCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcblx0ICB2YWx1ZSA9ICt2YWx1ZTtcblx0ICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG5cdCAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuXHQgIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcblx0ICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcblx0ICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNik7XG5cdCAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCk7XG5cdCAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuXHQgIHJldHVybiBvZmZzZXQgKyA0XG5cdH07XG5cblx0ZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcblx0ICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG5cdCAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuXHR9XG5cblx0ZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG5cdCAgdmFsdWUgPSArdmFsdWU7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIHtcblx0ICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQpO1xuXHQgIH1cblx0ICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG5cdCAgcmV0dXJuIG9mZnNldCArIDRcblx0fVxuXG5cdEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuXHQgIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcblx0fTtcblxuXHRmdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG5cdCAgdmFsdWUgPSArdmFsdWU7XG5cdCAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuXHQgIGlmICghbm9Bc3NlcnQpIHtcblx0ICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgpO1xuXHQgIH1cblx0ICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCk7XG5cdCAgcmV0dXJuIG9mZnNldCArIDhcblx0fVxuXG5cdEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxuXHR9O1xuXG5cdEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG5cdCAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcblx0fTtcblxuXHQvLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5cdEJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcblx0ICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuXHQgIGlmICghc3RhcnQpIHN0YXJ0ID0gMDtcblx0ICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoO1xuXHQgIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG5cdCAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwO1xuXHQgIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcblxuXHQgIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuXHQgIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuXHQgIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG5cdCAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuXHQgIGlmICh0YXJnZXRTdGFydCA8IDApIHtcblx0ICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcblx0ICB9XG5cdCAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG5cdCAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cblx0ICAvLyBBcmUgd2Ugb29iP1xuXHQgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGg7XG5cdCAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG5cdCAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDtcblx0ICB9XG5cblx0ICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG5cblx0ICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG5cdCAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpO1xuXHQgIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcblx0ICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuXHQgICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cdCAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcblx0ICAgICAgdGFyZ2V0LFxuXHQgICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuXHQgICAgICB0YXJnZXRTdGFydFxuXHQgICAgKTtcblx0ICB9XG5cblx0ICByZXR1cm4gbGVuXG5cdH07XG5cblx0Ly8gVXNhZ2U6XG5cdC8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuXHQvLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcblx0Ly8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5cdEJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcblx0ICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuXHQgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuXHQgICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgZW5jb2RpbmcgPSBzdGFydDtcblx0ICAgICAgc3RhcnQgPSAwO1xuXHQgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgZW5jb2RpbmcgPSBlbmQ7XG5cdCAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgfVxuXHQgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuXHQgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuXHQgICAgfVxuXHQgICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKTtcblx0ICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG5cdCAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcblx0ICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuXHQgICAgICAgIHZhbCA9IGNvZGU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG5cdCAgICB2YWwgPSB2YWwgJiAyNTU7XG5cdCAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcblx0ICAgIHZhbCA9IE51bWJlcih2YWwpO1xuXHQgIH1cblxuXHQgIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuXHQgIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuXHQgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG5cdCAgfVxuXG5cdCAgaWYgKGVuZCA8PSBzdGFydCkge1xuXHQgICAgcmV0dXJuIHRoaXNcblx0ICB9XG5cblx0ICBzdGFydCA9IHN0YXJ0ID4+PiAwO1xuXHQgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7XG5cblx0ICBpZiAoIXZhbCkgdmFsID0gMDtcblxuXHQgIHZhciBpO1xuXHQgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuXHQgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuXHQgICAgICB0aGlzW2ldID0gdmFsO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuXHQgICAgICA/IHZhbFxuXHQgICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpO1xuXHQgICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcblx0ICAgIGlmIChsZW4gPT09IDApIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG5cdCAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG5cdCAgICB9XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuXHQgICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gdGhpc1xuXHR9O1xuXG5cdC8vIEhFTFBFUiBGVU5DVElPTlNcblx0Ly8gPT09PT09PT09PT09PT09PVxuXG5cdHZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2c7XG5cblx0ZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuXHQgIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2Rpbmdcblx0ICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXTtcblx0ICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3Rcblx0ICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKTtcblx0ICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG5cdCAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcblx0ICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3Rcblx0ICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcblx0ICAgIHN0ciA9IHN0ciArICc9Jztcblx0ICB9XG5cdCAgcmV0dXJuIHN0clxuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcblx0ICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5O1xuXHQgIHZhciBjb2RlUG9pbnQ7XG5cdCAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdCAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXHQgIHZhciBieXRlcyA9IFtdO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHQgICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cblx0ICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcblx0ICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG5cdCAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG5cdCAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuXHQgICAgICAgIC8vIG5vIGxlYWQgeWV0XG5cdCAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuXHQgICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuXHQgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuXHQgICAgICAgICAgY29udGludWVcblx0ICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcblx0ICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcblx0ICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcblx0ICAgICAgICAgIGNvbnRpbnVlXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gdmFsaWQgbGVhZFxuXHQgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG5cblx0ICAgICAgICBjb250aW51ZVxuXHQgICAgICB9XG5cblx0ICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuXHQgICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG5cdCAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuXHQgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG5cdCAgICAgICAgY29udGludWVcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG5cdCAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDA7XG5cdCAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcblx0ICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuXHQgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG5cdCAgICB9XG5cblx0ICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG5cdCAgICAvLyBlbmNvZGUgdXRmOFxuXHQgICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcblx0ICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG5cdCAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTtcblx0ICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcblx0ICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cdCAgICAgIGJ5dGVzLnB1c2goXG5cdCAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG5cdCAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcblx0ICAgICAgKTtcblx0ICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuXHQgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcblx0ICAgICAgYnl0ZXMucHVzaChcblx0ICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcblx0ICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG5cdCAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcblx0ICAgICAgKTtcblx0ICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcblx0ICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG5cdCAgICAgIGJ5dGVzLnB1c2goXG5cdCAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuXHQgICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcblx0ICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG5cdCAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcblx0ICAgICAgKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50Jylcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gYnl0ZXNcblx0fVxuXG5cdGZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG5cdCAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG5cdCAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cblx0ICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG5cdCAgfVxuXHQgIHJldHVybiBieXRlQXJyYXlcblx0fVxuXG5cdGZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG5cdCAgdmFyIGMsIGhpLCBsbztcblx0ICB2YXIgYnl0ZUFycmF5ID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcblx0ICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG5cdCAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cdCAgICBoaSA9IGMgPj4gODtcblx0ICAgIGxvID0gYyAlIDI1Njtcblx0ICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcblx0ICAgIGJ5dGVBcnJheS5wdXNoKGhpKTtcblx0ICB9XG5cblx0ICByZXR1cm4gYnl0ZUFycmF5XG5cdH1cblxuXHRmdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcblx0ICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG5cdH1cblxuXHRmdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdCAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG5cdCAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG5cdCAgfVxuXHQgIHJldHVybiBpXG5cdH1cblxuXHQvLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuXHQvLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cblx0Ly8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5cdGZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuXHQgIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG5cdCAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuXHQgICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxuXHR9XG5cdGZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcblx0ICAvLyBGb3IgSUUxMSBzdXBwb3J0XG5cdCAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cdH1cblxuXHQvLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuXHQvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcblx0dmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuXHQgIHZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblx0ICB2YXIgdGFibGUgPSBuZXcgQXJyYXkoMjU2KTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcblx0ICAgIHZhciBpMTYgPSBpICogMTY7XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcblx0ICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gdGFibGVcblx0fSkoKTtcblxuXHR9LHtcImJhc2U2NC1qc1wiOjI5LFwiaWVlZTc1NFwiOjMyfV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICogQ3JlYXRlZCAyMDA4LTA4LTE5LlxuXHQgKlxuXHQgKiBEaWprc3RyYSBwYXRoLWZpbmRpbmcgZnVuY3Rpb25zLiBBZGFwdGVkIGZyb20gdGhlIERpamtzdGFyIFB5dGhvbiBwcm9qZWN0LlxuXHQgKlxuXHQgKiBDb3B5cmlnaHQgKEMpIDIwMDhcblx0ICogICBXeWF0dCBCYWxkd2luIDxzZWxmQHd5YXR0YmFsZHdpbi5jb20+XG5cdCAqICAgQWxsIHJpZ2h0cyByZXNlcnZlZFxuXHQgKlxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cdCAqXG5cdCAqICAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0ICpcblx0ICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuXHQgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcblx0ICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5cdCAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcblx0ICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcblx0ICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuXHQgKiBUSEUgU09GVFdBUkUuXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0dmFyIGRpamtzdHJhID0ge1xuXHQgIHNpbmdsZV9zb3VyY2Vfc2hvcnRlc3RfcGF0aHM6IGZ1bmN0aW9uKGdyYXBoLCBzLCBkKSB7XG5cdCAgICAvLyBQcmVkZWNlc3NvciBtYXAgZm9yIGVhY2ggbm9kZSB0aGF0IGhhcyBiZWVuIGVuY291bnRlcmVkLlxuXHQgICAgLy8gbm9kZSBJRCA9PiBwcmVkZWNlc3NvciBub2RlIElEXG5cdCAgICB2YXIgcHJlZGVjZXNzb3JzID0ge307XG5cblx0ICAgIC8vIENvc3RzIG9mIHNob3J0ZXN0IHBhdGhzIGZyb20gcyB0byBhbGwgbm9kZXMgZW5jb3VudGVyZWQuXG5cdCAgICAvLyBub2RlIElEID0+IGNvc3Rcblx0ICAgIHZhciBjb3N0cyA9IHt9O1xuXHQgICAgY29zdHNbc10gPSAwO1xuXG5cdCAgICAvLyBDb3N0cyBvZiBzaG9ydGVzdCBwYXRocyBmcm9tIHMgdG8gYWxsIG5vZGVzIGVuY291bnRlcmVkOyBkaWZmZXJzIGZyb21cblx0ICAgIC8vIGBjb3N0c2AgaW4gdGhhdCBpdCBwcm92aWRlcyBlYXN5IGFjY2VzcyB0byB0aGUgbm9kZSB0aGF0IGN1cnJlbnRseSBoYXNcblx0ICAgIC8vIHRoZSBrbm93biBzaG9ydGVzdCBwYXRoIGZyb20gcy5cblx0ICAgIC8vIFhYWDogRG8gd2UgYWN0dWFsbHkgbmVlZCBib3RoIGBjb3N0c2AgYW5kIGBvcGVuYD9cblx0ICAgIHZhciBvcGVuID0gZGlqa3N0cmEuUHJpb3JpdHlRdWV1ZS5tYWtlKCk7XG5cdCAgICBvcGVuLnB1c2gocywgMCk7XG5cblx0ICAgIHZhciBjbG9zZXN0LFxuXHQgICAgICAgIHUsIHYsXG5cdCAgICAgICAgY29zdF9vZl9zX3RvX3UsXG5cdCAgICAgICAgYWRqYWNlbnRfbm9kZXMsXG5cdCAgICAgICAgY29zdF9vZl9lLFxuXHQgICAgICAgIGNvc3Rfb2Zfc190b191X3BsdXNfY29zdF9vZl9lLFxuXHQgICAgICAgIGNvc3Rfb2Zfc190b192LFxuXHQgICAgICAgIGZpcnN0X3Zpc2l0O1xuXHQgICAgd2hpbGUgKCFvcGVuLmVtcHR5KCkpIHtcblx0ICAgICAgLy8gSW4gdGhlIG5vZGVzIHJlbWFpbmluZyBpbiBncmFwaCB0aGF0IGhhdmUgYSBrbm93biBjb3N0IGZyb20gcyxcblx0ICAgICAgLy8gZmluZCB0aGUgbm9kZSwgdSwgdGhhdCBjdXJyZW50bHkgaGFzIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gcy5cblx0ICAgICAgY2xvc2VzdCA9IG9wZW4ucG9wKCk7XG5cdCAgICAgIHUgPSBjbG9zZXN0LnZhbHVlO1xuXHQgICAgICBjb3N0X29mX3NfdG9fdSA9IGNsb3Nlc3QuY29zdDtcblxuXHQgICAgICAvLyBHZXQgbm9kZXMgYWRqYWNlbnQgdG8gdS4uLlxuXHQgICAgICBhZGphY2VudF9ub2RlcyA9IGdyYXBoW3VdIHx8IHt9O1xuXG5cdCAgICAgIC8vIC4uLmFuZCBleHBsb3JlIHRoZSBlZGdlcyB0aGF0IGNvbm5lY3QgdSB0byB0aG9zZSBub2RlcywgdXBkYXRpbmdcblx0ICAgICAgLy8gdGhlIGNvc3Qgb2YgdGhlIHNob3J0ZXN0IHBhdGhzIHRvIGFueSBvciBhbGwgb2YgdGhvc2Ugbm9kZXMgYXNcblx0ICAgICAgLy8gbmVjZXNzYXJ5LiB2IGlzIHRoZSBub2RlIGFjcm9zcyB0aGUgY3VycmVudCBlZGdlIGZyb20gdS5cblx0ICAgICAgZm9yICh2IGluIGFkamFjZW50X25vZGVzKSB7XG5cdCAgICAgICAgaWYgKGFkamFjZW50X25vZGVzLmhhc093blByb3BlcnR5KHYpKSB7XG5cdCAgICAgICAgICAvLyBHZXQgdGhlIGNvc3Qgb2YgdGhlIGVkZ2UgcnVubmluZyBmcm9tIHUgdG8gdi5cblx0ICAgICAgICAgIGNvc3Rfb2ZfZSA9IGFkamFjZW50X25vZGVzW3ZdO1xuXG5cdCAgICAgICAgICAvLyBDb3N0IG9mIHMgdG8gdSBwbHVzIHRoZSBjb3N0IG9mIHUgdG8gdiBhY3Jvc3MgZS0tdGhpcyBpcyAqYSpcblx0ICAgICAgICAgIC8vIGNvc3QgZnJvbSBzIHRvIHYgdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBsZXNzIHRoYW4gdGhlIGN1cnJlbnRcblx0ICAgICAgICAgIC8vIGtub3duIGNvc3QgdG8gdi5cblx0ICAgICAgICAgIGNvc3Rfb2Zfc190b191X3BsdXNfY29zdF9vZl9lID0gY29zdF9vZl9zX3RvX3UgKyBjb3N0X29mX2U7XG5cblx0ICAgICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgdmlzaXRlZCB2IHlldCBPUiBpZiB0aGUgY3VycmVudCBrbm93biBjb3N0IGZyb20gcyB0b1xuXHQgICAgICAgICAgLy8gdiBpcyBncmVhdGVyIHRoYW4gdGhlIG5ldyBjb3N0IHdlIGp1c3QgZm91bmQgKGNvc3Qgb2YgcyB0byB1IHBsdXNcblx0ICAgICAgICAgIC8vIGNvc3Qgb2YgdSB0byB2IGFjcm9zcyBlKSwgdXBkYXRlIHYncyBjb3N0IGluIHRoZSBjb3N0IGxpc3QgYW5kXG5cdCAgICAgICAgICAvLyB1cGRhdGUgdidzIHByZWRlY2Vzc29yIGluIHRoZSBwcmVkZWNlc3NvciBsaXN0IChpdCdzIG5vdyB1KS5cblx0ICAgICAgICAgIGNvc3Rfb2Zfc190b192ID0gY29zdHNbdl07XG5cdCAgICAgICAgICBmaXJzdF92aXNpdCA9ICh0eXBlb2YgY29zdHNbdl0gPT09ICd1bmRlZmluZWQnKTtcblx0ICAgICAgICAgIGlmIChmaXJzdF92aXNpdCB8fCBjb3N0X29mX3NfdG9fdiA+IGNvc3Rfb2Zfc190b191X3BsdXNfY29zdF9vZl9lKSB7XG5cdCAgICAgICAgICAgIGNvc3RzW3ZdID0gY29zdF9vZl9zX3RvX3VfcGx1c19jb3N0X29mX2U7XG5cdCAgICAgICAgICAgIG9wZW4ucHVzaCh2LCBjb3N0X29mX3NfdG9fdV9wbHVzX2Nvc3Rfb2ZfZSk7XG5cdCAgICAgICAgICAgIHByZWRlY2Vzc29yc1t2XSA9IHU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgZCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvc3RzW2RdID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgICB2YXIgbXNnID0gWydDb3VsZCBub3QgZmluZCBhIHBhdGggZnJvbSAnLCBzLCAnIHRvICcsIGQsICcuJ10uam9pbignJyk7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcHJlZGVjZXNzb3JzO1xuXHQgIH0sXG5cblx0ICBleHRyYWN0X3Nob3J0ZXN0X3BhdGhfZnJvbV9wcmVkZWNlc3Nvcl9saXN0OiBmdW5jdGlvbihwcmVkZWNlc3NvcnMsIGQpIHtcblx0ICAgIHZhciBub2RlcyA9IFtdO1xuXHQgICAgdmFyIHUgPSBkO1xuXHQgICAgdmFyIHByZWRlY2Vzc29yO1xuXHQgICAgd2hpbGUgKHUpIHtcblx0ICAgICAgbm9kZXMucHVzaCh1KTtcblx0ICAgICAgcHJlZGVjZXNzb3IgPSBwcmVkZWNlc3NvcnNbdV07XG5cdCAgICAgIHUgPSBwcmVkZWNlc3NvcnNbdV07XG5cdCAgICB9XG5cdCAgICBub2Rlcy5yZXZlcnNlKCk7XG5cdCAgICByZXR1cm4gbm9kZXM7XG5cdCAgfSxcblxuXHQgIGZpbmRfcGF0aDogZnVuY3Rpb24oZ3JhcGgsIHMsIGQpIHtcblx0ICAgIHZhciBwcmVkZWNlc3NvcnMgPSBkaWprc3RyYS5zaW5nbGVfc291cmNlX3Nob3J0ZXN0X3BhdGhzKGdyYXBoLCBzLCBkKTtcblx0ICAgIHJldHVybiBkaWprc3RyYS5leHRyYWN0X3Nob3J0ZXN0X3BhdGhfZnJvbV9wcmVkZWNlc3Nvcl9saXN0KFxuXHQgICAgICBwcmVkZWNlc3NvcnMsIGQpO1xuXHQgIH0sXG5cblx0ICAvKipcblx0ICAgKiBBIHZlcnkgbmFpdmUgcHJpb3JpdHkgcXVldWUgaW1wbGVtZW50YXRpb24uXG5cdCAgICovXG5cdCAgUHJpb3JpdHlRdWV1ZToge1xuXHQgICAgbWFrZTogZnVuY3Rpb24gKG9wdHMpIHtcblx0ICAgICAgdmFyIFQgPSBkaWprc3RyYS5Qcmlvcml0eVF1ZXVlLFxuXHQgICAgICAgICAgdCA9IHt9LFxuXHQgICAgICAgICAga2V5O1xuXHQgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblx0ICAgICAgZm9yIChrZXkgaW4gVCkge1xuXHQgICAgICAgIGlmIChULmhhc093blByb3BlcnR5KGtleSkpIHtcblx0ICAgICAgICAgIHRba2V5XSA9IFRba2V5XTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgdC5xdWV1ZSA9IFtdO1xuXHQgICAgICB0LnNvcnRlciA9IG9wdHMuc29ydGVyIHx8IFQuZGVmYXVsdF9zb3J0ZXI7XG5cdCAgICAgIHJldHVybiB0O1xuXHQgICAgfSxcblxuXHQgICAgZGVmYXVsdF9zb3J0ZXI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgIHJldHVybiBhLmNvc3QgLSBiLmNvc3Q7XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIEFkZCBhIG5ldyBpdGVtIHRvIHRoZSBxdWV1ZSBhbmQgZW5zdXJlIHRoZSBoaWdoZXN0IHByaW9yaXR5IGVsZW1lbnRcblx0ICAgICAqIGlzIGF0IHRoZSBmcm9udCBvZiB0aGUgcXVldWUuXG5cdCAgICAgKi9cblx0ICAgIHB1c2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29zdCkge1xuXHQgICAgICB2YXIgaXRlbSA9IHt2YWx1ZTogdmFsdWUsIGNvc3Q6IGNvc3R9O1xuXHQgICAgICB0aGlzLnF1ZXVlLnB1c2goaXRlbSk7XG5cdCAgICAgIHRoaXMucXVldWUuc29ydCh0aGlzLnNvcnRlcik7XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybiB0aGUgaGlnaGVzdCBwcmlvcml0eSBlbGVtZW50IGluIHRoZSBxdWV1ZS5cblx0ICAgICAqL1xuXHQgICAgcG9wOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG5cdCAgICB9LFxuXG5cdCAgICBlbXB0eTogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5sZW5ndGggPT09IDA7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cblx0Ly8gbm9kZS5qcyBtb2R1bGUgZXhwb3J0c1xuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICBtb2R1bGUuZXhwb3J0cyA9IGRpamtzdHJhO1xuXHR9XG5cblx0fSx7fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXHRleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuXHQgIHZhciBlLCBtO1xuXHQgIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDE7XG5cdCAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG5cdCAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuXHQgIHZhciBuQml0cyA9IC03O1xuXHQgIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDA7XG5cdCAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuXHQgIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG5cdCAgaSArPSBkO1xuXG5cdCAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG5cdCAgcyA+Pj0gKC1uQml0cyk7XG5cdCAgbkJpdHMgKz0gZUxlbjtcblx0ICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cblx0ICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcblx0ICBlID4+PSAoLW5CaXRzKTtcblx0ICBuQml0cyArPSBtTGVuO1xuXHQgIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuXHQgIGlmIChlID09PSAwKSB7XG5cdCAgICBlID0gMSAtIGVCaWFzO1xuXHQgIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuXHQgICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG5cdCAgfSBlbHNlIHtcblx0ICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG5cdCAgICBlID0gZSAtIGVCaWFzO1xuXHQgIH1cblx0ICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxuXHR9O1xuXG5cdGV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcblx0ICB2YXIgZSwgbSwgYztcblx0ICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxO1xuXHQgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuXHQgIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcblx0ICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApO1xuXHQgIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSk7XG5cdCAgdmFyIGQgPSBpc0xFID8gMSA6IC0xO1xuXHQgIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG5cdCAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cblx0ICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuXHQgICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuXHQgICAgZSA9IGVNYXg7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcblx0ICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcblx0ICAgICAgZS0tO1xuXHQgICAgICBjICo9IDI7XG5cdCAgICB9XG5cdCAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcblx0ICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuXHQgICAgfVxuXHQgICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG5cdCAgICAgIGUrKztcblx0ICAgICAgYyAvPSAyO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcblx0ICAgICAgbSA9IDA7XG5cdCAgICAgIGUgPSBlTWF4O1xuXHQgICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuXHQgICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcblx0ICAgICAgZSA9IGUgKyBlQmlhcztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcblx0ICAgICAgZSA9IDA7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuXHQgIGUgPSAoZSA8PCBtTGVuKSB8IG07XG5cdCAgZUxlbiArPSBtTGVuO1xuXHQgIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuXHQgIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcblx0fTtcblxuXHR9LHt9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cdHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG5cdCAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xuXHR9O1xuXG5cdH0se31dfSx7fSxbMjRdKSgyNClcblx0fSk7XG5cblxuXHR9KTtcblxuXHR2YXIgaW5kZXggPSB7XG5cdCAgbmFtZTogJ3FyY29kZScsXG5cdCAgcHJvcHM6IHtcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIHZhbHVlIG9mIHRoZSBRUiBjb2RlLlxuXHQgICAgICovXG5cdCAgICB2YWx1ZTogbnVsbCxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgb3B0aW9ucyBmb3IgdGhlIFFSIGNvZGUgZ2VuZXJhdG9yLlxuXHQgICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xkYWlyL25vZGUtcXJjb2RlI3FyLWNvZGUtb3B0aW9uc31cblx0ICAgICAqL1xuXHQgICAgb3B0aW9uczogT2JqZWN0LFxuXG5cdCAgICAvKipcblx0ICAgICAqIFRoZSB0YWcgbmFtZSBvZiB0aGUgY29tcG9uZW50J3Mgcm9vdCBlbGVtZW50LlxuXHQgICAgICovXG5cdCAgICB0YWc6IHtcblx0ICAgICAgdHlwZTogU3RyaW5nLFxuXHQgICAgICBkZWZhdWx0OiAnY2FudmFzJ1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoY3JlYXRlRWxlbWVudCkge1xuXHQgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGhpcy50YWcsIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuXHQgIH0sXG5cdCAgd2F0Y2g6IHtcblx0ICAgICRwcm9wczoge1xuXHQgICAgICBkZWVwOiB0cnVlLFxuXHQgICAgICBpbW1lZGlhdGU6IHRydWUsXG5cblx0ICAgICAgLyoqXG5cdCAgICAgICAqIFVwZGF0ZSB0aGUgUVIgY29kZSB3aGVuIHByb3BzIGNoYW5nZWQuXG5cdCAgICAgICAqL1xuXHQgICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge1xuXHQgICAgICAgIGlmICh0aGlzLiRlbCkge1xuXHQgICAgICAgICAgdGhpcy5nZW5lcmF0ZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgbWV0aG9kczoge1xuXHQgICAgLyoqXG5cdCAgICAgKiBHZW5lcmF0ZSBRUiBjb2RlLlxuXHQgICAgICovXG5cdCAgICBnZW5lcmF0ZTogZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG5cdCAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cblx0ICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdCAgICAgICAgICB0YWcgPSB0aGlzLnRhZztcblx0ICAgICAgdmFyIHZhbHVlID0gU3RyaW5nKHRoaXMudmFsdWUpO1xuXG5cdCAgICAgIGlmICh0YWcgPT09ICdjYW52YXMnKSB7XG5cdCAgICAgICAgcXJjb2RlLnRvQ2FudmFzKHRoaXMuJGVsLCB2YWx1ZSwgb3B0aW9ucywgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICAgIGlmIChlcnJvcikge1xuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgfSBlbHNlIGlmICh0YWcgPT09ICdpbWcnKSB7XG5cdCAgICAgICAgcXJjb2RlLnRvRGF0YVVSTCh2YWx1ZSwgb3B0aW9ucywgZnVuY3Rpb24gKGVycm9yLCB1cmwpIHtcblx0ICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgICAgICAgICAgaWYgKGVycm9yKSB7XG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBfdGhpcy4kZWwuc3JjID0gdXJsO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHFyY29kZS50b1N0cmluZyh2YWx1ZSwgb3B0aW9ucywgZnVuY3Rpb24gKGVycm9yLCBzdHJpbmcpIHtcblx0ICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgICAgICAgICAgaWYgKGVycm9yKSB7XG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBfdGhpcy4kZWwuaW5uZXJIVE1MID0gc3RyaW5nO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuXHQgICAgdGhpcy5nZW5lcmF0ZSgpO1xuXHQgIH1cblx0fTtcblxuXHRyZXR1cm4gaW5kZXg7XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@chenfengyuan/vue-qrcode/dist/vue-qrcode.js\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-37[0].rules[0].use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=script&lang=js&":
/*!***********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-37[0].rules[0].use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=script&lang=js& ***!
  \***********************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _chenfengyuan_vue_qrcode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chenfengyuan/vue-qrcode */ \"./node_modules/@chenfengyuan/vue-qrcode/dist/vue-qrcode.js\");\n/* harmony import */ var _chenfengyuan_vue_qrcode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_chenfengyuan_vue_qrcode__WEBPACK_IMPORTED_MODULE_0__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  props: {\n    url: String\n  },\n  components: {\n    qrcode: (_chenfengyuan_vue_qrcode__WEBPACK_IMPORTED_MODULE_0___default())\n  },\n  data() {\n    return {\n      local_url: this.url,\n      qr_options: {\n        width: 1200,\n        margin: 4\n      },\n      canvas_dataurl: undefined,\n      show_fullscreen: false,\n      is_copied: false\n    };\n  },\n  created() {},\n  mounted() {\n    this.$nextTick(() => {\n      this.createDownloadFromCanvas();\n    });\n  },\n  beforeDestroy() {},\n  watch: {\n    local_url() {\n      this.$nextTick(() => {\n        this.createDownloadFromCanvas();\n      });\n    }\n  },\n  computed: {},\n  methods: {\n    createDownloadFromCanvas() {\n      if (this.$refs.qrCode) this.canvas_dataurl = this.$refs.qrCode.$el.toDataURL();\n    },\n    copyToClipboard() {\n      this.is_copied = false;\n\n      // Get the text field\n      var copyText = this.$refs.urlToCopy;\n\n      // Select the text field\n      copyText.select();\n      copyText.setSelectionRange(0, 99999); // For mobile devices\n\n      // Copy the text inside the text field\n      navigator.clipboard.writeText(copyText.value);\n      this.is_copied = true;\n    },\n    downloadCanvas() {\n      var link = document.createElement(\"a\");\n      link.download = \"qr_code.png\";\n      const canvas_dataurl = this.$refs.qrCode.$el.toDataURL();\n      link.href = canvas_dataurl;\n      link.click();\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0zN1swXS5ydWxlc1swXS51c2VbMF0hLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9hZGMtY29yZS91aS9RUkNvZGVXaXRoTGluay52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAvc3JjL2FkYy1jb3JlL3VpL1FSQ29kZVdpdGhMaW5rLnZ1ZT9jNDQ2Il0sInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIl9RUkNvZGVXaXRoTGlua1wiPlxuICAgIDxkaXYgY2xhc3M9XCJfbGlua1wiPlxuICAgICAgPGRpdiBjbGFzcz1cInUtaW5wdXRHcm91cFwiPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgdi1tb2RlbD1cImxvY2FsX3VybFwiXG4gICAgICAgICAgcmVmPVwidXJsVG9Db3B5XCJcbiAgICAgICAgICBjbGFzcz1cIl91cmxJbnB1dFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzcz1cInUtYnV0dG9uIHUtYnV0dG9uX2ljb24gdS1zdWZmaXggX2NsaXBib2FyZEJ0blwiXG4gICAgICAgICAgQGNsaWNrPVwiY29weVRvQ2xpcGJvYXJkXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxiLWljb24gaWNvbj1cImNsaXBib2FyZFwiIHYtaWY9XCIhaXNfY29waWVkXCIgLz5cbiAgICAgICAgICA8Yi1pY29uIGljb249XCJjbGlwYm9hcmQtY2hlY2tcIiB2LWVsc2UgLz5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxhIDpocmVmPVwibG9jYWxfdXJsXCIgdGFyZ2V0PVwiX2JsYW5rXCIgY2xhc3M9XCJ1LWJ1dHRvbkxpbmtcIj5cbiAgICAgICAge3sgJHQoXCJvcGVuXCIpIH19IDxiLWljb24gc2xvdD1cInByZWZpeFwiIGljb249XCJib3gtYXJyb3ctdXAtcmlnaHRcIiAvPlxuICAgICAgPC9hPlxuICAgIDwvZGl2PlxuXG4gICAgPHRyYW5zaXRpb24gbmFtZT1cInBhZ2VjaGFuZ2VcIiBtb2RlPVwib3V0LWluXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiX3FyXCIgOmtleT1cImxvY2FsX3VybFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiX2ZzQnV0dG9uXCI+XG4gICAgICAgICAgPEVkaXRCdG4gOmJ0bl90eXBlPVwiJ2Z1bGxzY3JlZW4nXCIgQGNsaWNrPVwic2hvd19mdWxsc2NyZWVuID0gdHJ1ZVwiIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8cXJjb2RlXG4gICAgICAgICAgcmVmPVwicXJDb2RlXCJcbiAgICAgICAgICA6dmFsdWU9XCJsb2NhbF91cmxcIlxuICAgICAgICAgIHRhZz1cImNhbnZhc1wiXG4gICAgICAgICAgOm9wdGlvbnM9XCJxcl9vcHRpb25zXCJcbiAgICAgICAgLz5cbiAgICAgICAgPEZ1bGxzY3JlZW5WaWV3IHYtaWY9XCJzaG93X2Z1bGxzY3JlZW5cIiBAY2xvc2U9XCJzaG93X2Z1bGxzY3JlZW4gPSBmYWxzZVwiPlxuICAgICAgICAgIDxxcmNvZGVcbiAgICAgICAgICAgIHJlZj1cInFyQ29kZVwiXG4gICAgICAgICAgICA6dmFsdWU9XCJsb2NhbF91cmxcIlxuICAgICAgICAgICAgdGFnPVwiY2FudmFzXCJcbiAgICAgICAgICAgIDpvcHRpb25zPVwicXJfb3B0aW9uc1wiXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9GdWxsc2NyZWVuVmlldz5cbiAgICAgIDwvZGl2PlxuICAgIDwvdHJhbnNpdGlvbj5cbiAgICA8c21hbGw+XG4gICAgICA8YSBjbGFzcz1cInUtYnV0dG9uTGlua1wiIEBjbGljaz1cImRvd25sb2FkQ2FudmFzXCI+XG4gICAgICAgIHt7ICR0KFwiZG93bmxvYWRfdGhpc19xcl9jb2RlXCIpIH19XG4gICAgICA8L2E+XG4gICAgPC9zbWFsbD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmltcG9ydCBxcmNvZGUgZnJvbSBcIkBjaGVuZmVuZ3l1YW4vdnVlLXFyY29kZVwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHByb3BzOiB7XG4gICAgdXJsOiBTdHJpbmcsXG4gIH0sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBxcmNvZGUsXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2FsX3VybDogdGhpcy51cmwsXG4gICAgICBxcl9vcHRpb25zOiB7XG4gICAgICAgIHdpZHRoOiAxMjAwLFxuICAgICAgICBtYXJnaW46IDQsXG4gICAgICB9LFxuICAgICAgY2FudmFzX2RhdGF1cmw6IHVuZGVmaW5lZCxcbiAgICAgIHNob3dfZnVsbHNjcmVlbjogZmFsc2UsXG5cbiAgICAgIGlzX2NvcGllZDogZmFsc2UsXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlZCgpIHt9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgIHRoaXMuY3JlYXRlRG93bmxvYWRGcm9tQ2FudmFzKCk7XG4gICAgfSk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7fSxcbiAgd2F0Y2g6IHtcbiAgICBsb2NhbF91cmwoKSB7XG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuY3JlYXRlRG93bmxvYWRGcm9tQ2FudmFzKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuICBjb21wdXRlZDoge30sXG4gIG1ldGhvZHM6IHtcbiAgICBjcmVhdGVEb3dubG9hZEZyb21DYW52YXMoKSB7XG4gICAgICBpZiAodGhpcy4kcmVmcy5xckNvZGUpXG4gICAgICAgIHRoaXMuY2FudmFzX2RhdGF1cmwgPSB0aGlzLiRyZWZzLnFyQ29kZS4kZWwudG9EYXRhVVJMKCk7XG4gICAgfSxcbiAgICBjb3B5VG9DbGlwYm9hcmQoKSB7XG4gICAgICB0aGlzLmlzX2NvcGllZCA9IGZhbHNlO1xuXG4gICAgICAvLyBHZXQgdGhlIHRleHQgZmllbGRcbiAgICAgIHZhciBjb3B5VGV4dCA9IHRoaXMuJHJlZnMudXJsVG9Db3B5O1xuXG4gICAgICAvLyBTZWxlY3QgdGhlIHRleHQgZmllbGRcbiAgICAgIGNvcHlUZXh0LnNlbGVjdCgpO1xuICAgICAgY29weVRleHQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgOTk5OTkpOyAvLyBGb3IgbW9iaWxlIGRldmljZXNcblxuICAgICAgLy8gQ29weSB0aGUgdGV4dCBpbnNpZGUgdGhlIHRleHQgZmllbGRcbiAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KGNvcHlUZXh0LnZhbHVlKTtcblxuICAgICAgdGhpcy5pc19jb3BpZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgZG93bmxvYWRDYW52YXMoKSB7XG4gICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgbGluay5kb3dubG9hZCA9IFwicXJfY29kZS5wbmdcIjtcbiAgICAgIGNvbnN0IGNhbnZhc19kYXRhdXJsID0gdGhpcy4kcmVmcy5xckNvZGUuJGVsLnRvRGF0YVVSTCgpO1xuICAgICAgbGluay5ocmVmID0gY2FudmFzX2RhdGF1cmw7XG4gICAgICBsaW5rLmNsaWNrKCk7XG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiIHNjb3BlZD5cbi5fUVJDb2RlV2l0aExpbmsge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWZsb3c6IGNvbHVtbiBub3dyYXA7XG4gIGp1c3RpZnktY29udGVudDogc3RyZXRjaDtcbiAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XG5cbiAgZ2FwOiBjYWxjKHZhcigtLXNwYWNpbmcpIC8gMik7XG5cbiAgcGFkZGluZzogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDIpO1xuICBhc3BlY3QtcmF0aW86IDIxLzI5Ljc7XG5cbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gIGJveC1zaGFkb3c6IDAgMnB4IDZweCByZ2IoMCAwIDAgLyAzMCUpO1xufVxuXG4uX2xpbmsge1xuICBkaXNwbGF5OiBibG9jaztcbiAgd2lkdGg6IDEwMCU7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgd29yZC1icmVhazogYnJlYWstd29yZDtcblxuICAvLyBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgLy8gLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcbiAgLy8gLXdlYmtpdC1saW5lLWNsYW1wOiAxO1xuICAvLyBvdmVyZmxvdzogaGlkZGVuO1xufVxuLl9xciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAuX2ZzQnV0dG9uIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm90dG9tOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgbWFyZ2luOiBjYWxjKHZhcigtLXNwYWNpbmcpIC8gMik7XG4gIH1cblxuICBjYW52YXMge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIC8vIGJvcmRlcjogMnB4IHNvbGlkIHZhcigtLWMtZ3Jpcyk7XG4gICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbiAgICBoZWlnaHQ6IGF1dG8gIWltcG9ydGFudDtcbiAgICBhc3BlY3QtcmF0aW86IDE7XG4gIH1cblxuICA6OnYtZGVlcCAuX2ZzSW1nIGNhbnZhcyB7XG4gICAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XG4gICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbiAgICBoZWlnaHQ6IDEwMCUgIWltcG9ydGFudDtcbiAgICBhc3BlY3QtcmF0aW86IG5vbmU7XG4gIH1cbn1cblxuLl91cmxJbnB1dCB7XG4gIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuLl9jbGlwYm9hcmRCdG4ge1xuICBmb250LXNpemU6IDFyZW07XG4gIG1hcmdpbjogY2FsYyh2YXIoLS1zcGFjaW5nKSAvIDIpO1xufVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-37[0].rules[0].use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true&":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true& ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"._QRCodeWithLink[data-v-71cc997f] {\\n  display: flex;\\n  flex-flow: column nowrap;\\n  justify-content: stretch;\\n  align-items: stretch;\\n  gap: calc(var(--spacing) / 2);\\n  padding: calc(var(--spacing) * 2);\\n  aspect-ratio: 21/29.7;\\n  align-items: center;\\n  justify-content: space-around;\\n  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);\\n}\\n._link[data-v-71cc997f] {\\n  display: block;\\n  width: 100%;\\n  text-align: center;\\n  word-break: break-word;\\n}\\n._qr[data-v-71cc997f] {\\n  position: relative;\\n}\\n._qr ._fsButton[data-v-71cc997f] {\\n  position: absolute;\\n  bottom: 0;\\n  left: 0;\\n  margin: calc(var(--spacing) / 2);\\n}\\n._qr canvas[data-v-71cc997f] {\\n  display: block;\\n  width: 100% !important;\\n  height: auto !important;\\n  aspect-ratio: 1;\\n}\\n._qr[data-v-71cc997f]  ._fsImg canvas {\\n  border: none !important;\\n  width: 100% !important;\\n  height: 100% !important;\\n  aspect-ratio: none;\\n}\\n._urlInput[data-v-71cc997f] {\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n  overflow: hidden;\\n}\\n._clipboardBtn[data-v-71cc997f] {\\n  font-size: 1rem;\\n  margin: calc(var(--spacing) / 2);\\n}\", \"\"]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xOVswXS5ydWxlc1swXS51c2VbMV0hLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTlbMF0ucnVsZXNbMF0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTE5WzBdLnJ1bGVzWzBdLnVzZVszXSEuL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2FkYy1jb3JlL3VpL1FSQ29kZVdpdGhMaW5rLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTcxY2M5OTdmJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vc3JjL2FkYy1jb3JlL3VpL1FSQ29kZVdpdGhMaW5rLnZ1ZT8zZTM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9OT19TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvbm9Tb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfTk9fU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuX1FSQ29kZVdpdGhMaW5rW2RhdGEtdi03MWNjOTk3Zl0ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZmxvdzogY29sdW1uIG5vd3JhcDtcXG4gIGp1c3RpZnktY29udGVudDogc3RyZXRjaDtcXG4gIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xcbiAgZ2FwOiBjYWxjKHZhcigtLXNwYWNpbmcpIC8gMik7XFxuICBwYWRkaW5nOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMik7XFxuICBhc3BlY3QtcmF0aW86IDIxLzI5Ljc7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICBib3gtc2hhZG93OiAwIDJweCA2cHggcmdiYSgwLCAwLCAwLCAwLjMpO1xcbn1cXG4uX2xpbmtbZGF0YS12LTcxY2M5OTdmXSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAxMDAlO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgd29yZC1icmVhazogYnJlYWstd29yZDtcXG59XFxuLl9xcltkYXRhLXYtNzFjYzk5N2ZdIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLl9xciAuX2ZzQnV0dG9uW2RhdGEtdi03MWNjOTk3Zl0ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIG1hcmdpbjogY2FsYyh2YXIoLS1zcGFjaW5nKSAvIDIpO1xcbn1cXG4uX3FyIGNhbnZhc1tkYXRhLXYtNzFjYzk5N2ZdIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcXG4gIGhlaWdodDogYXV0byAhaW1wb3J0YW50O1xcbiAgYXNwZWN0LXJhdGlvOiAxO1xcbn1cXG4uX3FyW2RhdGEtdi03MWNjOTk3Zl0gIC5fZnNJbWcgY2FudmFzIHtcXG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xcbiAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcXG4gIGhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xcbiAgYXNwZWN0LXJhdGlvOiBub25lO1xcbn1cXG4uX3VybElucHV0W2RhdGEtdi03MWNjOTk3Zl0ge1xcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuLl9jbGlwYm9hcmRCdG5bZGF0YS12LTcxY2M5OTdmXSB7XFxuICBmb250LXNpemU6IDFyZW07XFxuICBtYXJnaW46IGNhbGModmFyKC0tc3BhY2luZykgLyAyKTtcXG59XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true&\n");

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js??clonedRuleSet-19[0].rules[0].use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true&":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader/index.js??clonedRuleSet-19[0].rules[0].use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true& ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!../../../node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true& */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true&\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(/*! !../../../node_modules/vue-style-loader/lib/addStylesClient.js */ \"./node_modules/vue-style-loader/lib/addStylesClient.js\")[\"default\"])\nvar update = add(\"d9ab714e\", content, false, {\"sourceMap\":false,\"shadowMode\":false});\n// Hot Module Replacement\nif(true) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(/*! !!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!../../../node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true& */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true&\", function() {\n     var newContent = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!../../../node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true& */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true&\");\n     if(newContent.__esModule) newContent = newContent.default;\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xOVswXS5ydWxlc1swXS51c2VbMF0hLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xOVswXS5ydWxlc1swXS51c2VbMV0hLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTlbMF0ucnVsZXNbMF0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTE5WzBdLnJ1bGVzWzBdLnVzZVszXSEuL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2FkYy1jb3JlL3VpL1FSQ29kZVdpdGhMaW5rLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTcxY2M5OTdmJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLy4vc3JjL2FkYy1jb3JlL3VpL1FSQ29kZVdpdGhMaW5rLnZ1ZT80ZjAwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xOVswXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xOVswXS5ydWxlc1swXS51c2VbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTE5WzBdLnJ1bGVzWzBdLnVzZVszXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1FSQ29kZVdpdGhMaW5rLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTcxY2M5OTdmJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIik7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiZDlhYjcxNGVcIiwgY29udGVudCwgZmFsc2UsIHtcInNvdXJjZU1hcFwiOmZhbHNlLFwic2hhZG93TW9kZVwiOmZhbHNlfSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xOVswXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xOVswXS5ydWxlc1swXS51c2VbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTE5WzBdLnJ1bGVzWzBdLnVzZVszXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHZ1ZS92dWUtbG9hZGVyLXYxNS9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1FSQ29kZVdpdGhMaW5rLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTcxY2M5OTdmJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTlbMF0ucnVsZXNbMF0udXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlL3Z1ZS1sb2FkZXItdjE1L2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTlbMF0ucnVsZXNbMF0udXNlWzJdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xOVswXS5ydWxlc1swXS51c2VbM10hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUvdnVlLWxvYWRlci12MTUvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9RUkNvZGVXaXRoTGluay52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD03MWNjOTk3ZiZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIpO1xuICAgICBpZihuZXdDb250ZW50Ll9fZXNNb2R1bGUpIG5ld0NvbnRlbnQgPSBuZXdDb250ZW50LmRlZmF1bHQ7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-style-loader/index.js??clonedRuleSet-19[0].rules[0].use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-19[0].rules[0].use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/adc-core/ui/QRCodeWithLink.vue?vue&type=style&index=0&id=71cc997f&lang=scss&scoped=true&\n");

/***/ })

}]);